
<!DOCTYPE html>
<html lang="zh-CN" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>自学VUE第五章笔记 - ly-blog</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="一个超级懒虫的博客,Composition APIsetup()：入口要使用组合式API，我们需要在组件中增加setup配置项，这是一个函数，返回一个对象，返回的对象可以像data中返回对象那样，其中的属性可以调用
1,"> 
    <meta name="author" content="Lazy-ly"> 
    <link rel="alternative" href="atom.xml" title="ly-blog" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.jpg"> 
    
    
    
    <meta name="twitter:card" content="summary"/>
    <meta name="twitter:title" content="自学VUE第五章笔记 - ly-blog"/>
    <meta name="twitter:description" content="一个超级懒虫的博客,Composition APIsetup()：入口要使用组合式API，我们需要在组件中增加setup配置项，这是一个函数，返回一个对象，返回的对象可以像data中返回对象那样，其中的属性可以调用
1,"/>
    
    
    
    
    <meta property="og:site_name" content="ly-blog"/>
    <meta property="og:type" content="object"/>
    <meta property="og:title" content="自学VUE第五章笔记 - ly-blog"/>
    <meta property="og:description" content="一个超级懒虫的博客,Composition APIsetup()：入口要使用组合式API，我们需要在组件中增加setup配置项，这是一个函数，返回一个对象，返回的对象可以像data中返回对象那样，其中的属性可以调用
1,"/>
    
<link rel="stylesheet" href="/css/diaspora.css">

    <script>window.searchDbPath = "/search.xml";</script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
<meta name="generator" content="Hexo 6.2.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">ly-blog</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://example.com"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">自学VUE第五章笔记</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">自学VUE第五章笔记</h1>
        <div class="stuff">
            <span>十月 12, 2022</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/VUE/" rel="tag">VUE</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/compositionAPI/" rel="tag">compositionAPI</a></li></ul>


        </div>
        <div class="content markdown">
            <h3 id="Composition-API"><a href="#Composition-API" class="headerlink" title="Composition API"></a>Composition API</h3><h4 id="setup-：入口"><a href="#setup-：入口" class="headerlink" title="setup()：入口"></a><code>setup()</code>：入口</h4><p>要使用组合式API，我们需要在组件中增加<code>setup</code>配置项，这是一个函数，返回一个对象，返回的对象可以像<code>data</code>中返回对象那样，其中的属性可以调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  import &#123;ref&#125; from &quot;vue&quot;;</span><br><span class="line">  export default &#123;</span><br><span class="line">    setup() &#123;</span><br><span class="line">      let list=ref([&#x27;listNode1&#x27;]);</span><br><span class="line">      console.log(list.value)</span><br><span class="line">      return &#123;</span><br><span class="line">        list:list,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>但像<code>components</code>这样的配置项还是得在<code>setup</code>外配置</p>
<h4 id="ref-定义响应式数据"><a href="#ref-定义响应式数据" class="headerlink" title="ref()定义响应式数据"></a><code>ref()</code>定义响应式数据</h4><p>直接在<code>setup</code>中返回的数据是非响应式的，如果想要转成响应式的，可以使用vue提供的<code>ref</code>函数</p>
<p><code>ref</code>函数接受多种类型的数据，并返回一个对象，在<code>setup</code>中要获取到值需要调用<code>value</code>，在标签中访问不需要</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  import &#123;ref&#125; from &quot;vue&quot;;</span><br><span class="line"></span><br><span class="line">  export default &#123;</span><br><span class="line">    setup() &#123;</span><br><span class="line">      let list=ref([&#x27;listNode1&#x27;]);</span><br><span class="line">      console.log(list.value)</span><br><span class="line">      return &#123;</span><br><span class="line">        list:list,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p v-for=&quot;node in list&quot;&gt;&#123;&#123;node&#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;button @click=&quot;list=[]&quot;&gt;删除&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<h4 id="reactive-另一种转换响应式数据的方法"><a href="#reactive-另一种转换响应式数据的方法" class="headerlink" title="reactive():另一种转换响应式数据的方法"></a><code>reactive()</code>:另一种转换响应式数据的方法</h4><p><code>reactive()</code>与<code>ref()</code>类似，但只接受对象类型的数据，直接返回一个代理，在<code>setup()</code>中不需要再使用<code>.value</code>访问</p>
<p>大部分情况直接使用<code>ref()</code>即可，但当要处理含有多个数据的对象为响应式时，可以使用<code>reactive()</code></p>
<h4 id="computed-监听响应式数据的变化"><a href="#computed-监听响应式数据的变化" class="headerlink" title="computed()监听响应式数据的变化"></a><code>computed()</code>监听响应式数据的变化</h4><p>使用vue提供的<code>computed()</code>可以监听响应式数据的变化，它接受一个回调函数，返回回调函数返回的值</p>
<p>下面是实现过滤列表的方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  import &#123;computed, ref&#125; from &quot;vue&quot;;</span><br><span class="line">  export default &#123;</span><br><span class="line">    setup() &#123;</span><br><span class="line">      let inputContent=ref(&#x27;&#x27;);//定义成响应式数据</span><br><span class="line">      let list=ref([&#x27;listNode1&#x27;,&#x27;listNode2&#x27;,&quot;listNode3&quot;,&quot;listNode4&quot;]);</span><br><span class="line">      let listFilter=computed(()=&gt;&#123;</span><br><span class="line">        if(inputContent.value===&#x27;&#x27;) &#123;</span><br><span class="line">          return list.value;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          return list.value.filter((node)=&gt;&#123;</span><br><span class="line">            return node.includes(inputContent.value)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      return &#123;</span><br><span class="line">        list:list,</span><br><span class="line">        inputContent:inputContent,</span><br><span class="line">        listFilter:listFilter</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p v-for=&quot;node in listFilter&quot;&gt;&#123;&#123;node&#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; v-model=&quot;inputContent&quot;&gt;</span><br><span class="line">  &lt;button @click=&quot;list=[]&quot;&gt;删除&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<h4 id="watch-监听响应式数据的变化"><a href="#watch-监听响应式数据的变化" class="headerlink" title="watch()监听响应式数据的变化"></a><code>watch()</code>监听响应式数据的变化</h4><p>和<code>options API</code>中一样，我们也可以使用<code>watch()</code>来监听响应式数据的变化</p>
<ul>
<li><p>监听基本数据类型</p>
<p>基本数据类型的响应性变量只能由<code>ref()</code>创建</p>
<ul>
<li><p>监听<code>ref()</code>本身，使用方式和<code>options API</code>中类似</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">watch</span>(inputContent,<span class="function">(<span class="params">newVal,oldVal</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(newVal+<span class="string">&quot;   &quot;</span>+oldVal);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>监听<code>ref().value</code>，不能直接替换，需要将第一个参数改为函数形式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">watch</span>(<span class="function">()=&gt;</span>&#123;<span class="keyword">return</span> inputContent.<span class="property">value</span>&#125;</span><br><span class="line">,<span class="function">(<span class="params">newVal,oldVal</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(newVal+<span class="string">&quot;   &quot;</span>+oldVal);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>监听对象中的基本数据类型的响应式数据</p>
<p>和监听<code>ref().value</code>一样</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">watch</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> title.<span class="property">value</span>.<span class="property">name</span></span><br><span class="line">&#125;,<span class="function">(<span class="params">newVal,oldVal</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(newVal+<span class="string">&#x27;,&#x27;</span>+oldVal)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>监听对象类型的响应式数据</p>
<p>直接用<code>watch</code>监听对象的响应性数据会失败，因为并没有比较对象中的每一个属性</p>
<ul>
<li><p>使用<code>deep</code></p>
<p>可以给<code>watch()</code>传递第三个参数，形式是一个对象，对象中可以配置deep属性为<code>ture</code>，这样就可以比较对象中的属性是否改变了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">watch</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> title.<span class="property">value</span></span><br><span class="line">&#125;,<span class="function">(<span class="params">newVal,oldVal</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(newVal+<span class="string">&#x27;,&#x27;</span>+oldVal)</span><br><span class="line">&#125;,&#123;</span><br><span class="line">  <span class="attr">deep</span>:<span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这种方法的缺点是只能获取到新值，因为旧值和新值的引用一样</p>
</li>
<li><p>对对象进行深度克隆</p>
<p>即在第一个参数的回调函数中返回对象的深克隆</p>
</li>
</ul>
</li>
<li><p>监听多个响应式数据</p>
<p>给第一个参数传递一个数组即可</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">watch</span>([inputContent,<span class="function">()=&gt;</span>title.<span class="property">value</span>.<span class="property">name</span>],<span class="function">(<span class="params">newVal,oldVal</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(newVal)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(oldVal)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="watchEffect-：变体的watch"><a href="#watchEffect-：变体的watch" class="headerlink" title="watchEffect()：变体的watch()"></a><code>watchEffect()</code>：变体的<code>watch()</code></h4><p><code>watchEffect()</code>接收一个回调函数，函数内涉及到的响应式数据一旦发生变化，就会重新执行一次<code>watchEffect()</code>。与<code>watch()</code>的区别是，它不管数据是否变化，声明后都会执行一次，相当于<code>do...while</code>,<code>watch</code>相当于<code>while</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">watchEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(inputContent.<span class="property">value</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>传递的函数也可以是<code>async</code>的</p>
<h4 id="watch-和watchEffect-清理操作"><a href="#watch-和watchEffect-清理操作" class="headerlink" title="watch()和watchEffect()清理操作"></a><code>watch()</code>和<code>watchEffect()</code>清理操作</h4><p>在<code>watch()</code>的第二个参数的回调函数中传入第三个参数<code>onInvalidate</code>然后调用即可</p>
<p>在<code>watchEffect()</code>传入的回调函数中传入参数<code>onInvalidate</code>然后调用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">watch</span>([inputContent,<span class="function">()=&gt;</span>title.<span class="property">value</span>.<span class="property">name</span>],<span class="function">(<span class="params">newVal,oldVal,onInvalidate</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(newVal)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(oldVal)</span><br><span class="line">  <span class="title function_">onInvalidate</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;一些清理操作&quot;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="title function_">watchEffect</span>(<span class="function">(<span class="params">onInvalidate</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(inputContent.<span class="property">value</span>)</span><br><span class="line">  <span class="title function_">onInvalidate</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;清理操作&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="传递和访问props"><a href="#传递和访问props" class="headerlink" title="传递和访问props"></a>传递和访问<code>props</code></h4><p>组件的<code>props</code>属性和<code>optionsAPI</code>一样定义成数组，在<code>setup</code>中传入第一个参数表示接收到的props对象，调用即可</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">props</span>:[<span class="string">&#x27;text&#x27;</span>,<span class="string">&#x27;message&#x27;</span>],</span><br><span class="line"><span class="title function_">setup</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(props.<span class="property">text</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="转换非响应性props为响应性"><a href="#转换非响应性props为响应性" class="headerlink" title="转换非响应性props为响应性"></a>转换非响应性props为响应性</h4><p>子组件接收到的<code>props</code>本身是响应性的，是一个<code>proxy</code>。</p>
<p>如果父组件传递的属性是响应性的，那么子组件接收到的也是响应性的</p>
<p>如果父组件传递的属性是普通的数据，子组件接收到的属性被解构出来就不是响应性的，需要转化成响应性的</p>
<p>使用<code>toRefs()</code>使解构后的对象为响应性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;msg&#125; = <span class="title function_">toRefs</span>(props);<span class="comment">//msg成为响应性数据</span></span><br></pre></td></tr></table></figure>

<h4 id="在setup-中使用methods"><a href="#在setup-中使用methods" class="headerlink" title="在setup()中使用methods"></a>在<code>setup()</code>中使用<code>methods</code></h4><p>直接在<code>setup()</code>中定义函数，要使用的话要在<code>return</code>语句中返回</p>
<h4 id="emit自定义事件"><a href="#emit自定义事件" class="headerlink" title="emit自定义事件"></a>emit自定义事件</h4><p><code>setup()</code>中接收第二个参数<code>context</code>，context对象有个<code>emit</code>属性，可以直接解构出来用于emit自定义事件</p>
<p>也可以和<code>optionsAPI</code>采取相同的方式<code>emit</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button @click=&quot;removeList(1)&quot;&gt;删除列表1&lt;/button&gt;</span><br><span class="line">  &lt;button @click=&quot;$emit(&#x27;remove2&#x27;)&quot;&gt;删除2&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    props:[],</span><br><span class="line">    emits:[&#x27;remove&#x27;,&#x27;remove2&#x27;],</span><br><span class="line">    setup(props,&#123;emit&#125;) &#123;</span><br><span class="line">      function removeList(id) &#123;</span><br><span class="line">        emit(&#x27;remove&#x27;,id);</span><br><span class="line">      &#125;</span><br><span class="line">      return &#123;removeList&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="使用生命周期钩子"><a href="#使用生命周期钩子" class="headerlink" title="使用生命周期钩子"></a>使用生命周期钩子</h4><p>在<code>compositionAPI</code>中生命周期钩子变成了函数形式，接收一个回调函数，所有的生命周期钩子函数名都是<code>on</code>+钩子名</p>
<p>没有<code>beforeCreate</code>和<code>created</code>钩子</p>
<h4 id="provide和inject"><a href="#provide和inject" class="headerlink" title="provide和inject"></a><code>provide</code>和<code>inject</code></h4><p>在<code>compositionAPI</code>中<code>provide</code>和<code>inject</code>变成了函数形式</p>
<p>在<code>setup()</code>中使用<code>provide()</code>,它接收两个参数，参数名和参数值</p>
<p>在<code>inject()</code>传入参数名，赋值给变量即可使用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">provide</span>(<span class="string">&#x27;title&#x27;</span>,movie.<span class="property">title</span>)</span><br><span class="line"><span class="title function_">inject</span>(<span class="string">&#x27;title&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>如果要传递响应性数据，可以使用<code>toRef</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">provide</span>(<span class="string">&#x27;title&#x27;</span>,<span class="title function_">toRef</span>(movie.<span class="property">value</span>,<span class="string">&#x27;title&#x27;</span>))</span><br></pre></td></tr></table></figure>

<h4 id="组件功能逻辑复用"><a href="#组件功能逻辑复用" class="headerlink" title="组件功能逻辑复用"></a>组件功能逻辑复用</h4><h4 id="script-setup简化组件代码"><a href="#script-setup简化组件代码" class="headerlink" title="script setup简化组件代码"></a><code>script setup</code>简化组件代码</h4><p>使用<code>script setup</code>可以进一步简化组件内的代码</p>
<p>import的组件可以直接使用无需配置</p>
<p>定义的函数，变量也可以直接在模板中使用，无需返回</p>
<p>使用<code>defineProps()</code>定义props，接收一个数组，定义之后就可以直接在模板中使用，在<code>script</code>中使用可以接收它的返回值</p>
<p>使用<code>defineEmits()</code>定义emits，接收一个数组，定义之后就可以直接在模板中使用，在函数中调用<code>emit()</code>函数上传事件</p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title="0" data-url="http://link.hhtjim.com/163/425570952.mp3"></li>
                        
                    
                        
                            <li title="1" data-url="http://link.hhtjim.com/163/425570952.mp3"></li>
                        
                    
                </ul>
            
        </div>
        
        
    <div id="gitalk-container" class="comment link"
		data-enable="false"
        data-ae="false"
        data-ci=""
        data-cs=""
        data-r=""
        data-o=""
        data-a=""
        data-d="false"
    >查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>






</html>
