
<!DOCTYPE html>
<html lang="zh-CN" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>软件综合实践 - ly-blog</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="一个超级懒虫的博客,软件综合实践这篇文章是对学院课程《软件综合实践》的学习整理，主要是编译原理的部分过程学习（编译前端）
省略了第一章的内容
词法分析词法分析过程将源程序文件视作一个字符型文本文件并读取字符，将其分为若,"> 
    <meta name="author" content="Lazy-ly"> 
    <link rel="alternative" href="atom.xml" title="ly-blog" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.jpg"> 
    
    
    
    <meta name="twitter:card" content="summary"/>
    <meta name="twitter:title" content="软件综合实践 - ly-blog"/>
    <meta name="twitter:description" content="一个超级懒虫的博客,软件综合实践这篇文章是对学院课程《软件综合实践》的学习整理，主要是编译原理的部分过程学习（编译前端）
省略了第一章的内容
词法分析词法分析过程将源程序文件视作一个字符型文本文件并读取字符，将其分为若,"/>
    
    
    
    
    <meta property="og:site_name" content="ly-blog"/>
    <meta property="og:type" content="object"/>
    <meta property="og:title" content="软件综合实践 - ly-blog"/>
    <meta property="og:description" content="一个超级懒虫的博客,软件综合实践这篇文章是对学院课程《软件综合实践》的学习整理，主要是编译原理的部分过程学习（编译前端）
省略了第一章的内容
词法分析词法分析过程将源程序文件视作一个字符型文本文件并读取字符，将其分为若,"/>
    
<link rel="stylesheet" href="/css/diaspora.css">

    <script>window.searchDbPath = "/search.xml";</script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
<meta name="generator" content="Hexo 6.2.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">ly-blog</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://example.com"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">软件综合实践</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">软件综合实践</h1>
        <div class="stuff">
            <span>十二月 22, 2022</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/%E7%BC%96%E8%AF%91%E5%89%8D%E7%AB%AF/" rel="tag">编译前端</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" rel="tag">编译原理</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/" rel="tag">词法分析</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/" rel="tag">语法分析</a></li></ul>


        </div>
        <div class="content markdown">
            <h3 id="软件综合实践"><a href="#软件综合实践" class="headerlink" title="软件综合实践"></a>软件综合实践</h3><p>这篇文章是对学院课程《软件综合实践》的学习整理，主要是编译原理的部分过程学习（编译前端）</p>
<p>省略了第一章的内容</p>
<h4 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h4><p>词法分析过程将源程序文件视作一个字符型文本文件并读取字符，将其分为若干个记号（token）。每个token都是表示源程序中信息单元的字符序列，如关键字（keyword），标识符（identifier），特殊符号（special symbol）等。token表示扫描程序从剩余字符串开头识别或匹配的某种字符格式</p>
<p>因此扫描程序的任务是格式匹配的一种。我们需要研究扫描过程中的格式说明和识别方法，其中最重要的是<strong>正则表达式</strong>和<strong>有穷自动机</strong>。扫描程序也是编译器处理源代码输入的部分，需要尽可能高校，要注意实际细节</p>
<p>我们通过以下几个部分来研究扫描程序：</p>
<ol>
<li>学习扫描程序操作的概述以及涉及到的结构和概念</li>
<li>学习正则表达式</li>
<li>学习有穷自动机（它是对正则给出的串格式的识别算法）</li>
<li>学习如何编写相关程序</li>
</ol>
<h5 id="扫描处理"><a href="#扫描处理" class="headerlink" title="扫描处理"></a>扫描处理</h5><p>扫描处理的任务是读取源程序代码字符并生成token，token就是编译器之后部分（通常是分析程序）处理的逻辑单元。扫描处理类似于在一个英文语句中将字母拼成一个个单词的处理</p>
<p>token在c中常被定义成枚举类型，如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    IF, THEN, ELSE, PLUS, MINUS, NUM, ID, ...</span><br><span class="line">&#125; TokenTyoe;</span><br></pre></td></tr></table></figure>

<p>token包含若干种类型，分为保留字（如<code>IF THEN</code>），特殊符号（如<code>PLUS MINUS</code>,表示+和-），多字符串的记号（如<code>NUM ID</code>表示数字和标识符）</p>
<p>token必须和它们表示的字符串完全区分开，如<code>IF</code>和<code>if</code>要做区别。token对应的字符串可以被称作token的词义，一个token可以有一个（如保留字）或者无限多个串值（如标识符）。任何与token相关的值都可以成为token的属性（attribute），如上面的串值就是一个属性，记号也可以有其他属性，如某个<code>NUM</code>有一个”114514”的串值属性，也有代表真实值114514的数字值属性。</p>
<p>为了之后的处理，扫描程序要求至少要有与token所需相等的属性。例如如果需要计算<code>NUM</code>的串值，直接取串值即可，就不需要计算数字值了。因为扫描程序需要计算每一个token的相关属性，把若干属性收集到一个数据类型中是很有用的，这种数据类型成为记号记录（token record），如，在C中可将记号记录声明为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    TokenType tokenval;</span><br><span class="line">    <span class="type">char</span> * stringval;</span><br><span class="line">    <span class="type">int</span> numval;</span><br><span class="line">&#125; TokenRecord;<span class="comment">//假设只需要数字属性和串值属性</span></span><br></pre></td></tr></table></figure>

<p>虽然扫描程序需要将整个源程序转化为token序列，但很少会一次性完成它。实际上扫描程序是在分析程序的控制下进行操作的，它通过一个函数从输入中读取字符串并返回下一个token。在C中，可以声明一个这样的函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TokenType <span class="title function_">getToken</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>这个函数会计算如串值这样的属性，并返回下一个记号。我们并不给这个函数提供参数，实际上参数被保存在缓冲区中。</p>
<p>下面开始研究字符串中定于和识别格式的方式</p>
<h5 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h5><p>正则表达式是一种匹配模式，它表示它匹配的所有字符串的集合。</p>
<ul>
<li><p>定义</p>
<ul>
<li><p>基本正则表达式</p>
<p>它们是字母表中的单个字符且自身匹配。如<code>L(a) = &#123;a&#125;</code>用来匹配a字符。特殊情况下还需要用到其他两个字符。一个是空串，表示不包含任何字符串，用ε表示（<code>L(ε) = ε</code>），另一个是与任何串都不匹配的符号，称它为空集（{}），用符号∅表示（<code>L(∅) = &#123;&#125;</code>）;{}与{ε}的区别是前者不会匹配任何串而后者会匹配空串</p>
</li>
<li><p>运算</p>
<p>包含三种基本运算</p>
<ul>
<li><p>从各对象中选择：用|表示</p>
<p>如果r和s是正则表达式，r|s表示可以被r或被s匹配的串集</p>
</li>
<li><p>连结：不需要添加符号</p>
<p>r和s的连结可以写作rs，表示两串连结后的串集，如<code>ab</code>只匹配ab，但<code>(a|b)c</code>匹配ac或bc，<code>(a|b)(c|d)</code>则会匹配ac，ad，bc，bd</p>
</li>
<li><p>重复：用元字符*表示</p>
<p>r*表示匹配串的任意又穷连结，每个连结匹配均为r。可以理解为匹配0到n个r，如<code>(a|bb)*</code>可匹配a，bb，abb，aaa，aabba等</p>
</li>
</ul>
</li>
<li><p>优先级与括号</p>
<p>三种运算中，重复（*）优先级最高，其次是连结，最后是选择（|）。当要使用不同的优先顺序时，要加括号</p>
</li>
<li><p>给正则命名</p>
<p>为较长的正则命名可以简化书写，如要匹配给一个或多个数字，正则表达式为<code>(0|1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)*</code></p>
<p>给<code>(0|1|2|3|4|5|6|7|8|9)</code>命名为<code>digit</code>则可以简化为<code>digit digit*</code></p>
<p>但这样做也增加了复杂度，这使得正则表达式的名称变成了元字符，需要一个方法将其和普通字符串做区别，而且名字中不能含有名字，不能递归表示</p>
</li>
</ul>
</li>
<li><p>拓展</p>
<p>除了上面的三种基本运算，还可以定义一些常用的拓展新运算</p>
<ul>
<li><p>一个或多个重复</p>
<p>用+表示。<code>(0|1)+</code>&#x3D;&#x3D;<code>(0|1)(0|1)*</code></p>
</li>
<li><p>字母表中的任意字符</p>
<p>用<code>.</code>表示与任意字符匹配</p>
</li>
<li><p>字符范围</p>
<p>如果要表示一个范围的某个字符，可以用方括号和连字符表示。如<code>[a-z]</code>表示小写字母，<code>[0-9]</code>表示数字，<code>[abc]</code>表示<code>a|b|c</code>，<code>[a-zA-Z]</code>表示大小写字母表</p>
</li>
<li><p>不在给定范围内的字符</p>
<p>用<del>表示非。如&#96;</del>(a|b|c)&#96;表示abc以外的字符。</p>
</li>
<li><p>可选的字符</p>
<p>用?表示某字符是可选的，如<code>(+?)[0-9]</code>表示数字前的加号是可选的</p>
</li>
</ul>
</li>
<li><p>token的正则表达式</p>
<p>这里先简单讨论一下token的典型正则</p>
<ul>
<li><p>数</p>
<p>这里的数包括自然数，十进制数，带指数（e&#x2F;E）的数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nat = [<span class="number">0</span><span class="number">-9</span>]+</span><br><span class="line">signedNat = (+|-)?nat</span><br><span class="line">number = signedNat(.nat)?(EsignedNat)?</span><br></pre></td></tr></table></figure>
</li>
<li><p>保留字</p>
<p>保留字（关键字）是固定的，用|选择即可</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reserved = <span class="keyword">if</span>|<span class="keyword">while</span>|<span class="keyword">do</span>|<span class="keyword">for</span>...</span><br></pre></td></tr></table></figure>
</li>
<li><p>标识符</p>
<p>一般来说标识符以字母开头并且只包含数字和字母</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">letter = [a-zA-Z]</span><br><span class="line">digit = [<span class="number">0</span><span class="number">-9</span>]</span><br><span class="line">identifier = letter(letter|digit)*</span><br></pre></td></tr></table></figure>
</li>
<li><p>注释</p>
<p>注释一般有两种，前后为分隔符的自由格式，或者一个或多个特殊字符开头并到这行结尾</p>
<p>到本行结尾的注释比较简单，如在c中为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//(~\n)*</span></span><br></pre></td></tr></table></figure>

<p>但当分隔符多于一个时,如<code>/* */</code>时情况就复杂的多，扫描程序往往会通过特殊办法解决。</p>
<p>在一些语言中，注释是可以嵌套的，所以这就要求正则表达式统计数量，但这是正则表达式不能实现的</p>
</li>
<li><p>二义性，空白格和先行</p>
<p>有些串可以被不同的正则表达式匹配。比如按照上面的标准，if既可以是标识符又可以是关键字。程序语言必须规定应该遵循哪个规则，但正则表达式做不到。可以做出如下处理：</p>
<p>当串既是标识符又是关键字时，取做关键字</p>
<p>当串既是单个记号又可以是若干记号的序列时，解释为单个记号。这常常被称作“最长子串原理”：可组成单个token的字符最长串在任何时候都假设为代表下一个token（这理解起来感觉很晦涩，但中文译版是这样翻译的，原文好像也是这么写的。查了一下可以理解为当字符串的一个或者多个子串可以进行匹配时取最长的子串匹配）。</p>
<p>在使用最长子串原理时会遇到记号分隔符（token delimiter）的问题。如在<code>x=y</code>中，等号将标识符x分隔，因为等号不是标识符的一部分。一般认为空格，换行，tab是记号分隔符。我们需要定义空白格伪记号（原文是这么写，可以理解为就是一种token），可以这样定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whitespace = (newline|blank|tab|comment)+<span class="comment">//换行，空格，tab，注释</span></span><br></pre></td></tr></table></figure>

<p>但要注意空格通常不当作记号分隔符而是直接被忽略掉，有这种忽略行为的语言的扫描程序需要检查记号分隔符后舍弃空格。</p>
<p>分隔符会结束掉某个token串，但分隔符不是token的一部分。因此扫描程序必须要处理先行（lookahead）问题。（文中关于lookahead的部分描述的难懂，给出一个易懂的解释：先行问题就是有些token必须要读到它们的后一位才能判断是否结束）</p>
</li>
</ul>
</li>
</ul>
<h5 id="有穷自动机"><a href="#有穷自动机" class="headerlink" title="有穷自动机"></a>有穷自动机</h5><p>有穷自动机的图形描述：用一个箭头线指向一个圆圈代表初始状态，从这个圆圈（初始状态）再引出箭头，箭头上标注字符集代表匹配条件，指向下一个状态，如此下去，直到到达最终状态（接受状态）。接受状态用一个边界为双线的圆圈表示。（参照pdf42页图2-1）。</p>
<h6 id="确定性有穷状态机"><a href="#确定性有穷状态机" class="headerlink" title="确定性有穷状态机"></a>确定性有穷状态机</h6><p>确定性有穷自动机（DFA）：下一个状态由当前状态和当前输入字符唯一给出的自动机（也就是根据当前状态和字符可以确定的到达下一个状态）。</p>
<p>数学描述比较抽象，不描述，可以参考pdfP43</p>
<h6 id="先行，回溯和非确定性自动机"><a href="#先行，回溯和非确定性自动机" class="headerlink" title="先行，回溯和非确定性自动机"></a>先行，回溯和非确定性自动机</h6><p>我们先继续学习DFA表示的精确算法。</p>
<p>注意到DFA图示只是给出了运算的要点。即使是数学公式也不能描述所有方面。比如不能描述出错时的错误是什么。</p>
<p>  举标识符的DFA为例，出错状态并不是真正的错误，而是表示该字符不能被识别（比如遇到了分隔符），此时识别应该结束，应该接受并生成token，所以对DFA做出改进，得到图2-5所示（PDFP46）。</p>
<p>  现在再考虑初始状态。若所有token都是以不同字符开头的就会比较好处理，一个初始状态加上不同的起始字符箭头即可，但实际上不是这样，如&lt;,&lt;&#x3D;就是相同起始字符的token，若按之前的表示方法表示，就不符合DFA的定义了（确定性）。一个解决方法是拓展有穷自动机的定义，让它包括对某个特定字符能存在多个转换。这种新型自动机被称为非确定性有穷自动机（NFA）。</p>
<p>  在给出NFA的定义前，先要引入ε-转换的概念。ε-转换是无需考虑和消耗任何字串就可以发生的转换。可以看作对空串的匹配。引入ε-转换的好处是能够方便的合并一些token的DFA，还能清晰的描述出空串的匹配。（具体可以看p48底部的部分）。</p>
<p>  NFA的定义与DFA很像，但需要拓展字母表（要包含ε）和拓展函数T（现在能够一对多了）的含义。具体数学定义不给出，参考p49</p>
<h6 id="代码实现有穷自动机"><a href="#代码实现有穷自动机" class="headerlink" title="代码实现有穷自动机"></a>代码实现有穷自动机</h6><p>  这里的方法并不都会用在扫描程序中，扫描程序相关的代码部分会在后面展开</p>
<p>  原文中这一节的伪代码和代码似乎都是Fortran语言的，这里用C格式表示</p>
<p>  考虑标识符的DFA,实现它最简单的方法如下（伪代码）：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//现在处于状态1（初始状态）</span></span><br><span class="line"><span class="comment">//假设现在读到的字符为character，下一个字符为character.next</span></span><br><span class="line"><span class="keyword">if</span>(isLetter(character.next)==<span class="literal">true</span>) &#123;<span class="comment">//如果下一个字符是字母</span></span><br><span class="line">    character = character.next;<span class="comment">//这里开始向后移动输入（进入状态2）</span></span><br><span class="line">    <span class="keyword">while</span>(isDigit(character.next)||isLetter(character.next)) &#123;</span><br><span class="line">        <span class="comment">//如果下一个字符是数字或字母</span></span><br><span class="line">        character = character.next;<span class="comment">//这里向后移动输入（保持状态2）        </span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//结束循环，说明读到了分隔符，达到状态3（接受状态）</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//其他情况或错误</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>  这种方式用输入的移动来表示状态的改变。当一个DFA没有多少状态时，这样编写没什么问题。但它也有缺点。当状态增多或者路径增多时会变得很麻烦，而且每个算法都是特殊的，必须用略微不同的方法处理不同的DFA，这难以实现。</p>
<p>  另一个方法是定义一个状态变量，并把转换写进switch…case…语句中，避免出现在循环中</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//仍是上一个代码块的表述</span></span><br><span class="line"><span class="type">int</span> state = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(state == <span class="number">1</span> || state ==<span class="number">2</span>) &#123;</span><br><span class="line">   <span class="keyword">switch</span>(state) &#123;</span><br><span class="line">       <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">          <span class="comment">//原文这里还是一个switch...case...筛选character,但在c中不允许这样表示</span></span><br><span class="line">          <span class="keyword">if</span>(isLetter(character) == <span class="literal">true</span>) &#123;</span><br><span class="line">              character = character.next;</span><br><span class="line">              state = <span class="number">2</span>;<span class="comment">//进入状态2</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              state = ...；<span class="comment">//其他状态，表示错误或者其他情况</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>；</span><br><span class="line">       <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">           <span class="keyword">if</span>(isDigit(character.next)||isLetter(character.next)) &#123;</span><br><span class="line">				state = <span class="number">2</span>;</span><br><span class="line">               	character = character.next;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               state = <span class="number">3</span>;<span class="comment">//进入状态3（接受状态）</span></span><br><span class="line">           &#125;    </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(state = <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="comment">//accepted</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  除了这种方法之外，还可以将DFA表示为数据结构，写成一类代码。转换表或者二维数组就可以解决这个问题。可以参照P53内容，大意是创建一个二维数组T用来表示转换，列表示状态，行表示输入，数组元素值表示在该状态下输入该字符后转换到的状态。表中空白处的值由二维数组Advance定义，这是一个布尔类型的数组，用于判断。下面给出一段示例代码</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> state = <span class="number">1</span>;</span><br><span class="line"><span class="type">char</span> character = character.next;</span><br><span class="line"><span class="type">int</span> Accepted[<span class="number">5</span>] = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>];</span><br><span class="line"><span class="keyword">while</span>(!Accepted[state]&amp;&amp;!error[state]) &#123;</span><br><span class="line">  <span class="type">int</span> newState = T[state][<span class="type">char</span>];<span class="comment">//从T数组中读取状态</span></span><br><span class="line">  <span class="keyword">if</span>(Advance[state][<span class="type">char</span>]) &#123;<span class="comment">//空白为false,处理先行，否则为true,继续读取</span></span><br><span class="line">    character = character.next;</span><br><span class="line">  &#125;</span><br><span class="line">  state = newState;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(Accepted[state]) &#123;</span><br><span class="line">  accepted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  这种方式称为表驱动，虽然简化了代码，但表格会变得异常大，造成了很多内存上的浪费，依赖于诸如稀疏矩阵的压缩等方法进行处理。</p>
<p>  NFA的实现将在之后讲述</p>
<h5 id="从正则表达式到DFA"><a href="#从正则表达式到DFA" class="headerlink" title="从正则表达式到DFA"></a>从正则表达式到DFA</h5><p>   将正则表达式翻译成DFA最简单的方式是通过中间构造，先将正则表达式翻译成NFA,在将NFA翻译成DFA,最后将DFA转换为程序实现</p>
<ul>
<li>从正则表达式到NFA</li>
</ul>
<pre><code>这里的核心思想是使用ε-转换表示并置，选择，重复等。原书中的插图简单易懂，可以阅读P56-P58的图示理解
</code></pre>
<ul>
<li><p>从NFA到DFA</p>
<p>现在给定任意一个NFA，要把它转换为DFA，首先要做的就是消除ε-转换。消除ε-转换涉及到构造ε-闭包的操作。ε-闭包是通过ε-转换能到达的所有状态的集合。而我们要进行的，消除单个字符多重转换涉及到通过单个字符可到达的状态的集合。两个过程都要求考虑集合而不是单个状态。下面先来研究构造ε-闭包</p>
<p>原书中用一个例子表述了如何构造ε-闭包，这个例子还是通俗易懂的，参考p59</p>
<p>先构造每个状态的ε-闭包，一个集合的ε-闭包就是每个单独状态的ε-闭包的和</p>
<p>现在再来看通过给定NFA（假设用$M$表示）来构造DFA（假设称为$\overline{M}$）。我们先计算$M$的初始状态ε闭包，这就是$\overline{M}$ 的初始状态。对于这个初始状态集合S，对于输入的字符a，再计算在a上发生的装换的集合S‘，再计算S’的闭包…重复下去直到不再生成新的转换或状态。对于具体过程原书中也给出了一个通俗易懂的例子，参考P59例2.1</p>
</li>
<li><p>将DFA的状态数最小化</p>
<p>上面生成DFA的方法有一个缺点：生成的DFA可能比较复杂。扫描程序中为保证高效率，构造的DFA理论上应该是最小的。实际上，自动机理论中有一个很重要的结果：对于任何给定的DFA,都有一个含有最少量状态等价的DFA,而且这个最小状态数的DFA是唯一的，我们可以从任何指定的DFA中直接得到最小状态的DFA。</p>
<p>原书中还是举了两个例子，可以参考P62。算法的思路大致是将所有的接受状态先视作一个整体，然后对每一个字符进行讨论，若每个状态下该字符造成的转换都相同，就视为一个整体，若出现异样，就分割。通过这种从整体一次次分割来保证最少的状态数</p>
</li>
</ul>
<h5 id="TINY扫描程序的实现"><a href="#TINY扫描程序的实现" class="headerlink" title="TINY扫描程序的实现"></a>TINY扫描程序的实现</h5><p>这里就直接结合源码分析了</p>
<p>首先在<code>global.h</code>文件中用枚举类型定义了token</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> </span></span><br><span class="line"><span class="class">    /* <span class="title">book</span>-<span class="title">keeping</span> <span class="title">tokens</span> 内务记号用于标记（文件末尾<span class="title">EOF</span>和错误<span class="title">ERROR</span>）*/</span></span><br><span class="line"><span class="class">   &#123;</span>ENDFILE,ERROR,</span><br><span class="line">    <span class="comment">/* reserved words 保留字*/</span></span><br><span class="line">    IF,THEN,ELSE,END,REPEAT,UNTIL,READ,WRITE,</span><br><span class="line">    <span class="comment">/* multicharacter tokens 多字符token*/</span></span><br><span class="line">    ID,NUM,</span><br><span class="line">    <span class="comment">/* special symbols 特殊符号*/</span></span><br><span class="line">    ASSIGN,EQ,LT,PLUS,MINUS,TIMES,OVER,LPAREN,RPAREN,SEMI</span><br><span class="line">   &#125; TokenType;</span><br></pre></td></tr></table></figure>

<p>图2.8（pdfP64）给出了一个要实现的DFA图示，在<code>scan.h</code>和<code>scan.c</code>中有对应实现</p>
<p>在scan.c中，用枚举类型定义了状态，和图2.8中一致</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* states in scanner DFA */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">   &#123;</span> START,INASSIGN,INCOMMENT,INNUM,INID,DONE &#125;</span><br><span class="line">   StateType;</span><br></pre></td></tr></table></figure>

<p>在global.h中还定义了文件变量source和list，以及一个整型变量lineno，它们也在扫描程序中使用，分别表示源代码文件和输出的文件，若开启打印扫描细节时才会用作标记的行号</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在main.c中初始化</span></span><br><span class="line"><span class="keyword">extern</span> FILE* source; <span class="comment">/* source code text file */</span></span><br><span class="line"><span class="keyword">extern</span> FILE* listing; <span class="comment">/* listing output text file */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> lineno; <span class="comment">/* source line number for listing */</span></span><br></pre></td></tr></table></figure>

<p>在scan.h中定义了MAXTOKENLEN,表示token串值的最大长度，为40。在scan.c中定义了tokenString，长度最大为41,则标识符不能超过40个字符（算上空字符）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//scan.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXTOKENLEN 40</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//scan.c</span></span><br><span class="line"><span class="comment">/* lexeme of identifier or reserved word */</span></span><br><span class="line"><span class="type">char</span> tokenString[MAXTOKENLEN+<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p>scan.c中还定义了一些静态变量，他们的作用在注释里给出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* BUFLEN = length of the input buffer for</span></span><br><span class="line"><span class="comment">   source code lines */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFLEN 256<span class="comment">//定义缓冲区长度为256</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> lineBuf[BUFLEN]; <span class="comment">/* holds the current line缓冲区对应的字符串 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> linepos = <span class="number">0</span>; <span class="comment">/* current position in LineBuf在缓冲区字符串中的位置 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> bufsize = <span class="number">0</span>; <span class="comment">/* current size of buffer string缓冲区字符串的长度 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> EOF_flag = FALSE; <span class="comment">/* corrects ungetNextChar behavior on EOF文件末尾标志 */</span></span><br></pre></td></tr></table></figure>

<p>扫描程序通过<code>getNextChar</code>函数读取字符，函数的逻辑是：当前位置不在末尾时，直接返回当前位置的字符并让位置加一，当前位置若在末尾了，就利用<code>fgets</code>从source文件中更新缓冲区字符串（lineBuf），同时增加lineno,刷新linepos和bufsize。如果不能读取新的一行，就说明已经到末尾了，修改EOF_flag。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">getNextChar</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; <span class="keyword">if</span> (!(linepos &lt; bufsize))<span class="comment">//判断是否到达缓冲区字符串尾部</span></span><br><span class="line">    <span class="comment">//到了尾部，更新缓冲区</span></span><br><span class="line">  &#123; lineno++;</span><br><span class="line">   <span class="comment">//从source中读取新的一行的BUFLEN-1长度的字符串并赋值给lineBuf</span></span><br><span class="line">    <span class="keyword">if</span> (fgets(lineBuf,BUFLEN<span class="number">-1</span>,source))</span><br><span class="line">    &#123; <span class="keyword">if</span> (EchoSource) <span class="built_in">fprintf</span>(listing,<span class="string">&quot;%4d: %s&quot;</span>,lineno,lineBuf);</span><br><span class="line">      bufsize = <span class="built_in">strlen</span>(lineBuf);</span><br><span class="line">      linepos = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span> lineBuf[linepos++];<span class="comment">//更新完成后返回字符</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//读取失败，说明到了尾部</span></span><br><span class="line">    &#123; EOF_flag = TRUE;</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">//没到尾部，直接返回</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> lineBuf[linepos++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>getNextChar</code>函数读取一行的最长长度是255个字符，因此要求源码程序一行的字符数不能超过255</p>
<p>还有一个<code>ungetNextChar</code>函数，用于处理先行，当读多了的时候需要回退</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ungetNextChar</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; <span class="keyword">if</span> (!EOF_flag) linepos-- ;&#125;<span class="comment">//将位置回退一个字符</span></span><br></pre></td></tr></table></figure>

<p>然后来分析关键的getToken函数，因为这个函数比较长，其中也涉及到其他函数，先拆开来分析，最后给出完整的代码注释   </p>
<p>在最前面是对一些必要的变量的定义</p>
<p>tokenStringIndex是用于标识tokenString的当前字符所在的位置，因为改变字符串要给char数组赋值，需要一个数组下标。</p>
<p>currentToken,表示getToken函数返回的token</p>
<p>state,表示状态，初始状态是START</p>
<p>save,一个标志变量，用于标记是否要将字符存进tokenString里                                            </p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*index for storing into tokenString下标 */</span></span><br><span class="line"><span class="type">int</span> tokenStringIndex = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* holds current token to be returned表示返回的token */</span></span><br><span class="line">TokenType currentToken;</span><br><span class="line"><span class="comment">/* current state - always begins at START状态变量 */</span></span><br><span class="line">StateType state = START;</span><br><span class="line"><span class="comment">/* flag to indicate save to tokenString标志变量 */</span></span><br><span class="line"><span class="type">int</span> save;</span><br></pre></td></tr></table></figure>

<p>获取token的逻辑和之前所说的定义一个状态变量，并把转换写进switch…case…语句中的方法是类似的</p>
<p>先进入一个while循环，当状态不为结束状态时执行循环</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (state != DONE)&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>  然后从缓冲区中开始获取字符，并将save先设置成true（默认读取的字符需要存进tokenString)，接着开始switch…case区分状态</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> c = getNextChar();</span><br><span class="line">     save = TRUE;</span><br><span class="line">     <span class="keyword">switch</span> (state)&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>switch中的内容比较多，但知道原理之后可以发现都是简单的选择判断</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> START:</span><br><span class="line">         <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c))<span class="comment">//若当前字符为数字</span></span><br><span class="line">           state = INNUM;<span class="comment">//进入INNUM状态（数）</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isalpha</span>(c))<span class="comment">//若为字母</span></span><br><span class="line">           state = INID;<span class="comment">//进入ID状态（标识符）</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;:&#x27;</span>)<span class="comment">//若为:</span></span><br><span class="line">           state = INASSIGN;<span class="comment">//进入INASSIGN状态</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> ((c == <span class="string">&#x27; &#x27;</span>) || (c == <span class="string">&#x27;\t&#x27;</span>) || (c == <span class="string">&#x27;\n&#x27;</span>))<span class="comment">//若开头就是空格/tab/换行</span></span><br><span class="line">           save = FALSE;<span class="comment">//忽略</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;&#123;&#x27;</span>)<span class="comment">//若为注释符</span></span><br><span class="line">         &#123; save = FALSE;<span class="comment">//忽略</span></span><br><span class="line">           state = INCOMMENT;<span class="comment">//进入INCOMMENT状态（注释）</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span><span class="comment">//否则就是单字符的特殊字符</span></span><br><span class="line">         &#123; state = DONE;<span class="comment">//进入完成状态</span></span><br><span class="line">           <span class="keyword">switch</span> (c)<span class="comment">//根据读到字符的类型开始给token赋值</span></span><br><span class="line">           &#123; <span class="keyword">case</span> EOF:</span><br><span class="line">               save = FALSE;</span><br><span class="line">               currentToken = ENDFILE;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">             <span class="keyword">case</span> <span class="string">&#x27;=&#x27;</span>:</span><br><span class="line">               currentToken = EQ;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">             <span class="keyword">case</span> <span class="string">&#x27;&lt;&#x27;</span>:</span><br><span class="line">               currentToken = LT;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">             <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">               currentToken = PLUS;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">             <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">               currentToken = MINUS;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">             <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">               currentToken = TIMES;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">             <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">               currentToken = OVER;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">             <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">               currentToken = LPAREN;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">             <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">               currentToken = RPAREN;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">             <span class="keyword">case</span> <span class="string">&#x27;;&#x27;</span>:</span><br><span class="line">               currentToken = SEMI;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">             <span class="keyword">default</span>:</span><br><span class="line">               currentToken = ERROR;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//对INCOMMENT状态的处理</span></span><br><span class="line">       <span class="keyword">case</span> INCOMMENT:</span><br><span class="line">         save = FALSE;<span class="comment">//注释内容不保存</span></span><br><span class="line">         <span class="keyword">if</span> (c == EOF)<span class="comment">//如果注释一直到了文件末尾</span></span><br><span class="line">         &#123; state = DONE;<span class="comment">//进入结束状态</span></span><br><span class="line">           currentToken = ENDFILE;<span class="comment">//token赋值为ENDFILE</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;&#125;&#x27;</span>) state = START;<span class="comment">//读到&#125;结束注释，回到start状态（注释也是分隔符）</span></span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//对INASSIGN状态的处理</span></span><br><span class="line">       <span class="keyword">case</span> INASSIGN:</span><br><span class="line">         state = DONE;<span class="comment">//该次处理一定能判断出token类型，状态改变为结束状态</span></span><br><span class="line">         <span class="keyword">if</span> (c == <span class="string">&#x27;=&#x27;</span>)<span class="comment">//如果为：=，表示赋值</span></span><br><span class="line">           currentToken = ASSIGN;</span><br><span class="line">         <span class="keyword">else</span><span class="comment">//否则就是错误符号</span></span><br><span class="line">         &#123; <span class="comment">/* backup in the input */</span></span><br><span class="line">           ungetNextChar();<span class="comment">//读到的其他符号不能保存，回退一个字符</span></span><br><span class="line">           save = FALSE;<span class="comment">//不保存</span></span><br><span class="line">           currentToken = ERROR;<span class="comment">//为错误类型的TOKEN</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//对INNUM状态的处理</span></span><br><span class="line">       <span class="keyword">case</span> INNUM:</span><br><span class="line">         <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(c))<span class="comment">//如果读到的不是数字就结束</span></span><br><span class="line">         &#123; <span class="comment">/* backup in the input */</span></span><br><span class="line">           ungetNextChar();<span class="comment">//不储存这个非数字字符，回退</span></span><br><span class="line">           save = FALSE;<span class="comment">//不保存这个字符</span></span><br><span class="line">           state = DONE;<span class="comment">//状态更新为结束状态</span></span><br><span class="line">           currentToken = NUM;<span class="comment">//给token赋值为数</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//对INID状态的处理，和INNUM类似</span></span><br><span class="line">       <span class="keyword">case</span> INID:</span><br><span class="line">         <span class="keyword">if</span> (!<span class="built_in">isalpha</span>(c))</span><br><span class="line">         &#123; <span class="comment">/* backup in the input */</span></span><br><span class="line">           ungetNextChar();</span><br><span class="line">           save = FALSE;</span><br><span class="line">           state = DONE;</span><br><span class="line">           currentToken = ID;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//对DONE状态无需处理</span></span><br><span class="line">       <span class="keyword">case</span> DONE:</span><br><span class="line">       <span class="keyword">default</span>: <span class="comment">/* should never happen不属于上面的任何一个状态，报错 */</span></span><br><span class="line">         <span class="built_in">fprintf</span>(listing,<span class="string">&quot;Scanner Bug: state= %d\n&quot;</span>,state);</span><br><span class="line">         state = DONE;</span><br><span class="line">         currentToken = ERROR;</span><br><span class="line">         <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>switch…case…完，更改状态和token一遍之后，开始将读到的字符存入tokenString</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((save) &amp;&amp; (tokenStringIndex &lt;= MAXTOKENLEN))<span class="comment">//需要存入并且没标识符没超过上限</span></span><br><span class="line">  tokenString[tokenStringIndex++] = (<span class="type">char</span>) c;<span class="comment">//将字符存入tokenString</span></span><br></pre></td></tr></table></figure>

<p>上面并没有对DONE状态做处理，进入DONE状态后，首先需要在tokenString末尾补上\0结束，然后要考虑标识符是不是保留字</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (state == DONE)</span><br><span class="line">&#123; tokenString[tokenStringIndex] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  <span class="keyword">if</span> (currentToken == ID)</span><br><span class="line">    currentToken = reservedLookup(tokenString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里判断是否为保留字的函数为<code>reservedLookup</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> TokenType <span class="title function_">reservedLookup</span> <span class="params">(<span class="type">char</span> * s)</span></span><br><span class="line">&#123; <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;MAXRESERVED;i++)</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(s,reservedWords[i].str))</span><br><span class="line">      <span class="keyword">return</span> reservedWords[i].tok;<span class="comment">//若tokenString和保留字相等，返回该保留字作为token</span></span><br><span class="line">  <span class="keyword">return</span> ID;<span class="comment">//没有匹配成功，还是标识符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面将传入的tokenString和reservedWords比较</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span> <span class="type">char</span>* str;</span><br><span class="line">      TokenType tok;</span><br><span class="line">    &#125; reservedWords[MAXRESERVED]</span><br><span class="line">   = &#123;&#123;<span class="string">&quot;if&quot;</span>,IF&#125;,&#123;<span class="string">&quot;then&quot;</span>,THEN&#125;,&#123;<span class="string">&quot;else&quot;</span>,ELSE&#125;,&#123;<span class="string">&quot;end&quot;</span>,END&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;repeat&quot;</span>,REPEAT&#125;,&#123;<span class="string">&quot;until&quot;</span>,UNTIL&#125;,&#123;<span class="string">&quot;read&quot;</span>,READ&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;write&quot;</span>,WRITE&#125;&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>reservedWord</code>是一个结构体数组，每个结构体有str表示tokenString和tok表示对应的token，传入的tokenString和数组中每一个结构体的str比较，相同的话就返回对应token</p>
<p>getToken函数最后面还有一个if判断，传入一个全局变量（可以当作开关），为true就会打印出扫描细节</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (TraceScan) &#123;</span><br><span class="line">  <span class="built_in">fprintf</span>(listing,<span class="string">&quot;\t%d: &quot;</span>,lineno);</span><br><span class="line">  printToken(currentToken,tokenString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里用到了<code>printToken</code>函数，它定义在util.c中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printToken</span><span class="params">( TokenType token, <span class="type">const</span> <span class="type">char</span>* tokenString )</span></span><br><span class="line">&#123; <span class="keyword">switch</span> (token)</span><br><span class="line">  &#123; <span class="keyword">case</span> IF:</span><br><span class="line">    <span class="keyword">case</span> THEN:</span><br><span class="line">    <span class="keyword">case</span> ELSE:</span><br><span class="line">    <span class="keyword">case</span> END:</span><br><span class="line">    <span class="keyword">case</span> REPEAT:</span><br><span class="line">    <span class="keyword">case</span> UNTIL:</span><br><span class="line">    <span class="keyword">case</span> READ:</span><br><span class="line">    <span class="keyword">case</span> WRITE:</span><br><span class="line">      <span class="built_in">fprintf</span>(listing,</span><br><span class="line">         <span class="string">&quot;reserved word: %s\n&quot;</span>,tokenString);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ASSIGN: <span class="built_in">fprintf</span>(listing,<span class="string">&quot;:=\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LT: <span class="built_in">fprintf</span>(listing,<span class="string">&quot;&lt;\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> EQ: <span class="built_in">fprintf</span>(listing,<span class="string">&quot;=\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LPAREN: <span class="built_in">fprintf</span>(listing,<span class="string">&quot;(\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> RPAREN: <span class="built_in">fprintf</span>(listing,<span class="string">&quot;)\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SEMI: <span class="built_in">fprintf</span>(listing,<span class="string">&quot;;\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> PLUS: <span class="built_in">fprintf</span>(listing,<span class="string">&quot;+\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MINUS: <span class="built_in">fprintf</span>(listing,<span class="string">&quot;-\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> TIMES: <span class="built_in">fprintf</span>(listing,<span class="string">&quot;*\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> OVER: <span class="built_in">fprintf</span>(listing,<span class="string">&quot;/\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ENDFILE: <span class="built_in">fprintf</span>(listing,<span class="string">&quot;EOF\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> NUM:</span><br><span class="line">      <span class="built_in">fprintf</span>(listing,</span><br><span class="line">          <span class="string">&quot;NUM, val= %s\n&quot;</span>,tokenString);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ID:</span><br><span class="line">      <span class="built_in">fprintf</span>(listing,</span><br><span class="line">          <span class="string">&quot;ID, name= %s\n&quot;</span>,tokenString);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ERROR:</span><br><span class="line">      <span class="built_in">fprintf</span>(listing,</span><br><span class="line">          <span class="string">&quot;ERROR: %s\n&quot;</span>,tokenString);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">/* should never happen */</span></span><br><span class="line">      <span class="built_in">fprintf</span>(listing,<span class="string">&quot;Unknown token: %d\n&quot;</span>,token);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很简单的switch…case，根据token的不同类型打印对应内容</p>
<p>这就是scan.c的内容，可以生成单个token并返回</p>
<h5 id="用Lex自动生成扫描程序"><a href="#用Lex自动生成扫描程序" class="headerlink" title="用Lex自动生成扫描程序"></a>用Lex自动生成扫描程序</h5><p>本节依然是针对TINY语言开发扫描程序，但使用Lex扫描程序生成器生成扫描程序。</p>
<p>如果你已经安装配置好了flex的话，在lex文件夹下运行<code>flex tiny.l</code>，就可以生成一个扫描程序<code>lex.yy.c</code>，用这个去替换scan.c即可</p>
<p>Lex是一个包含了正则表达式的文本文件作为其输出的程序，此外还包括每一个表达式被匹配时采取的动作</p>
<h6 id="正则表达式的lex约定"><a href="#正则表达式的lex约定" class="headerlink" title="正则表达式的lex约定"></a>正则表达式的lex约定</h6><p>直接给出法则如下</p>
<ul>
<li>a：匹配字符a</li>
<li>“a”：即使a是元字符，也匹配字符a，对于普通字符a,也匹配</li>
<li>\a：a为元字符时，匹配字符a</li>
<li>a*：a的零次或多次重复</li>
<li>a+：a的一次或多次重复</li>
<li>a?：一个可选的a</li>
<li>a|b：a或b</li>
<li>(a)：a本身</li>
<li>[abc]：abc中的任意一个</li>
<li>[a-d]：abcd中任意一个</li>
<li>[^ab]：除了a或b外的任意一个字符</li>
<li>.：除换行外的任意一个字符</li>
<li>{xxx}：名字为xxx的正则表达式</li>
</ul>
<h6 id="Lex输入文件的格式"><a href="#Lex输入文件的格式" class="headerlink" title="Lex输入文件的格式"></a>Lex输入文件的格式</h6><p>Lex输入文件由三部分组成：定义（definition）集，规则（rule）集以及辅助程序（auxiliary routine）集或者用户程序（user routine）集。这三个部分用双百分号隔开，因此Lex输入格式如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;definition&#125;</span><br><span class="line">%%</span><br><span class="line">&#123;rules&#125;</span><br><span class="line">%%</span><br><span class="line">&#123;auxiliary routine&#125;</span><br></pre></td></tr></table></figure>

<p>直接结合<code>tiny.l</code>来看</p>
<p>先看定义集部分</p>
<p>首先包括一个用<code>%&#123;&#125;%</code>括起来的部分，这一部分可以理解为宏定义，在这一部分里写的c代码会转换到生成的<code>lex.yy.c</code>的最前面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;globals.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;util.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;scan.h&quot;</span></span></span><br><span class="line"><span class="comment">/* lexeme of identifier or reserved word */</span></span><br><span class="line"><span class="type">char</span> tokenString[MAXTOKENLEN+<span class="number">1</span>];</span><br><span class="line">%&#125;</span><br></pre></td></tr></table></figure>

<p>然后是定义一些正则名称和表达式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">digit       [<span class="number">0</span><span class="number">-9</span>]</span><br><span class="line">number      &#123;digit&#125;+</span><br><span class="line">letter      [a-zA-Z]</span><br><span class="line">identifier  &#123;letter&#125;+</span><br><span class="line">newline     \n                                                                 </span><br><span class="line">whitespace  [ \t]+</span><br></pre></td></tr></table></figure>

<p>然后就是以双百分号分界，后面便是最重要的规则集</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;if&quot;</span>            &#123;<span class="keyword">return</span> IF;&#125;</span><br><span class="line"><span class="string">&quot;then&quot;</span>          &#123;<span class="keyword">return</span> THEN;&#125;</span><br><span class="line"><span class="string">&quot;else&quot;</span>          &#123;<span class="keyword">return</span> ELSE;&#125;</span><br><span class="line"><span class="string">&quot;end&quot;</span>           &#123;<span class="keyword">return</span> END;&#125;</span><br><span class="line"><span class="string">&quot;repeat&quot;</span>        &#123;<span class="keyword">return</span> REPEAT;&#125;</span><br><span class="line"><span class="string">&quot;until&quot;</span>         &#123;<span class="keyword">return</span> UNTIL;&#125;</span><br><span class="line"><span class="string">&quot;read&quot;</span>          &#123;<span class="keyword">return</span> READ;&#125;</span><br><span class="line"><span class="string">&quot;write&quot;</span>         &#123;<span class="keyword">return</span> WRITE;&#125;</span><br><span class="line"><span class="string">&quot;:=&quot;</span>            &#123;<span class="keyword">return</span> ASSIGN;&#125;</span><br><span class="line"><span class="string">&quot;=&quot;</span>             &#123;<span class="keyword">return</span> EQ;&#125;</span><br><span class="line"><span class="string">&quot;&lt;&quot;</span>             &#123;<span class="keyword">return</span> LT;&#125;</span><br><span class="line"><span class="string">&quot;+&quot;</span>             &#123;<span class="keyword">return</span> PLUS;&#125;</span><br><span class="line"><span class="string">&quot;-&quot;</span>             &#123;<span class="keyword">return</span> MINUS;&#125;</span><br><span class="line"><span class="string">&quot;*&quot;</span>             &#123;<span class="keyword">return</span> TIMES;&#125;</span><br><span class="line"><span class="string">&quot;/&quot;</span>             &#123;<span class="keyword">return</span> OVER;&#125;</span><br><span class="line"><span class="string">&quot;(&quot;</span>             &#123;<span class="keyword">return</span> LPAREN;&#125;</span><br><span class="line"><span class="string">&quot;)&quot;</span>             &#123;<span class="keyword">return</span> RPAREN;&#125;</span><br><span class="line"><span class="string">&quot;;&quot;</span>             &#123;<span class="keyword">return</span> SEMI;&#125;</span><br><span class="line">&#123;number&#125;        &#123;<span class="keyword">return</span> NUM;&#125;</span><br><span class="line">&#123;identifier&#125;    &#123;<span class="keyword">return</span> ID;&#125;</span><br><span class="line">&#123;newline&#125;       &#123;lineno++;&#125;</span><br><span class="line">&#123;whitespace&#125;    &#123;<span class="comment">/* skip whitespace */</span>&#125;</span><br><span class="line"><span class="string">&quot;&#123;&quot;</span>             &#123; <span class="type">char</span> c;</span><br><span class="line">                  <span class="keyword">do</span></span><br><span class="line">                  &#123; c = input();</span><br><span class="line">                    <span class="keyword">if</span> (c == EOF) <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">if</span> (c == <span class="string">&#x27;\n&#x27;</span>) lineno++;</span><br><span class="line">                  &#125; <span class="keyword">while</span> (c != <span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">.               &#123;<span class="keyword">return</span> ERROR;&#125;</span><br></pre></td></tr></table></figure>

<p>规则集的每一行都有两个部分构成：正则表达式和匹配时执行的c代码。c代码要写在大括号内（这个大括号是分隔含义，要与c的大括号区别）。</p>
<p>为了处理多义性，如标识符和保留字，lex会先进行最长字串匹配，如果最长字串匹配后仍具有多义性，按照规则集的书写顺序匹配。可以看到规则集中先写明了保留字的匹配规则，因此当读到保留字对应字段时lex会当作保留字而不是标识符匹配。</p>
<p>然后就是最后的辅助程序段，这部分的代码也会原封不动的被搬进生成的扫描程序，用于辅助运行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">TokenType <span class="title function_">getToken</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; <span class="type">static</span> <span class="type">int</span> firstTime = TRUE;</span><br><span class="line">  TokenType currentToken;</span><br><span class="line">  <span class="keyword">if</span> (firstTime)</span><br><span class="line">  &#123; firstTime = FALSE;</span><br><span class="line">    lineno++;</span><br><span class="line">    yyin = source;                                                                     </span><br><span class="line">    yyout = listing;</span><br><span class="line">  &#125;</span><br><span class="line">  currentToken = yylex();</span><br><span class="line">  <span class="built_in">strncpy</span>(tokenString,yytext,MAXTOKENLEN);</span><br><span class="line">  <span class="keyword">if</span> (TraceScan) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(listing,<span class="string">&quot;\t%d: &quot;</span>,lineno);</span><br><span class="line">    printToken(currentToken,tokenString);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> currentToken;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体逻辑不再解释，理解文件结构即可。</p>
<p>原书词法分析的部分到此为止，下面开始讲解语法分析</p>
<h4 id="上下文无关语法及分析"><a href="#上下文无关语法及分析" class="headerlink" title="上下文无关语法及分析"></a>上下文无关语法及分析</h4><p>分析的任务是确定程序的语法，因此这个过程又被称为语法分析。程序设计语言的语法通常是由上下文无关的文法规则给出。在学习分析算法和如何利用算法之前要先学习上下文无关文法的理论。分析按照构造语法树的方式可分为两种算法：自顶向下分析和自底向上分析，在后续会提到这两种方法。</p>
<h5 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h5><p>分析程序的任务是从由扫描程序产生的token中确定程序的语法结构，隐式或显式的构造出能表示该结构的分析树和语法树。可以将分析程序看成一个函数，它接收扫描程序产生的token作为输入并生成语法树作为输出。分析步骤可减为对分析程序的调用:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">syntaxTree = parse();</span><br></pre></td></tr></table></figure>

<p> 对于单遍编译来说，分析程序中包含了所有的其他阶段，不需要显示的构造语法树了，而多遍编译会将语法树作为输入。</p>
<h5 id="上下文无关文法"><a href="#上下文无关文法" class="headerlink" title="上下文无关文法"></a>上下文无关文法</h5><p>上下文无关文法用于说明程序设计语言的语法结构。这种说明方式除了涉及到递归之外，和使用正则表达式的词法结构十分相似。</p>
<h6 id="与正则表达式比较"><a href="#与正则表达式比较" class="headerlink" title="与正则表达式比较"></a>与正则表达式比较</h6><p>基本正则表达式有3中运算：选择（|），并置，重复（*），以及命名用等号。</p>
<p>文法规则使用相似的表示法：|还是表示选择，并置也仍然存在，但是不存在重复了。另外，命名使用了箭头→而不是等号&#x3D;，这是因为现在的名字涉及到了更加复杂的定义过程，这是由定义的递归本质决定的，如下面这个例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exp</span> → <span class="built_in">exp</span> op <span class="built_in">exp</span>|(<span class="built_in">exp</span>)|number</span><br><span class="line">op → +|-|*</span><br></pre></td></tr></table></figure>

<p>这里涉及了一个表达式的文法，exp的规则就是递归的。</p>
<p>文法规则还将正则表达式作为部件，如在exp规则中使用了number。这个例子中使用的文法格式通常被称为BNF文法（Back-Naur form）</p>
<h6 id="上下文无关文法规则的说明"><a href="#上下文无关文法规则的说明" class="headerlink" title="上下文无关文法规则的说明"></a>上下文无关文法规则的说明</h6><p>与正则表达式类似，文法规则也定义在一个字母表或符号集之上。在正则中，这些符号一般就是指字符，而在文法规则中，符号通常指的是表示字符串的记号，这里的记号就是一个固定的符号，对于能表示多个字符串的标识符和数字记号来说，用斜体表示。如将TINY语言的记号字母表表示为集合：</p>
<p>{if, then, else, end, repeat, until, read, write, <em>identify</em>, <em>number</em>, +, -, *, &#x2F;, &#x3D;, &lt;, (, ), ;, :&#x3D;}</p>
<p>假设有一个字母表，BNF的上下文无关文法规则是由符号串组成。第一个符号是结构名字，第二个符号是元字符→，这个符号之后是一个符号串，串中每个符号都是字母表中的符号（一个结构的名字）或者元字符|</p>
<p>当然这并没有统一的标准，例如代替→的字符通常有&#x3D;、:、::&#x3D;， 代替斜体的方法使用尖括号括住名字，将斜体换为大写。使用不同的惯例，写出来的文法规则也不一样</p>
<p>BNF中还会经常使用到括号划分优先级，区分括号与元字符括号的方法是在括号两边加上引号（”(“）</p>
<p>由于括号里面的内容可以定义成新的规则（如将<code>(+|-|*)</code>定义成<code>op</code>），括号其实并不是不可或缺，如果规定左边的相同名字可以出现无数次的话，|也不是不可或缺，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exp → exp op exp</span><br><span class="line">exp → (exp)</span><br><span class="line">exp → number</span><br></pre></td></tr></table></figure>

<p>然而通常并不这么做，还是将所有选择放在一个规则里表示</p>
<h6 id="推导及由文法定义的语言"><a href="#推导及由文法定义的语言" class="headerlink" title="推导及由文法定义的语言"></a>推导及由文法定义的语言</h6><p>如现在给出一个表达式：<code>(34 - 3)*42</code></p>
<p>则他与含有七个记号的串对应：<code>(number - number)*number</code></p>
<p>其中number记号是一个正规的表达式，他与<code>exp → number</code>对应</p>
<p>文法规则通过推导确定记号符号的正规串。推导是指在文法规则的右边进行选择并替换，举个例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">exp =&gt; exp op exp</span><br><span class="line">	=&gt; exp op number</span><br><span class="line">	=&gt; exp * number</span><br><span class="line">	=&gt; (exp) * number</span><br><span class="line">	=&gt; (exp op exp)* number</span><br><span class="line">	=&gt; (exp op number) * number</span><br><span class="line">	=&gt; (exp - number) * number</span><br><span class="line">	=&gt; (number - number) * number</span><br></pre></td></tr></table></figure>

<p>这样就完成了(34 - 3)*42的推导</p>
<p>由推导从exp中得到的所有记号符号的串集是 被表达式的文法定义的语言。这个语言包括了所有合乎语法的表达式。用符号表示：<code>L(G) = &#123;s|exp =&gt;* s&#125;</code></p>
<p>G代表表达式文法，s代表记号符号的任意数组串（也称为句子），&#x3D;&gt;*表示由替换序列组成的推导（*表示多次，与正则中的重复很像）。通过推导产生L(G)中的串。</p>
<p>一些术语可以更好的区别结构与符号，结构必须被进一步替换，他们被称作非终结符，而符号终结推导，被称为终结符。</p>
<p>如果要产生空串，可以定义<code>empty → ε</code>。这样的文法规则被称为ε-产生式，任何包括了空串的文法至少要有一个ε-产生式。如可以将正则表达式a*写成文法规则<code>A → Aa|ε</code></p>
<h5 id="分析树和抽象语法树"><a href="#分析树和抽象语法树" class="headerlink" title="分析树和抽象语法树"></a>分析树和抽象语法树</h5><h6 id="分析树"><a href="#分析树" class="headerlink" title="分析树"></a>分析树</h6><p>通过推导可以生成分析树，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">exp =&gt; exp op exp</span><br><span class="line">	=&gt; number op exp</span><br><span class="line">	=&gt; number * exp</span><br><span class="line">	=&gt; number * number</span><br></pre></td></tr></table></figure>

<p> 这个推导可以生成下面的分析树（省略树枝）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">		exp</span><br><span class="line"></span><br><span class="line">exp		op		exp</span><br><span class="line"></span><br><span class="line">number	*		number</span><br></pre></td></tr></table></figure>

<p>如果考虑推导顺序，还可以进行编号：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">		1exp</span><br><span class="line"></span><br><span class="line">2exp	3op		4exp</span><br><span class="line"></span><br><span class="line">number	*		number</span><br></pre></td></tr></table></figure>

<p>推导因为顺序原因可以是多种多样的。最左推导指每次推导都替换掉最左非终结符的推导，最右同理</p>
<p> 根据最左推导和最右推导，可以构造出具有前序编号和后序编号的分析树（可以参考pdfP88,P89的向噶U内内容）</p>
<h6 id="抽象语法树"><a href="#抽象语法树" class="headerlink" title="抽象语法树"></a>抽象语法树</h6><p>分析树虽然能完整的表示推导的过程，但它提供的信息太多了，在编译过程中我们并不需要那么多信息，这时候我们就需要对分析树进行优化，创建抽象语法树</p>
<p>仍以上一节的例子为例，先为分析树加上一些额外信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">		exp</span><br><span class="line"></span><br><span class="line">exp		op		exp</span><br><span class="line"></span><br><span class="line">number	*		number</span><br><span class="line">3				4</span><br></pre></td></tr></table></figure>

<p>表示3*4的运算，我们进行优化后得到抽象语法树</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">		*</span><br><span class="line">	/		\</span><br><span class="line">3				4</span><br></pre></td></tr></table></figure>

<p>这样省略的推导，且能够表示出相同的信息</p>
<p>再考虑(3*4)*4</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">				*</span><br><span class="line">			/		\</span><br><span class="line">		*				4</span><br><span class="line">	/		\</span><br><span class="line">3				4</span><br></pre></td></tr></table></figure>

<p>虽然省略了括号但仍然能清晰的表示(3*4)*4的含义</p>
<p>我们可以由一个数据类型定义这样的抽象语法树</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span>Plus, Minus, Times&#125; OpKind;<span class="comment">//操作符类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span>OpKind, ConstKind&#125; ExpKind;<span class="comment">//表达式类型，带操作符或常量</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">streenode</span> &#123;</span></span><br><span class="line">    ExpKind kind;</span><br><span class="line">    OpKind op;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">streenode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span><span class="comment">//带操作符的话需要左右节点</span></span><br><span class="line">    <span class="type">int</span> val;<span class="comment">//不带操作符的定值</span></span><br><span class="line">&#125; sTreeNode;</span><br><span class="line"><span class="keyword">typedef</span> sTreeNode *SyntaxTree;</span><br></pre></td></tr></table></figure>

<h5 id="二义性"><a href="#二义性" class="headerlink" title="二义性"></a>二义性</h5><h6 id="二义性文法"><a href="#二义性文法" class="headerlink" title="二义性文法"></a>二义性文法</h6><p>考虑串<code>2-1*3</code>，即使使用最左推导，它仍然能推导出两种分析树</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">					exp</span><br><span class="line">			 /       |       \			</span><br><span class="line">		exp			op			exp</span><br><span class="line">    /   |     \      |            |</span><br><span class="line">exp		op		exp	 *			number</span><br><span class="line"> |      |        |</span><br><span class="line">number	-		number</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">	exp</span><br><span class="line">/	 |	  		\</span><br><span class="line">exp  op    		exp</span><br><span class="line"> |	  |		/	 |    \	</span><br><span class="line">number	  -	   exp	 op     exp</span><br><span class="line">               |     |       |</span><br><span class="line">              number *      number</span><br></pre></td></tr></table></figure>

<p>抽象语法树也对应有两种</p>
<p>能产生两种不同分析树的串的文法被称为二义性文法，这种文法不能准确的指示出程序的语法结构，所以是分析程序必须解决的问题。</p>
<p>基本的解决方法有两个。一个是设置一个规则，这个规则可以在二义性情况下指出哪个分析树是对的，这种方法的缺点在于语言的语法结构再也不能由文法规则单独提供了。另一个办法是将文法强制改变成一个能产生正确分析树的文法，这样不会产生二义性了。</p>
<p>当然我们要确定哪个语法树是正确的，很明显，先乘后减的运算是正确的。要消除这个运算的二义性，我们可以设置*的优先级更高的规则。但这样并不能规避所有的二义性，如2-1-5，不同的推导仍然会产生二义性，所以又需要制定一个规则：减法运算为左结合（认为一个减法序列的运算是自左向右的）</p>
<p>所以对于简单的表达式文法，可以有一个规则规定加减乘为左结合。</p>
<p>下面不再讨论通过规则消除二义性，而是通过重写文法来消除二义性。</p>
<h6 id="优先权和结合性"><a href="#优先权和结合性" class="headerlink" title="优先权和结合性"></a>优先权和结合性</h6><p>为了处理文法中优先级的问题，就要把具有相同优先级的运算符归到一组里，现在重写简单表达式的文法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">exp → exp addop exp|term</span><br><span class="line">addop → +|-</span><br><span class="line">term → term mulop term | factor</span><br><span class="line">mulop → *</span><br><span class="line">factor → (exp)|number</span><br></pre></td></tr></table></figure>

<p>这样乘法被归到了term规则下，而加减法被归到了exp规则下，这样生成的抽象语法树中加减法始终在上部，因此它们的优先级就降低了。这种分组被称为优先级联</p>
<p>这种文法解决了优先级，但没有解决结合性，解决办法是用基本情况代替递归，再次重写规则</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">exp → exp addop term|term</span><br><span class="line">addop → +|-</span><br><span class="line">term → term mulop term | factor</span><br><span class="line">mulop → *</span><br><span class="line">factor → (exp)|number</span><br></pre></td></tr></table></figure>

<p><code>exp → exp addop term|term</code>使得加减运算符左结合，而<code>exp → term addop add|term</code>使得右结合。</p>
<p>现在让所有运算都左结合</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">exp → exp addop term|term</span><br><span class="line">addop → +|-</span><br><span class="line">term → term mulop factor | factor</span><br><span class="line">mulop → *</span><br><span class="line">factor → (exp)|number</span><br></pre></td></tr></table></figure>

<p>优先级联使分析树变得复杂，但抽象语法树不受影响</p>
<h6 id="悬挂else问题"><a href="#悬挂else问题" class="headerlink" title="悬挂else问题"></a>悬挂else问题</h6><p>考虑下面的简化版本的if语句文法（把判断语句简化为0|1,把其他语句简化为other）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">statement → if-stmt|other</span><br><span class="line">if-stmt → if(exp) statement|if(exp) statement else statement</span><br><span class="line">exp → 0|1</span><br></pre></td></tr></table></figure>

<p>考虑下面的串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(0) if(1) other else other</span><br></pre></td></tr></table></figure>

<p>这里同样有二义性，指的是else与第一个if匹配还是第二个if匹配。这种二义性称为悬挂else问题。很明显，在c语言中，else应该与第二个if匹配，如果要与第一个if匹配，就要加大括号</p>
<p>解决办法比之前的麻烦一些</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">statment → matched-stmt|unmatched-stmt</span><br><span class="line">matched-stmt → if(exp) mathched-stmt else matched-stmt|other</span><br><span class="line">unmathched-stmt → if(exp) statement | if(exp) mathched-stmt else unmatched-stmt </span><br><span class="line">exp → 0|1</span><br></pre></td></tr></table></figure>

<p>这样只有一个matched-stmt会出现在else之前，使得能够正确匹配</p>
<p>但通常不在BNF中建立这样的规则，主要原因是分析办法很容易按照遵循最近嵌套规则的方法来配置</p>
<h6 id="无关紧要的二义性"><a href="#无关紧要的二义性" class="headerlink" title="无关紧要的二义性"></a>无关紧要的二义性</h6><p>有些二义性可能会生成唯一的语法树，或者语法树虽然不同但语义是相同的（比如乘法的结合律），这种二义性称为无关紧要的二义性。然而分析算法却要提供一些消除二义性的规则。</p>
<h5 id="拓展的表示法：EBNF和语法图"><a href="#拓展的表示法：EBNF和语法图" class="headerlink" title="拓展的表示法：EBNF和语法图"></a>拓展的表示法：EBNF和语法图</h5><h6 id="EBNF表示法"><a href="#EBNF表示法" class="headerlink" title="EBNF表示法"></a>EBNF表示法</h6><p>重复和可选的结构在程序设计语言中很普遍，在BNF文法规则中也是一样的。BNF表示法有时扩展到包含这两种特殊表示法，我们称之为拓展的BNF或EBNF表示法</p>
<p>EBNF选择用花括号{…}表示重复</p>
<p>例如将<code>A→aA|b</code>这种右递归改写为重复形式：<code>A → &#123;a&#125;b</code></p>
<p>这种写法的一个问题是让分析树的构造不清楚，但不用在意，左递归和右递归仍然能够区分</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">右递归：A → &#123;a&#125;b</span><br><span class="line">左递归：A → b&#123;a&#125;</span><br></pre></td></tr></table></figure>

<p>通常使用左递归的形式</p>
<p>在结合性的表示中也会出现问题，如在表示加减法的文法规则<code>exp → exp addop term | term </code>，在EBNF中写作：<code>exp → term &#123;addop term&#125;</code>，虽然看不出来，但我们可以规定它暗示了左结合，同理，也可以写出右结合：<code>exp → &#123;term addop&#125; term</code>。但事实并不是这样，如：</p>
<p><code>stmt-sequence → stmt;stmt-sequence|stmt</code> 可以看成一个<code>stmt</code>后接可选的<code>;sequence-stmt</code></p>
<p>在EBNF中可选用方括号<code>[]</code>表示,如可选else就可以写成</p>
<p><code>if-stmt → if(exp) statement [else statement]</code></p>
<p>上面的例子也可以写作<code>stmt-sequence → stmt[;stmt-sequence]</code>                                                                                                                                                                                                                                                                                                                                                                                          </p>
<h6 id="语法图"><a href="#语法图" class="headerlink" title="语法图"></a>语法图</h6><p>用作可视地表示EBNF规则的图形表示法被称为语法图。它们由表示终结符和非终结符的方框，表示序列和选择的带箭头的线，非终结符标记组成，用圆形和椭圆形框表示终结符，方形框和矩形框则表示非终结符</p>
<p>具体图示参考PDFP101及其后内容</p>
<h5 id="上下文无关语言的形式特性"><a href="#上下文无关语言的形式特性" class="headerlink" title="上下文无关语言的形式特性"></a>上下文无关语言的形式特性</h5><p>这里是用更正式的数学方法写出前面提到的术语和定义，这里就不展开了，可以参考PDFP103-P107</p>
<h5 id="TINY语言的语法"><a href="#TINY语言的语法" class="headerlink" title="TINY语言的语法"></a>TINY语言的语法</h5><h6 id="TINY语言的上下文无关语法"><a href="#TINY语言的上下文无关语法" class="headerlink" title="TINY语言的上下文无关语法"></a>TINY语言的上下文无关语法</h6><p>下面先给出TINY语言的BNF文法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">program → stmt-sequence</span><br><span class="line">stmt-sequence → stmt-sequence ; statement | statement</span><br><span class="line">statement → if-stmt | repeat-stmt | read-stmt | write-stmt</span><br><span class="line">if-stmt → if exp then stmt-sequence end</span><br><span class="line">		  | if exp then stmt-sequence else stmt-sequence end</span><br><span class="line">repeat-stmt → repeat stmt-sequence until exp</span><br><span class="line">assign-stmt → identifier := exp</span><br><span class="line">read-stmt → read identifier</span><br><span class="line">write-stmt → write exp</span><br><span class="line">exp → simple-exp comparision-op simple-exp | simple-exp</span><br><span class="line">comparison-op → &lt; | =</span><br><span class="line">simple-exp → simple-exp addop term | term</span><br><span class="line">addop → +|-</span><br><span class="line">term → term mulop factor | factor</span><br><span class="line">mulop → *|/</span><br><span class="line">factor → (exp) | number | identifier</span><br></pre></td></tr></table></figure>

<p>可以看到TINY程序只是一个语句序列，它有五种语句：if语句，repeat语句，read语句，write语句，assignment语句。if语句使用end作为括号关键字因此不存在悬挂else问题。read语句一次读入一个变量，而write语句一次只写出一个表达式。表达式有两类，比较表达式（使用&lt;和&#x3D;作为操作符），算术表达式（使用+-*&#x2F;作为运算符）。TINY没有声明语句 ，只通过赋值语句来隐式声明一个变量，只有一个作用域（全局作用域）且没有过程和函数</p>
<p>另外一点是TINY使用分号来分隔语句但最后一个语句末尾没有分号，因为TINY没有空语句</p>
<p>因为这一章并没有涉及到更多的分析细节，重点在于理论学习，这里只分析少许代码</p>
<p>在global.h中定义了语法树的结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**************************************************/</span></span><br><span class="line"><span class="comment">/***********   Syntax tree for parsing ************/</span></span><br><span class="line"><span class="comment">/**************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span>StmtK,ExpK&#125; NodeKind;<span class="comment">//枚举定义节点类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span>IfK,RepeatK,AssignK,ReadK,WriteK&#125; StmtKind;<span class="comment">//枚举定义语句类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span>OpK,ConstK,IdK&#125; ExpKind;<span class="comment">//枚举定义表达式类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ExpType is used for type checking */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span>Void,Integer,Boolean&#125; ExpType;<span class="comment">//枚举定义表达式的值的类型</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXCHILDREN 3<span class="comment">//定义子节点的最大数目（给数组开辟空间）</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span></span></span><br><span class="line"><span class="class">   &#123;</span> <span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span> * <span class="title">child</span>[<span class="title">MAXCHILDREN</span>];</span><span class="comment">//子节点</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span> * <span class="title">sibling</span>;</span><span class="comment">//同级节点，如用分号隔开的多个语句</span></span><br><span class="line">     <span class="type">int</span> lineno;<span class="comment">//行号，和词法分析里的作用一样</span></span><br><span class="line">     NodeKind nodekind;<span class="comment">//节点类型</span></span><br><span class="line">     <span class="class"><span class="keyword">union</span> &#123;</span> StmtKind stmt; ExpKind <span class="built_in">exp</span>;&#125; kind;<span class="comment">//种类（是语句或者表达式）</span></span><br><span class="line">     <span class="class"><span class="keyword">union</span> &#123;</span> TokenType op;</span><br><span class="line">             <span class="type">int</span> val;</span><br><span class="line">             <span class="type">char</span> * name; &#125; attr;<span class="comment">//节点的属性（操作符，数字值，标识符的串值）</span></span><br><span class="line">     ExpType type; <span class="comment">/* for type checking of exp 表达式的值的类型 */</span></span><br><span class="line">   &#125; TreeNode;</span><br></pre></td></tr></table></figure>

<p>本章到此结束，下面开始讲解分析过程</p>
<h4 id="自顶向下的分析"><a href="#自顶向下的分析" class="headerlink" title="自顶向下的分析"></a>自顶向下的分析</h4><p>自顶向下的分析算法通过在最左推导中描述出各个步骤来分析记号串输入。之所以称为是自顶向下是因为分析树中隐含的编号是前序编号，且顺序是由根到叶。</p>
<p>自顶向下的分析程序有两类：回溯分析程序和预测分析程序。预测分析程序试图用一个或多个先行记号来预测输入串的下一个构造，而回溯分析程序试图分析其他有可能的输入，当失败时就回溯备份。虽然回溯分析程序更加强大，但都太慢了，对于编译器并不合适，本书不研究回溯分析程序</p>
<p>本章要学习的两类自顶向下分析算法分别是递归下降分析和LL(1)分析。递归下降比较常用，且对于手写程序最为合适，因此先学习递归下降的分析算法。LL(1)在实际中不常用到，所以只是简单学习，它是下一张自底向上算法的前奏。</p>
<h5 id="使用递归下降分析算法进行自顶向下的分析"><a href="#使用递归下降分析算法进行自顶向下的分析" class="headerlink" title="使用递归下降分析算法进行自顶向下的分析"></a>使用递归下降分析算法进行自顶向下的分析</h5><h6 id="递归下降分析的基本方法"><a href="#递归下降分析的基本方法" class="headerlink" title="递归下降分析的基本方法"></a>递归下降分析的基本方法</h6><p>递归下降分析的概念很简单：将一个非终结符A的文法规则看作识别A的一个过程。	</p>
<p>考虑前一章的表达式文法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">exp → exp addop term|term</span><br><span class="line">addop → +|-</span><br><span class="line">term → term mulop factor | factor</span><br><span class="line">mulop → *</span><br><span class="line">factor → (exp)|number</span><br></pre></td></tr></table></figure>

<p>考虑对其中的factor进行递归下降分析，可以写出这样的伪代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">TokenType * <span class="title function_">factor</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(token == <span class="string">&#x27;:&#x27;</span>) &#123;</span><br><span class="line">    match(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">    <span class="built_in">exp</span>();</span><br><span class="line">    match(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(token == number) &#123;</span><br><span class="line">    match(number);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    error()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 这段伪代码中，假设有一个在输入中保存的token变量，还假设有一个match()匹配过程，它用参数匹配记号，如果成功则前移，失败就表明错误</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">match</span><span class="params">(TokenType * expected_token)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(token == expected_token) &#123;</span><br><span class="line">    getToken();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    error()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="comment">//伪代码</span></span><br></pre></td></tr></table></figure>

<p>并非所有文法规则都像factor规则这么简单。我们需要用到EBNF</p>
<h6 id="重复和选择：使用EBNF"><a href="#重复和选择：使用EBNF" class="headerlink" title="重复和选择：使用EBNF"></a>重复和选择：使用EBNF</h6><p>考虑一个化简后的if的文法规则</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if-stmt → if (exp) statement</span><br><span class="line">		  | if (exp) statement else statement</span><br></pre></td></tr></table></figure>

<p> 这里并不能直接区分出右边的两个选择，因为它们都是以if开头，必须要看到else时才能决定是否识别可选的else部分，这恰好对应EBNF中的可选。所以它与EBNF的匹配度更高。事实上EBNF就是为了能更加贴合递归下降分析的代码过程而被设计的，所以如果使用递归下降分析的话应该尽可能使用EBNF表示文法。</p>
<p>考虑下面这种情况          </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exp → exp addop term|term</span><br></pre></td></tr></table></figure>

<p>如果对BNF直接分析的话，第一个分析的token就是exp，这会造成无限递归，然而使用EBNF就不存在这个问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exp → term &#123;addop term&#125;</span><br></pre></td></tr></table></figure>

<p>对于花括号中的内容，我们可以使用循环来表示在代码中</p>
<h5 id="LL-1-分析"><a href="#LL-1-分析" class="headerlink" title="LL(1)分析"></a>LL(1)分析</h5><p>不在课程要求内，先省略相关内容</p>
<h5 id="TINY语言的递归下降分析程序"><a href="#TINY语言的递归下降分析程序" class="headerlink" title="TINY语言的递归下降分析程序"></a>TINY语言的递归下降分析程序</h5><p>先给出TINY语言的EBNF文法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">program → stmt-sequence</span><br><span class="line">stmt-sequence → statement &#123;;statement&#125;</span><br><span class="line">statement → if    printTree(psyntaxTree);-stmt | repeat-stmt | read-stmt | write-stmt</span><br><span class="line">if-stmt → if exp then stmt-sequence [else stmt-sequence] end</span><br><span class="line">repeat-stmt → repeat stmt-sequence until exp</span><br><span class="line">assign-stmt → identifier := exp</span><br><span class="line">read-stmt → read identifier</span><br><span class="line">write-stmt → write exp</span><br><span class="line">exp → simple-exp [comparision-op simple-exp]</span><br><span class="line">comparison-op → &lt;|=</span><br><span class="line">simple-exp → term &#123;addop term&#125;</span><br><span class="line">addop → +|-</span><br><span class="line">term → factor&#123;mulop factor&#125;</span><br><span class="line">mulop → *|/</span><br><span class="line">factor → (exp) | number | identifier</span><br></pre></td></tr></table></figure>

<p>原书中有加粗表示字符穿串而不是名称，更容易看懂，可以看PDFp146</p>
<p>这里直接结合源码</p>
<p>分析的内容在文件parse.c中，而语法树节点的定义在global.h中，在上一章已经分析过</p>
<p>parse.c的核心函数<code>parse()</code>在main.c中被调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">syntaxTree = parse();</span><br><span class="line"><span class="keyword">if</span> (TraceParse) &#123;</span><br><span class="line">  <span class="built_in">fprintf</span>(listing, <span class="string">&quot;\nSyntax tree:\n&quot;</span>);</span><br><span class="line">  printTree(psyntaxTree);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里调用了<code>parse()</code>函数并生成了一棵语法树。如果打开了<code>TraceParse</code>选项后（和扫描程序的类似），就会把语法树打印出来</p>
<p><code>printTree</code>函数定义在util.c文件中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Variable indentno is used by printTree to</span></span><br><span class="line"><span class="comment"> * store current number of spaces to indent</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> indentno = <span class="number">0</span>;<span class="comment">//用于计数的变量，表示要打印的空格数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* macros to increase/decrease indentation */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INDENT indentno+=2<span class="comment">//表示加两个空格</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNINDENT indentno-=2<span class="comment">//表示减两个空格</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* printSpaces indents by printing spaces */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">printSpaces</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;indentno;i++)<span class="comment">//for循环打印空格表示缩进</span></span><br><span class="line">    <span class="built_in">fprintf</span>(listing,<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* procedure printTree prints a syntax tree to the </span></span><br><span class="line"><span class="comment"> * listing file using indentation to indicate subtrees</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printTree</span><span class="params">( TreeNode * tree )</span><span class="comment">//接收一个树节点（根节点）</span></span><br><span class="line">&#123; <span class="type">int</span> i;</span><br><span class="line">  INDENT;<span class="comment">//默认先缩进两格</span></span><br><span class="line">  <span class="keyword">while</span> (tree != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    printSpaces();<span class="comment">//根据indentno的值打印空格表示缩进</span></span><br><span class="line">    <span class="keyword">if</span> (tree-&gt;nodekind==StmtK)</span><br><span class="line">    &#123; <span class="keyword">switch</span> (tree-&gt;kind.stmt) &#123;</span><br><span class="line">        <span class="keyword">case</span> IfK:</span><br><span class="line">          <span class="built_in">fprintf</span>(listing,<span class="string">&quot;If\n&quot;</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> RepeatK:</span><br><span class="line">          <span class="built_in">fprintf</span>(listing,<span class="string">&quot;Repeat\n&quot;</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> AssignK:</span><br><span class="line">          <span class="built_in">fprintf</span>(listing,<span class="string">&quot;Assign to: %s\n&quot;</span>,tree-&gt;attr.name);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ReadK:</span><br><span class="line">          <span class="built_in">fprintf</span>(listing,<span class="string">&quot;Read: %s\n&quot;</span>,tree-&gt;attr.name);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> WriteK:</span><br><span class="line">          <span class="built_in">fprintf</span>(listing,<span class="string">&quot;Write\n&quot;</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="built_in">fprintf</span>(listing,<span class="string">&quot;Unknown ExpNode kind\n&quot;</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (tree-&gt;nodekind==ExpK)</span><br><span class="line">    &#123; <span class="keyword">switch</span> (tree-&gt;kind.<span class="built_in">exp</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> OpK:</span><br><span class="line">          <span class="built_in">fprintf</span>(listing,<span class="string">&quot;Op: &quot;</span>);</span><br><span class="line">          printToken(tree-&gt;attr.op,<span class="string">&quot;\0&quot;</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ConstK:</span><br><span class="line">          <span class="built_in">fprintf</span>(listing,<span class="string">&quot;Const: %d\n&quot;</span>,tree-&gt;attr.val);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IdK:</span><br><span class="line">          <span class="built_in">fprintf</span>(listing,<span class="string">&quot;Id: %s\n&quot;</span>,tree-&gt;attr.name);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="built_in">fprintf</span>(listing,<span class="string">&quot;Unknown ExpNode kind\n&quot;</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">fprintf</span>(listing,<span class="string">&quot;Unknown node kind\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;MAXCHILDREN;i++)</span><br><span class="line">         printTree(tree-&gt;child[i]);</span><br><span class="line">    tree = tree-&gt;sibling;</span><br><span class="line">  &#125;</span><br><span class="line">  UNINDENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到每调用一次<code>printTree</code>函数都会先让缩进增加两格空格，如果有子节点的话就会重复调用<code>printTree</code>，导致缩进继续增加，缩进效果就是这样实现的。而当没有孩子节点的时候转到兄弟节点（没有兄弟节点就结束while循环），转到兄弟节点后会让缩进减少两格空格（<code>UNINDENT</code>），所以同级的节点缩进数一定相同，依靠缩进便于展示树状结构</p>
<p>下面进入正题，开始看<code>parse()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;globals.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;util.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;scan.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;parse.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> TokenType token; <span class="comment">/* holds current token */</span></span><br><span class="line"><span class="comment">/****************************************/</span></span><br><span class="line"><span class="comment">/* the primary function of the parser   */</span></span><br><span class="line"><span class="comment">/****************************************/</span></span><br><span class="line"><span class="comment">/* Function parse returns the newly </span></span><br><span class="line"><span class="comment"> * constructed syntax tree</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">TreeNode * <span class="title function_">parse</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; TreeNode * t;</span><br><span class="line">  token = getToken();</span><br><span class="line">  t = stmt_sequence();</span><br><span class="line">  <span class="keyword">if</span> (token!=ENDFILE)</span><br><span class="line">    syntaxError(<span class="string">&quot;Code ends before file\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数非常简单，它先调用<code>getToken()</code>函数，把获取到token赋给token变量，这个变量是在parse.c的顶部声明的，表示当前遍历到的token，然后它调用<code>stmt-sequence</code>函数（之前有提到TINY只是由语句序列构成的），根据递归下降分析，这个函数会匹配，然后调用其他函数，这其中会不断的触发<code>getToken</code>，所以说扫描程序是由分析程序驱动的。完成整个递归下降分析后，生成了一棵语法树并返回。如果开始就文件尾就会触发错误。</p>
<p>下面来看<code>stmt-sequence</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">TreeNode * <span class="title function_">stmt_sequence</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; TreeNode * t = statement();</span><br><span class="line">  TreeNode * p = t;</span><br><span class="line">  <span class="keyword">while</span> ((token!=ENDFILE) &amp;&amp; (token!=END) &amp;&amp;(token!=ELSE) &amp;&amp; (token!=UNTIL))</span><br><span class="line">  &#123; TreeNode * q;<span class="comment">//定义一个节点q</span></span><br><span class="line">    match(SEMI);<span class="comment">//匹配分号</span></span><br><span class="line">    q = statement();<span class="comment">//获取statement生成的节点并赋值给q</span></span><br><span class="line">    <span class="keyword">if</span> (q!=<span class="literal">NULL</span>) &#123;<span class="comment">//如果获取到了</span></span><br><span class="line">      <span class="keyword">if</span> (t==<span class="literal">NULL</span>) t = p = q;</span><br><span class="line">      <span class="keyword">else</span> <span class="comment">/* now p cannot be NULL either */</span></span><br><span class="line">      &#123; p-&gt;sibling = q;<span class="comment">//就把q作为p的邻接节点</span></span><br><span class="line">        p = q;<span class="comment">//q赋值给p（链表后移）</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结合EBNF文法<code>stmt-sequence → statement &#123;;statement&#125;</code>，语句序列是由一个<code>statement</code>和重复的<code>;statement</code>组成的，因此在这个函数开头先调用了<code>statement</code>函数，这个函数继续递归下降得到树节点t,然后while循环的作用是表示重复。所有重复的statement节点都会用邻接表的形式充当兄弟节点</p>
<p>然后看<code>statement()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">TreeNode * <span class="title function_">statement</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; TreeNode * t = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">switch</span> (token) &#123;</span><br><span class="line">    <span class="keyword">case</span> IF : t = if_stmt(); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> REPEAT : t = repeat_stmt(); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ID : t = assign_stmt(); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> READ : t = read_stmt(); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WRITE : t = write_stmt(); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span> : syntaxError(<span class="string">&quot;unexpected token -&gt; &quot;</span>);</span><br><span class="line">              printToken(token,tokenString);</span><br><span class="line">              token = getToken();</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">  &#125; <span class="comment">/* end case */</span></span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据文法<code>statement → if-stmt | repeat-stmt | read-stmt | write-stmt</code>，这个函数被设计成<code>switch...case...</code>来表示选择，当然也包括了错误处理</p>
<p>先假设正确匹配了，依次看各种语句</p>
<p>先看if</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">TreeNode * <span class="title function_">if_stmt</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; TreeNode * t = newStmtNode(IfK);</span><br><span class="line">  match(IF);</span><br><span class="line">  <span class="keyword">if</span> (t!=<span class="literal">NULL</span>) t-&gt;child[<span class="number">0</span>] = <span class="built_in">exp</span>();<span class="comment">//匹配exp</span></span><br><span class="line">  match(THEN);<span class="comment">//匹配then</span></span><br><span class="line">  <span class="keyword">if</span> (t!=<span class="literal">NULL</span>) t-&gt;child[<span class="number">1</span>] = stmt_sequence();<span class="comment">//匹配if==true执行的语句</span></span><br><span class="line">  <span class="keyword">if</span> (token==ELSE) &#123;<span class="comment">//匹配可选的else</span></span><br><span class="line">    match(ELSE);</span><br><span class="line">    <span class="keyword">if</span> (t!=<span class="literal">NULL</span>) t-&gt;child[<span class="number">2</span>] = stmt_sequence();</span><br><span class="line">  &#125;</span><br><span class="line">  match(END);</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于<code>if-stmt</code>函数被调用的前提是当前token是IF,所以当调用时我们就可以预测这会生成一个语句类型的节点，且语句类型是if。所以先调用一个工具函数<code>newStmtNode</code>，这个函数在<code>util.c</code>中定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Function newStmtNode creates a new statement</span></span><br><span class="line"><span class="comment"> * node for syntax tree construction</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">TreeNode * <span class="title function_">newStmtNode</span><span class="params">(StmtKind kind)</span></span><br><span class="line">&#123; TreeNode * t = (TreeNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode));<span class="comment">//通过动态内存分配创建节点</span></span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">if</span> (t==<span class="literal">NULL</span>)<span class="comment">//分配失败</span></span><br><span class="line">    <span class="built_in">fprintf</span>(listing,<span class="string">&quot;Out of memory error at line %d\n&quot;</span>,lineno);</span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="comment">//开始根据获取的参数给t初始化一些数据</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;MAXCHILDREN;i++) t-&gt;child[i] = <span class="literal">NULL</span>;</span><br><span class="line">    t-&gt;sibling = <span class="literal">NULL</span>;</span><br><span class="line">    t-&gt;nodekind = StmtK;</span><br><span class="line">    t-&gt;kind.stmt = kind;</span><br><span class="line">    t-&gt;lineno = lineno;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> t;<span class="comment">//返回t</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后调用<code>match</code>函数匹配IF,其实<code>if-stmt</code>函数被调用的前提是当前token是IF，所以这个match一定会成立，实际上只是为了获取下一个token（驱动扫描程序）</p>
<p>看一下<code>match</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">match</span><span class="params">(TokenType expected)</span></span><br><span class="line">&#123; <span class="keyword">if</span> (token == expected) token = getToken();<span class="comment">//如果token和作为参数的需要的token相同就获取下一个token</span></span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="comment">//否则进行错误处理</span></span><br><span class="line">    syntaxError(<span class="string">&quot;unexpected token -&gt; &quot;</span>);</span><br><span class="line">    printToken(token,tokenString);</span><br><span class="line">    <span class="built_in">fprintf</span>(listing,<span class="string">&quot;      &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据文法<code>if-stmt → if exp then stmt-sequence [else stmt-sequence] end</code>，匹配了if之后需要匹配exp(TINY语言的exp外面不需要括号)，匹配完exp之后会再匹配then字符串，然后匹配if为true时执行的语句，对于else由于是可选的所以用了if选择匹配。最后是结尾标志符end的匹配</p>
<p>下面再看<code>exp()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">TreeNode * <span class="title function_">exp</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; TreeNode * t = simple_exp();<span class="comment">//进行simple-exp的匹配</span></span><br><span class="line">  <span class="keyword">if</span> ((token==LT)||(token==EQ)) &#123;</span><br><span class="line">    TreeNode * p = newExpNode(OpK);<span class="comment">//调用工具函数初始化</span></span><br><span class="line">    <span class="keyword">if</span> (p!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">      p-&gt;child[<span class="number">0</span>] = t;<span class="comment">//如果是比较型表达式，那么第一个simple-exp就要成为该表达式的子节点</span></span><br><span class="line">      p-&gt;attr.op = token;<span class="comment">//给节点完善操作符属性</span></span><br><span class="line">      t = p;<span class="comment">//返回值更改为p</span></span><br><span class="line">    &#125;</span><br><span class="line">    match(token);<span class="comment">//传入token,必然成立，目的是获取下一个token</span></span><br><span class="line">    <span class="keyword">if</span> (t!=<span class="literal">NULL</span>)</span><br><span class="line">      t-&gt;child[<span class="number">1</span>] = simple_exp();<span class="comment">//另一个子节点是后面的simple-exp</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据文法<code>exp → simple-exp [comparision-op simple-exp]</code>，exp是由一个<code>simple-exp</code>(运算表达式)和可选的<code>comparsion-op simple-exp</code>组成（用于和前面必有的simple-exp构成一个比较表达式）。同样用if表示可选，当存在比较时就可以先预测这个节点会是一个表达式类型的节点，且表达式类型是有运算符（<code>OpK</code>），同样，是调用<code>util.c</code>中的<code>newExpNode</code>函数进行初始化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Function newExpNode creates a new expression </span></span><br><span class="line"><span class="comment"> * node for syntax tree construction</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//和newStmtNode相似，不解释了</span></span><br><span class="line">TreeNode * <span class="title function_">newExpNode</span><span class="params">(ExpKind kind)</span></span><br><span class="line">&#123; TreeNode * t = (TreeNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">if</span> (t==<span class="literal">NULL</span>)</span><br><span class="line">    <span class="built_in">fprintf</span>(listing,<span class="string">&quot;Out of memory error at line %d\n&quot;</span>,lineno);</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;MAXCHILDREN;i++) t-&gt;child[i] = <span class="literal">NULL</span>;</span><br><span class="line">    t-&gt;sibling = <span class="literal">NULL</span>;</span><br><span class="line">    t-&gt;nodekind = ExpK;</span><br><span class="line">    t-&gt;kind.<span class="built_in">exp</span> = kind;</span><br><span class="line">    t-&gt;lineno = lineno;</span><br><span class="line">    t-&gt;type = Void;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面看<code>simple_exp()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">TreeNode * <span class="title function_">simple_exp</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; TreeNode * t = term();<span class="comment">//先匹配一次term</span></span><br><span class="line">  <span class="keyword">while</span> ((token==PLUS)||(token==MINUS))</span><br><span class="line">  &#123; TreeNode * p = newExpNode(OpK);<span class="comment">//调用工具函数初始化</span></span><br><span class="line">    <span class="keyword">if</span> (p!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">      p-&gt;child[<span class="number">0</span>] = t;<span class="comment">//有运算符的话之前匹配的term就要当成子节点</span></span><br><span class="line">      p-&gt;attr.op = token;<span class="comment">//给节点完善操作符属性</span></span><br><span class="line">      t = p;<span class="comment">//更改返回值</span></span><br><span class="line">      match(token);<span class="comment">//获取下一个token</span></span><br><span class="line">      t-&gt;child[<span class="number">1</span>] = term();<span class="comment">//获取后一个term</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据文法<code>simple-exp → term &#123;addop term&#125;</code>，这是由一个term和重复的addop term组成的，同样由while循环实现重复。</p>
<p>下面看<code>term()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">TreeNode * <span class="title function_">term</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; TreeNode * t = factor();</span><br><span class="line">  <span class="keyword">while</span> ((token==TIMES)||(token==OVER))</span><br><span class="line">  &#123; TreeNode * p = newExpNode(OpK);</span><br><span class="line">    <span class="keyword">if</span> (p!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">      p-&gt;child[<span class="number">0</span>] = t;</span><br><span class="line">      p-&gt;attr.op = token;</span><br><span class="line">      t = p;</span><br><span class="line">      match(token);</span><br><span class="line">      p-&gt;child[<span class="number">1</span>] = factor();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文法为<code>term → factor&#123;mulop factor&#125;</code>，这个文法和上面的<code>simple-exp</code>很像，而且代码内容格式也是一致的，不过多分析</p>
<p>下面看<code>factor()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">TreeNode * <span class="title function_">factor</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; TreeNode * t = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">switch</span> (token) &#123;</span><br><span class="line">    <span class="keyword">case</span> NUM :<span class="comment">//匹配数字</span></span><br><span class="line">      t = newExpNode(ConstK);<span class="comment">//调用工具函数初始化节点数据</span></span><br><span class="line">      <span class="keyword">if</span> ((t!=<span class="literal">NULL</span>) &amp;&amp; (token==NUM))</span><br><span class="line">        t-&gt;attr.val = atoi(tokenString);<span class="comment">//将串值转化为整数赋值给节点的属性值</span></span><br><span class="line">      match(NUM);<span class="comment">//必然成功，读取下一个token</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ID :</span><br><span class="line">      t = newExpNode(IdK);</span><br><span class="line">      <span class="keyword">if</span> ((t!=<span class="literal">NULL</span>) &amp;&amp; (token==ID))</span><br><span class="line">        t-&gt;attr.name = copyString(tokenString);</span><br><span class="line">      match(ID);<span class="comment">////必然成功，读取下一个token</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LPAREN :</span><br><span class="line">      match(LPAREN);<span class="comment">//左括号</span></span><br><span class="line">      t = <span class="built_in">exp</span>();<span class="comment">//匹配exp</span></span><br><span class="line">      match(RPAREN);<span class="comment">//右括号</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      syntaxError(<span class="string">&quot;unexpected token -&gt; &quot;</span>);<span class="comment">//其他的都是错误的token</span></span><br><span class="line">      printToken(token,tokenString);</span><br><span class="line">      token = getToken();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文法为<code>factor → (exp) | number | identifier</code>，这是一个选择，用<code>switch...case...实现</code></p>
<p>下面看其他语句</p>
<p>repeat语句</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TreeNode * <span class="title function_">repeat_stmt</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; TreeNode * t = newStmtNode(RepeatK);<span class="comment">//工具函数调用初始化节点数据</span></span><br><span class="line">  match(REPEAT);<span class="comment">//必然成功，读取下一个token</span></span><br><span class="line">  <span class="keyword">if</span> (t!=<span class="literal">NULL</span>) t-&gt;child[<span class="number">0</span>] = stmt_sequence();<span class="comment">//循环体里的语句序列（作为孩子）</span></span><br><span class="line">  match(UNTIL);<span class="comment">//匹配until</span></span><br><span class="line">  <span class="keyword">if</span> (t!=<span class="literal">NULL</span>) t-&gt;child[<span class="number">1</span>] = <span class="built_in">exp</span>();<span class="comment">//匹配until内的条件表达式</span></span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文法为<code>repeat-stmt → repeat stmt-sequence until exp</code>，很简单，顺序匹配即可。另外声明作为子节点可以让内容处于语法树的下端</p>
<p>赋值语句</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TreeNode * <span class="title function_">assign_stmt</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; TreeNode * t = newStmtNode(AssignK);<span class="comment">//初始化</span></span><br><span class="line">  <span class="keyword">if</span> ((t!=<span class="literal">NULL</span>) &amp;&amp; (token==ID))</span><br><span class="line">    t-&gt;attr.name = copyString(tokenString);</span><br><span class="line">  match(ID);<span class="comment">//匹配标识符</span></span><br><span class="line">  match(ASSIGN);<span class="comment">//匹配赋值操作符</span></span><br><span class="line">  <span class="keyword">if</span> (t!=<span class="literal">NULL</span>) t-&gt;child[<span class="number">0</span>] = <span class="built_in">exp</span>();<span class="comment">//匹配exp</span></span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文法为<code>assign-stmt → identifier := exp</code>，也是很直接的依次匹配</p>
<p>下面看输入和输出语句</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">TreeNode * <span class="title function_">read_stmt</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; TreeNode * t = newStmtNode(ReadK);</span><br><span class="line">  match(READ);</span><br><span class="line">  <span class="keyword">if</span> ((t!=<span class="literal">NULL</span>) &amp;&amp; (token==ID))</span><br><span class="line">    t-&gt;attr.name = copyString(tokenString);</span><br><span class="line">  match(ID);</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode * <span class="title function_">write_stmt</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; TreeNode * t = newStmtNode(WriteK);</span><br><span class="line">  match(WRITE);</span><br><span class="line">  <span class="keyword">if</span> (t!=<span class="literal">NULL</span>) t-&gt;child[<span class="number">0</span>] = <span class="built_in">exp</span>();</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个语句的文法也很简单<code>read-stmt → read identifier write-stmt → write exp</code>，直接匹配即可</p>
<h3 id="关于课程要求"><a href="#关于课程要求" class="headerlink" title="关于课程要求"></a>关于课程要求</h3><p>下面是课程要求的代码实现</p>
<h4 id="C–斐波那契数列"><a href="#C–斐波那契数列" class="headerlink" title="C–斐波那契数列"></a>C–斐波那契数列</h4><p>C–语言没有递归和数组，只有while循环，而且必须先声明再使用。所以按照下面的代码实现斐波那契数列</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Fib</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(num &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">int</span> first;</span><br><span class="line">    <span class="type">int</span> second;</span><br><span class="line">    <span class="type">int</span> third;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    first = <span class="number">0</span>;</span><br><span class="line">    second = <span class="number">1</span>;</span><br><span class="line">    third = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; num) &#123;</span><br><span class="line">      third = first + second;</span><br><span class="line">      first = second;</span><br><span class="line">      second = third;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> third;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="type">int</span> result;</span><br><span class="line">  num = input();</span><br><span class="line">  result = Fib(num)</span><br><span class="line">  output(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="C–语言的词法分析设计"><a href="#C–语言的词法分析设计" class="headerlink" title="C–语言的词法分析设计"></a>C–语言的词法分析设计</h4><p>选择在TINY语言样本的模板上修改</p>
<p>首先我们需要分析一下C–语言里需要用到哪些token</p>
<h5 id="token设计"><a href="#token设计" class="headerlink" title="token设计"></a>token设计</h5><p>下面是TINY中用到的token（global.h中）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> </span></span><br><span class="line"><span class="class">    /* <span class="title">book</span>-<span class="title">keeping</span> <span class="title">tokens</span> */</span></span><br><span class="line"><span class="class">   &#123;</span>ENDFILE,ERROR,</span><br><span class="line">    <span class="comment">/* reserved words */</span></span><br><span class="line">    IF,THEN,ELSE,END,REPEAT,UNTIL,READ,WRITE,</span><br><span class="line">    <span class="comment">/* multicharacter tokens */</span></span><br><span class="line">    ID,NUM,</span><br><span class="line">    <span class="comment">/* special symbols */</span></span><br><span class="line">    ASSIGN,EQ,LT,PLUS,MINUS,TIMES,OVER,LPAREN,RPAREN,SEMI</span><br><span class="line">   &#125; TokenType;</span><br></pre></td></tr></table></figure>

<p>先不考虑token的串值，<code>ENDFILE,ERROR</code>用于标记，可以保留。IF和ELSE仍然是保留字，可以保留，而THEN和END不存在于C–中，删除。REPEAT用WHILE替换，UNTIL也不在C–中，删除。READ和WRITE分别用INPUT和OUTPUT替换。多字符token中，ID和NUM都可以保留。特殊标志里，赋值，相等，小于，加，减，乘，除，左括号，右括号，分号都可以保留</p>
<p>此外，C–中还有代表类型的保留字VOID和INT，代表主函数的保留字MAIN,用于返回的保留字return，能表示代码块的特殊字符大括号，用于比较的特殊字符字符大于，不等于，大于等于，小于等于，用于分割函数参数的逗号。</p>
<p>所以我们修改枚举类型TokenType</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改后的TokenType</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> </span></span><br><span class="line"><span class="class">    /* <span class="title">book</span>-<span class="title">keeping</span> <span class="title">tokens</span> */</span></span><br><span class="line"><span class="class">   &#123;</span>ENDFILE,ERROR,</span><br><span class="line">    <span class="comment">/* reserved words */</span></span><br><span class="line">    IF,ELSE,WHILE,INPUT,OUTPUT,RETURN,VOID,MAIN,INT,</span><br><span class="line">    <span class="comment">/* multicharacter tokens */</span></span><br><span class="line">    ID,NUM,</span><br><span class="line">    <span class="comment">/* special symbols */</span></span><br><span class="line">    ASSIGN,EQ,LT,NEQ,BT,LET,BET,PLUS,MINUS,TIMES,OVER,LPAREN,RPAREN,SEMI,LBPAREN,RBPAREN,COMMMA</span><br><span class="line">   &#125; TokenType;</span><br><span class="line"><span class="comment">//NEQ:!=  BT:&gt;  LET:&lt;=  BET:&gt;=  LBPAREN:&#123;  RBPAREN:&#125; COMMA:,</span></span><br></pre></td></tr></table></figure>

<p>保留字是9个，还需改变<code>MAXRESERVED</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXRESERVED 9</span></span><br></pre></td></tr></table></figure>

<p>然后我们需要构造以及修改有穷自动机</p>
<p>保留字依然是先当成标识符，扫描之后再区分。</p>
<p>从正则表达式开始：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">letter = [a-zA-Z]</span><br><span class="line">digit = [0-9]</span><br><span class="line">ID = letter(letter|digit)*</span><br><span class="line">NUM = digit+</span><br><span class="line">ASSIGN = =</span><br><span class="line">EQ = ==</span><br><span class="line">LT = &lt;</span><br><span class="line">NEQ = !=</span><br><span class="line">BT = &gt;</span><br><span class="line">LET = &lt;=</span><br><span class="line">BET = &gt;=</span><br><span class="line">PLUS = +</span><br><span class="line">MINUS = -</span><br><span class="line">TIMES = *</span><br><span class="line">OVER = /</span><br><span class="line">LPAREN = (</span><br><span class="line">RPAREN = )</span><br><span class="line">LBPAREN = &#123;</span><br><span class="line">RBPAREN = &#125;</span><br><span class="line">COMMA = ,</span><br></pre></td></tr></table></figure>

<h5 id="构造有穷自动机"><a href="#构造有穷自动机" class="headerlink" title="构造有穷自动机"></a>构造有穷自动机</h5><p>然后构造有穷自动机（考虑了注释的情况）</p>
<p><img src="/image/img_28.png" alt="dfa"></p>
<h5 id="修改scan-c的代码"><a href="#修改scan-c的代码" class="headerlink" title="修改scan.c的代码"></a>修改scan.c的代码</h5><p>然后就可以根据有穷自动机修改scan.c了</p>
<p>首先是根据global.h中的内容修改保留字结构体数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* lookup table of reserved words */</span></span><br><span class="line"><span class="comment">//这是修改后的</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> *str;</span><br><span class="line">  TokenType tok;</span><br><span class="line">&#125; reservedWords[MAXRESERVED] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;if&quot;</span>, IF&#125;,&#123;<span class="string">&quot;while&quot;</span>,WHILE&#125;,&#123;<span class="string">&quot;else&quot;</span>, ELSE&#125;, &#123;<span class="string">&quot;input&quot;</span>, INPUT&#125;, &#123;<span class="string">&quot;output&quot;</span>, OUTPUT&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;return&quot;</span>, RETURN&#125;, &#123;<span class="string">&quot;int&quot;</span>, INT&#125;,&#123;<span class="string">&quot;void&quot;</span>, VOID&#125;,&#123;<span class="string">&quot;main&quot;</span>,MAIN&#125;&#125;;</span><br></pre></td></tr></table></figure>

<p>然后根据有穷自动机的内容修改枚举类型的状态<code>StateType</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改后的</span></span><br><span class="line"><span class="comment">/* states in scanner DFA */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span> START, INEQ, INNEQ, INLT, INBT, INCOMMENT, INNUM, INID, DONE, INNOTCOMMENT &#125; StateType;</span><br></pre></td></tr></table></figure>

<p>然后开始修改<code>getToken</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改后的</span></span><br><span class="line">TokenType <span class="title function_">getToken</span><span class="params">(<span class="type">void</span>)</span> &#123; <span class="comment">/* index for storing into tokenString */</span></span><br><span class="line">  <span class="type">int</span> tokenStringIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* holds current token to be returned */</span></span><br><span class="line">  TokenType currentToken;</span><br><span class="line">  <span class="comment">/* current state - always begins at START */</span></span><br><span class="line">  StateType state = START;</span><br><span class="line">  <span class="comment">/* flag to indicate save to tokenString */</span></span><br><span class="line">  <span class="type">int</span> save;</span><br><span class="line">  <span class="keyword">while</span> (state != DONE) &#123;</span><br><span class="line">    <span class="type">int</span> c = getNextChar();</span><br><span class="line">    save = TRUE;</span><br><span class="line">    <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">    <span class="keyword">case</span> START:</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c))</span><br><span class="line">        state = INNUM;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isalpha</span>(c))</span><br><span class="line">        state = INID;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;=&#x27;</span>)</span><br><span class="line">        state = INEQ;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;&lt;&#x27;</span>)</span><br><span class="line">        state = INLT;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;&gt;&#x27;</span>)</span><br><span class="line">        state = INBT;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">        state = INNEQ;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ((c == <span class="string">&#x27; &#x27;</span>) || (c == <span class="string">&#x27;\t&#x27;</span>) || (c == <span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line">        save = FALSE;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(getNextChar()==<span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">          save = FALSE;</span><br><span class="line">          state = INCOMMENT;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          ungetNextChar();</span><br><span class="line">          state = DONE;</span><br><span class="line">          currentToken = OVER;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        state = DONE;</span><br><span class="line">        <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> EOF:</span><br><span class="line">          save = FALSE;</span><br><span class="line">          currentToken = ENDFILE;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">          currentToken = PLUS;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">          currentToken = MINUS;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">          currentToken = TIMES;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">          currentToken = LPAREN;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">          currentToken = RPAREN;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;&#123;&#x27;</span>:</span><br><span class="line">          currentToken = LBPAREN;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;&#125;&#x27;</span>:</span><br><span class="line">          currentToken = RBPAREN;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;;&#x27;</span>:</span><br><span class="line">          currentToken = SEMI;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;,&#x27;</span>:</span><br><span class="line">          currentToken = COMMA;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          currentToken = ERROR;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> INCOMMENT:</span><br><span class="line">      save = FALSE;</span><br><span class="line">      <span class="keyword">if</span> (c == EOF) &#123;</span><br><span class="line">        state = DONE;</span><br><span class="line">        currentToken = ENDFILE;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">        state = INNOTCOMMENT;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> INNOTCOMMENT:</span><br><span class="line">      save = FALSE;</span><br><span class="line">      <span class="keyword">if</span>(c == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">        state = START;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        state = INCOMMENT;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> INEQ:</span><br><span class="line">      state = DONE;</span><br><span class="line">      <span class="keyword">if</span>(c == <span class="string">&#x27;=&#x27;</span>) &#123;</span><br><span class="line">        currentToken = EQ;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ungetNextChar();</span><br><span class="line">        currentToken = ASSIGN;</span><br><span class="line">        save = FALSE;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> INNEQ:</span><br><span class="line">      state = DONE;</span><br><span class="line">      <span class="keyword">if</span>(c == <span class="string">&#x27;=&#x27;</span>) &#123;</span><br><span class="line">        currentToken = NEQ;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ungetNextChar();</span><br><span class="line">        save = FALSE;</span><br><span class="line">        currentToken = ERROR;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> INLT:</span><br><span class="line">      state = DONE;</span><br><span class="line">      <span class="keyword">if</span>(c == <span class="string">&#x27;=&#x27;</span>) &#123;</span><br><span class="line">        currentToken = LET;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        currentToken = LT;</span><br><span class="line">        save = FALSE;</span><br><span class="line">        ungetNextChar();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> INBT:</span><br><span class="line">      state = DONE;</span><br><span class="line">      <span class="keyword">if</span>(c == <span class="string">&#x27;=&#x27;</span>) &#123;</span><br><span class="line">        currentToken = BET;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        currentToken = BT;</span><br><span class="line">        save = FALSE;</span><br><span class="line">        ungetNextChar();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> INNUM:</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(c)) &#123; <span class="comment">/* backup in the input */</span></span><br><span class="line">        ungetNextChar();</span><br><span class="line">        save = FALSE;</span><br><span class="line">        state = DONE;</span><br><span class="line">        currentToken = NUM;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> INID:</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">isalpha</span>(c)&amp;&amp;(!<span class="built_in">isdigit</span>(c))) &#123; </span><br><span class="line">        ungetNextChar();</span><br><span class="line">        save = FALSE;</span><br><span class="line">        state = DONE;</span><br><span class="line">        currentToken = ID;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DONE:</span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">/* should never happen */</span></span><br><span class="line">      <span class="built_in">fprintf</span>(listing, <span class="string">&quot;Scanner Bug: state= %d\n&quot;</span>, state);</span><br><span class="line">      state = DONE;</span><br><span class="line">      currentToken = ERROR;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((save) &amp;&amp; (tokenStringIndex &lt;= MAXTOKENLEN))</span><br><span class="line">      tokenString[tokenStringIndex++] = (<span class="type">char</span>)c;</span><br><span class="line">    <span class="keyword">if</span> (state == DONE) &#123;</span><br><span class="line">      tokenString[tokenStringIndex] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">      <span class="keyword">if</span> (currentToken == ID)</span><br><span class="line">        currentToken = reservedLookup(tokenString);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (TraceScan) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(listing, <span class="string">&quot;\t%d: &quot;</span>, lineno);</span><br><span class="line">    printToken(currentToken, tokenString);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> currentToken;</span><br><span class="line">&#125; <span class="comment">/* end getToken */</span></span><br></pre></td></tr></table></figure>

<p>结果要想打印出来，还得修改util.c中的printToken函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改后的</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printToken</span><span class="params">( TokenType token, <span class="type">const</span> <span class="type">char</span>* tokenString )</span></span><br><span class="line">&#123; <span class="keyword">switch</span> (token)</span><br><span class="line">  &#123; <span class="keyword">case</span> IF:</span><br><span class="line">    <span class="keyword">case</span> INT:</span><br><span class="line">    <span class="keyword">case</span> ELSE:</span><br><span class="line">    <span class="keyword">case</span> VOID:</span><br><span class="line">    <span class="keyword">case</span> WHILE:</span><br><span class="line">    <span class="keyword">case</span> INPUT:</span><br><span class="line">    <span class="keyword">case</span> OUTPUT:</span><br><span class="line">    <span class="keyword">case</span> RETURN:</span><br><span class="line">   	<span class="keyword">case</span> MAIN:</span><br><span class="line">      <span class="built_in">fprintf</span>(listing,</span><br><span class="line">         <span class="string">&quot;reserved word: %s\n&quot;</span>,tokenString);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ASSIGN: <span class="built_in">fprintf</span>(listing,<span class="string">&quot;=\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> BT: <span class="built_in">fprintf</span>(listing,<span class="string">&quot;&gt;\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LT: <span class="built_in">fprintf</span>(listing,<span class="string">&quot;&lt;\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> EQ: <span class="built_in">fprintf</span>(listing,<span class="string">&quot;=\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> NEQ: <span class="built_in">fprintf</span>(listing,<span class="string">&quot;!=\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> BET: <span class="built_in">fprintf</span>(listing,<span class="string">&quot;&gt;=\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LET: <span class="built_in">fprintf</span>(listing,<span class="string">&quot;&lt;=\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LPAREN: <span class="built_in">fprintf</span>(listing,<span class="string">&quot;(\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> RPAREN: <span class="built_in">fprintf</span>(listing,<span class="string">&quot;)\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LBPAREN: <span class="built_in">fprintf</span>(listing,<span class="string">&quot;&#123;\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> RBPAREN: <span class="built_in">fprintf</span>(listing,<span class="string">&quot;&#125;\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SEMI: <span class="built_in">fprintf</span>(listing,<span class="string">&quot;;\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> PLUS: <span class="built_in">fprintf</span>(listing,<span class="string">&quot;+\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MINUS: <span class="built_in">fprintf</span>(listing,<span class="string">&quot;-\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> TIMES: <span class="built_in">fprintf</span>(listing,<span class="string">&quot;*\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> OVER: <span class="built_in">fprintf</span>(listing,<span class="string">&quot;/\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> COMMA: <span class="built_in">fprintf</span>(listing,<span class="string">&quot;,\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ENDFILE: <span class="built_in">fprintf</span>(listing,<span class="string">&quot;EOF\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> NUM:</span><br><span class="line">      <span class="built_in">fprintf</span>(listing,</span><br><span class="line">          <span class="string">&quot;NUM, val= %s\n&quot;</span>,tokenString);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ID:</span><br><span class="line">      <span class="built_in">fprintf</span>(listing,</span><br><span class="line">          <span class="string">&quot;ID, name= %s\n&quot;</span>,tokenString);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ERROR:</span><br><span class="line">      <span class="built_in">fprintf</span>(listing,</span><br><span class="line">          <span class="string">&quot;ERROR: %s\n&quot;</span>,tokenString);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">/* should never happen */</span></span><br><span class="line">      <span class="built_in">fprintf</span>(listing,<span class="string">&quot;Unknown token: %d\n&quot;</span>,token);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候还不能验证正确性，因为我们执行<code>make all</code>时默认编译了全部文件，因为parse.c中也会用到token而我们还没修改，所以会报错，我们可以选择重写MAKEFILE文件</p>
<h5 id="使用lex生成C–的扫描程序"><a href="#使用lex生成C–的扫描程序" class="headerlink" title="使用lex生成C–的扫描程序"></a>使用lex生成C–的扫描程序</h5><p>这里给出lex的代码，基于tiny语言的lex,改动不是很多，注意一下注释的判断</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/****************************************************/</span></span><br><span class="line"><span class="comment">/* File: tiny.l                                     */</span></span><br><span class="line"><span class="comment">/* Lex specification for TINY                       */</span></span><br><span class="line"><span class="comment">/* Compiler Construction: Principles and Practice   */</span></span><br><span class="line"><span class="comment">/* Kenneth C. Louden                                */</span></span><br><span class="line"><span class="comment">/****************************************************/</span></span><br><span class="line"></span><br><span class="line">%&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;globals.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;util.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;scan.h&quot;</span></span></span><br><span class="line"><span class="comment">/* lexeme of identifier or reserved word */</span></span><br><span class="line"><span class="type">char</span> tokenString[MAXTOKENLEN+<span class="number">1</span>];</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">digit       [<span class="number">0</span><span class="number">-9</span>]</span><br><span class="line">number      &#123;digit&#125;+</span><br><span class="line">letter      [a-zA-Z]</span><br><span class="line">identifier  &#123;letter&#125;(&#123;letter&#125;|&#123;digit&#125;)*</span><br><span class="line">newline     \n                                                                 </span><br><span class="line">whitespace  [ \t]+</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;if&quot;</span>            &#123;<span class="keyword">return</span> IF;&#125;</span><br><span class="line"><span class="string">&quot;while&quot;</span>         &#123;<span class="keyword">return</span> WHILE;&#125;</span><br><span class="line"><span class="string">&quot;else&quot;</span>          &#123;<span class="keyword">return</span> ELSE;&#125;</span><br><span class="line"><span class="string">&quot;return&quot;</span>        &#123;<span class="keyword">return</span> RETURN;&#125;</span><br><span class="line"><span class="string">&quot;int&quot;</span>           &#123;<span class="keyword">return</span> INT;&#125;</span><br><span class="line"><span class="string">&quot;input&quot;</span>         &#123;<span class="keyword">return</span> INPUT;&#125;</span><br><span class="line"><span class="string">&quot;output&quot;</span>        &#123;<span class="keyword">return</span> OUTPUT;&#125;</span><br><span class="line"><span class="string">&quot;void&quot;</span>          &#123;<span class="keyword">return</span> VOID;&#125;</span><br><span class="line"><span class="string">&quot;main&quot;</span>          &#123;<span class="keyword">return</span> MAIN;&#125;</span><br><span class="line"><span class="string">&quot;=&quot;</span>             &#123;<span class="keyword">return</span> ASSIGN;&#125;</span><br><span class="line"><span class="string">&quot;==&quot;</span>            &#123;<span class="keyword">return</span> EQ;&#125;</span><br><span class="line"><span class="string">&quot;!=&quot;</span>            &#123;<span class="keyword">return</span> NEQ;&#125;</span><br><span class="line"><span class="string">&quot;&lt;&quot;</span>             &#123;<span class="keyword">return</span> LT;&#125;</span><br><span class="line"><span class="string">&quot;&lt;=&quot;</span>            &#123;<span class="keyword">return</span> LET;&#125;</span><br><span class="line"><span class="string">&quot;&gt;=&quot;</span>            &#123;<span class="keyword">return</span> BET;&#125;</span><br><span class="line"><span class="string">&quot;+&quot;</span>             &#123;<span class="keyword">return</span> PLUS;&#125;</span><br><span class="line"><span class="string">&quot;-&quot;</span>             &#123;<span class="keyword">return</span> MINUS;&#125;</span><br><span class="line"><span class="string">&quot;*&quot;</span>             &#123;<span class="keyword">return</span> TIMES;&#125;</span><br><span class="line"><span class="string">&quot;/&quot;</span>             &#123;<span class="keyword">return</span> OVER;&#125;</span><br><span class="line"><span class="string">&quot;&#123;&quot;</span>             &#123;<span class="keyword">return</span> LBPAREN;&#125;</span><br><span class="line"><span class="string">&quot;(&quot;</span>             &#123;<span class="keyword">return</span> LPAREN;&#125;</span><br><span class="line"><span class="string">&quot;)&quot;</span>             &#123;<span class="keyword">return</span> RPAREN;&#125;</span><br><span class="line"><span class="string">&quot;&#125;&quot;</span>             &#123;<span class="keyword">return</span> RBPAREN;&#125;</span><br><span class="line"><span class="string">&quot;,&quot;</span>             &#123;<span class="keyword">return</span> COMMA;&#125;  </span><br><span class="line"><span class="string">&quot;;&quot;</span>             &#123;<span class="keyword">return</span> SEMI;&#125;</span><br><span class="line">&#123;number&#125;        &#123;<span class="keyword">return</span> NUM;&#125;</span><br><span class="line">&#123;identifier&#125;    &#123;<span class="keyword">return</span> ID;&#125;</span><br><span class="line">&#123;newline&#125;       &#123;lineno++;&#125;</span><br><span class="line">&#123;whitespace&#125;    &#123;<span class="comment">/* skip whitespace */</span>&#125;</span><br><span class="line"><span class="string">&quot;/*&quot;</span>            &#123; <span class="type">char</span> c;</span><br><span class="line">                  <span class="keyword">do</span></span><br><span class="line">                  &#123; c = input();</span><br><span class="line">                    <span class="keyword">if</span> (c == EOF) <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">if</span> (c == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                      <span class="keyword">if</span>(input()==<span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                      &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (c == <span class="string">&#x27;\n&#x27;</span>) lineno++;</span><br><span class="line">                  &#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">.               &#123;<span class="keyword">return</span> ERROR;&#125;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">TokenType <span class="title function_">getToken</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; <span class="type">static</span> <span class="type">int</span> firstTime = TRUE;</span><br><span class="line">  TokenType currentToken;</span><br><span class="line">  <span class="keyword">if</span> (firstTime)</span><br><span class="line">  &#123; firstTime = FALSE;</span><br><span class="line">    lineno++;</span><br><span class="line">    yyin = source;</span><br><span class="line">    yyout = listing;</span><br><span class="line">  &#125;</span><br><span class="line">  currentToken = yylex();</span><br><span class="line">  <span class="built_in">strncpy</span>(tokenString,yytext,MAXTOKENLEN);</span><br><span class="line">  <span class="keyword">if</span> (TraceScan) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(listing,<span class="string">&quot;\t%d: &quot;</span>,lineno);</span><br><span class="line">    printToken(currentToken,tokenString);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> currentToken;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="C–的语法分析设计"><a href="#C–的语法分析设计" class="headerlink" title="C–的语法分析设计"></a>C–的语法分析设计</h4><h2 id="注：此处在构造BNF时使用的是笔者自己的思路，导致最终代码很繁琐，但原书附录A中给出了C-MINUS语言的BNF-C–的语言复杂度比C-MINUS低，所以可以参考原书构造BNF"><a href="#注：此处在构造BNF时使用的是笔者自己的思路，导致最终代码很繁琐，但原书附录A中给出了C-MINUS语言的BNF-C–的语言复杂度比C-MINUS低，所以可以参考原书构造BNF" class="headerlink" title="注：此处在构造BNF时使用的是笔者自己的思路，导致最终代码很繁琐，但原书附录A中给出了C MINUS语言的BNF,C–的语言复杂度比C MINUS低，所以可以参考原书构造BNF"></a>注：此处在构造BNF时使用的是笔者自己的思路，导致最终代码很繁琐，但原书附录A中给出了C MINUS语言的BNF,C–的语言复杂度比C MINUS低，所以可以参考原书构造BNF</h2><h5 id="C–语言的BNF描述"><a href="#C–语言的BNF描述" class="headerlink" title="C–语言的BNF描述"></a>C–语言的BNF描述</h5><p>先看TINY语言的BNF</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">program → stmt-sequence</span><br><span class="line">stmt-sequence → stmt-sequence ; statement | statement</span><br><span class="line">statement → if-stmt | repeat-stmt | read-stmt | write-stmt</span><br><span class="line">if-stmt → if exp then stmt-sequence end</span><br><span class="line">		  | if exp then stmt-sequence else stmt-sequence end</span><br><span class="line">repeat-stmt → repeat stmt-sequence until exp</span><br><span class="line">assign-stmt → identifier := exp</span><br><span class="line">read-stmt → read identifier</span><br><span class="line">write-stmt → write exp</span><br><span class="line">exp → simple-exp comparision-op simple-exp | simple-exp</span><br><span class="line">comparison-op → &lt; | =</span><br><span class="line">simple-exp → simple-exp addop term | term</span><br><span class="line">addop → +|-</span><br><span class="line">term → term mulop factor | factor</span><br><span class="line">mulop → *|/</span><br><span class="line">factor → (exp) | number | identifier</span><br></pre></td></tr></table></figure>

<p>这里有加粗但是未标出(比如括号实际上是”(“和”)”)</p>
<p>有些可以参考，有些则必须改变。</p>
<p>比如TINY语言的程序是由语句序列构成的，而C–语言的程序是由函数序列构成的，且最后一个函数声明必须是main函数</p>
<p>对名词进行解释：</p>
<p>program：C–程序</p>
<p>function-sequence：函数序列</p>
<p>other-function：除main函数以外的声明函数</p>
<p>main-function：main函数</p>
<p>return-type：返回类型</p>
<p>params：参数</p>
<p>arg-list:函数传入的参数列表</p>
<p>statement-sequence：语句序列</p>
<p>statement：语句</p>
<p>if-stmt：if语句</p>
<p>while-stmt：while语句</p>
<p>declaration-stmt：声明语句</p>
<p>assignment-stmt：赋值语句</p>
<p>input-stmt：输入语句</p>
<p>output-stmt：输出语句</p>
<p>return-stmt：返回语句</p>
<p>func-stmt：函数调用语句</p>
<p>exp：表达式</p>
<p>comparision-op：比较操作符</p>
<p>simple-exp：运算表达式</p>
<p>addop：加减号</p>
<p>term：运算表达式中的乘除法表达式和常量表达式</p>
<p>mulop：乘除号</p>
<p>factor：乘除运算的左右值和常量的值</p>
<p>func-exp:函数调用表达式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">program → function-sequence</span><br><span class="line">function-sequence → other-function function-sequence | main-function</span><br><span class="line">other-function → return-type identifier &quot;(&quot;(params|void)&quot;)&quot; &#123; statement-sequence &#125;</span><br><span class="line">main-function → void main&quot;(&quot;void&quot;)&quot; &#123;statement-sequence&#125;</span><br><span class="line">return-type → void|int</span><br><span class="line">params → params,assignment-stmt|assignment-stmt</span><br><span class="line">statement-sequence → statement-sequence statement|statement</span><br><span class="line">statement → if-stmt|while-stmt|declaration-stmt|assignment-stmt|input-stmt|output-stmt|return-stmt|func-stmt</span><br><span class="line">if-stmt → if&quot;(&quot;exp&quot;)&quot;(&#123;stmt-sequence&#125;|statement)|</span><br><span class="line">		  if&quot;(&quot;exp&quot;)&quot;(&#123;stmt-sequence&#125;|statment)else(&#123;stmt-sequence&#125;|statement)</span><br><span class="line">while-stmt → while&quot;(&quot;exp&quot;)&quot;(&#123;statement-seqence&#125;|statement)</span><br><span class="line">declaration-stmt → int identifier</span><br><span class="line">assignment-stmt → identifier = (number|identifier)</span><br><span class="line">func-stmt → identifier&quot;(&quot;arg-list|ε&quot;)&quot;</span><br><span class="line">arg-list → arg-list, exp|exp</span><br><span class="line">input-stmt → input&quot;(&quot;&quot;)&quot;</span><br><span class="line">output-stmt → output&quot;(&quot;(identifier|number)&quot;)&quot;</span><br><span class="line">return-stmt → return (identifier|number)</span><br><span class="line">exp → simple-exp comparasion-op simple-exp|simple-exp</span><br><span class="line">comparation-op → &lt;|&lt;=|==|&gt;=|&gt;|!=</span><br><span class="line">simple-exp → simple-exp addop term|term</span><br><span class="line">addop → +|-</span><br><span class="line">term → term mulop factor|factor</span><br><span class="line">mulop → *|/</span><br><span class="line">factor → &quot;(&quot;exp&quot;)&quot;|num|identifier|func-exp</span><br><span class="line">func-exp → func-stmt</span><br></pre></td></tr></table></figure>

<h5 id="C–语言的EBNF文法描述"><a href="#C–语言的EBNF文法描述" class="headerlink" title="C–语言的EBNF文法描述"></a>C–语言的EBNF文法描述</h5><p>实际构造递归下降代码时依照的是EBNF描述</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">program → function-sequence</span><br><span class="line">function-sequence → &#123;other-function&#125; main-function</span><br><span class="line">other-function → return-type identifier &quot;(&quot;(params|void)&quot;)&quot; &quot;&#123;&quot; statement-sequence &quot;&#125;&quot;</span><br><span class="line">main-function → void main&quot;(&quot;void&quot;)&quot; &quot;&#123;&quot;statement-sequence&quot;&#125;&quot;</span><br><span class="line">return-type → void|int</span><br><span class="line">params → declaration-stmt &#123;,declaration-stmt&#125;</span><br><span class="line">statement-sequence → &#123;statement&#125;</span><br><span class="line">statement → (if-stmt|while-stmt|declaration-stmt|assignment-stmt|input-stmt|output-stmt|return-stmt|</span><br><span class="line">			func-statement);</span><br><span class="line">if-stmt → if&quot;(&quot;exp&quot;)&quot; (&quot;&#123;&quot;stmt-sequence&quot;&#125;&quot;|statement)[else(&quot;&#123;&quot;stmt-sequence&quot;&#125;&quot;|statement)]</span><br><span class="line">while-stmt → while&quot;(&quot;exp&quot;)&quot; (&quot;&#123;&quot;statement-seqence&quot;&#125;&quot;|statement)</span><br><span class="line">declaration-stmt → int identifier</span><br><span class="line">assignment-stmt → identifier = (number|identifier)</span><br><span class="line">input-stmt → input&quot;(&quot;&quot;)&quot;</span><br><span class="line">output-stmt → output&quot;(&quot;(identifier|number)&quot;)&quot;</span><br><span class="line">return-stmt → return (identifier|number)</span><br><span class="line">exp → simple-exp[comparasion-op simple-exp]                                                                    comparation-op → &lt;|&lt;=|==|&gt;=|&gt;|!=</span><br><span class="line">simple-exp → term &#123;addop term&#125;</span><br><span class="line">term → factor&#123;mulop factor&#125;</span><br><span class="line">mulop → *|/</span><br><span class="line">factor → &quot;(&quot;exp&quot;)&quot; | number | identifier | func-exp</span><br><span class="line">func-exp → func-stmt</span><br></pre></td></tr></table></figure>

<h5 id="C–语言的递归下降代码"><a href="#C–语言的递归下降代码" class="headerlink" title="C–语言的递归下降代码"></a>C–语言的递归下降代码</h5><p>和词法分析所做的一样，首先我们先对节点的定义进行修改，TINY语言中仍然可用的节点类型保留下来</p>
<p>另外由于涉及到了更多的表达式，StmtKind也要修改</p>
<p>在global.h中修改TreeNode</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**************************************************/</span></span><br><span class="line"><span class="comment">/***********   Syntax tree for parsing ************/</span></span><br><span class="line"><span class="comment">/**************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span>StmtK,ExpK,FuncK&#125; NodeKind;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span>IfK,WhileK,AssignK,InputK,OutputK,ReturnK,DeclareK,FunctionK&#125; StmtKind;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span>OpK,ConstK,IdK,FunK&#125; ExpKind;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span>otherK,mainK&#125; FuncKind;</span><br><span class="line"><span class="comment">/* ExpType is used for type checking */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span>Void,Integer,Boolean&#125; ExpType;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXCHILDREN 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span></span></span><br><span class="line"><span class="class">   &#123;</span> <span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span> * <span class="title">child</span>[<span class="title">MAXCHILDREN</span>];</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span> * <span class="title">sibling</span>;</span></span><br><span class="line">     <span class="type">int</span> lineno;</span><br><span class="line">     NodeKind nodekind;</span><br><span class="line">     <span class="class"><span class="keyword">union</span> &#123;</span> StmtKind stmt; ExpKind <span class="built_in">exp</span>; FuncKind func;&#125; kind;</span><br><span class="line">     <span class="class"><span class="keyword">union</span> &#123;</span> TokenType op;</span><br><span class="line">             <span class="type">int</span> val;</span><br><span class="line">             <span class="type">char</span> * name; &#125; attr;</span><br><span class="line">     ExpType type; <span class="comment">/* for type checking of exps */</span></span><br><span class="line">     TokenType returnType;</span><br><span class="line">   &#125; TreeNode;</span><br></pre></td></tr></table></figure>

<p>我们为节点类型新增了一个funcK类型表示函数，声明了函数的类型FuncKind（其他函数和主函数），并且给treeNode的属性加上了一个返回值类型，它是为函数类型的节点准备的</p>
<p>然后在parse.c中修改节点匹配函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改后的</span></span><br><span class="line"><span class="comment">/* function prototypes for recursive calls */</span></span><br><span class="line"><span class="type">static</span> TreeNode *<span class="title function_">function_sequence</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> TreeNode *<span class="title function_">other_function</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> TreeNode *<span class="title function_">main_function</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> TreeNode *<span class="title function_">params</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> TreeNode *<span class="title function_">stmt_sequence</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> TreeNode *<span class="title function_">statement</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> TreeNode *<span class="title function_">if_stmt</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> TreeNode *<span class="title function_">while_stmt</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> TreeNode *<span class="title function_">declaration_stmt</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> TreeNode *<span class="title function_">assign_stmt</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> TreeNode *<span class="title function_">arg_list</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> TreeNode *<span class="title function_">input_stmt</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> TreeNode *<span class="title function_">output_stmt</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> TreeNode *<span class="title function_">return_stmt</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> TreeNode *<span class="title function_">exp</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> TreeNode *<span class="title function_">simple_exp</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> TreeNode *<span class="title function_">term</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> TreeNode *<span class="title function_">factor</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>然后我们在parse函数中把根节点类型改为<code>function_sequence</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改后</span></span><br><span class="line"><span class="comment">/****************************************/</span></span><br><span class="line"><span class="comment">/* the primary function of the parser   */</span></span><br><span class="line"><span class="comment">/****************************************/</span></span><br><span class="line"><span class="comment">/* Function parse returns the newly</span></span><br><span class="line"><span class="comment"> * constructed syntax tree</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">TreeNode *<span class="title function_">parse</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  TreeNode *t;</span><br><span class="line">  token = getToken();</span><br><span class="line">  t = function_sequence();</span><br><span class="line">  <span class="keyword">if</span> (token != ENDFILE)</span><br><span class="line">    syntaxError(<span class="string">&quot;Code ends before file\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后给<code>function_sequence</code>添加函数内容</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">TreeNode *<span class="title function_">function_sequence</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  TreeNode *t = newFuncNode(otherK);</span><br><span class="line">  TreeNode *p = t;</span><br><span class="line">  <span class="keyword">while</span> (token != ENDFILE) &#123;</span><br><span class="line">    TreeNode *q;</span><br><span class="line">    q = other_function();</span><br><span class="line">    <span class="keyword">if</span> (q != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (t-&gt;sibling == <span class="literal">NULL</span>) &#123; <span class="comment">//说明这是第一个函数，把它作为头部</span></span><br><span class="line">        t = p = q;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (t == <span class="literal">NULL</span>) &#123; <span class="comment">//适用于错误情况</span></span><br><span class="line">        t = p = q;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        p-&gt;sibling = q;</span><br><span class="line">        p = q;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (p-&gt;kind.func == mainK) &#123; <span class="comment">//读取到了主函数，返回</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后给<code>other_function</code>添加函数内容</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">TreeNode *<span class="title function_">other_function</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  TreeNode *t = newFuncNode(otherK); <span class="comment">//初始化</span></span><br><span class="line">  <span class="keyword">switch</span> (token) &#123;                   <span class="comment">//对区别返回类型</span></span><br><span class="line">  <span class="keyword">case</span> INT:</span><br><span class="line">    t-&gt;returnType = INT;</span><br><span class="line">    match(token); <span class="comment">//读取下一个token</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> VOID:</span><br><span class="line">    t-&gt;returnType = VOID;</span><br><span class="line">    match(token); <span class="comment">//读取下一个token</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    syntaxError(<span class="string">&quot;unexpected token -&gt; &quot;</span>);</span><br><span class="line">    printToken(token, tokenString);</span><br><span class="line">    token = getToken();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (token == MAIN &amp;&amp; t-&gt;returnType == VOID) &#123; <span class="comment">//可以认为是读到了主函数</span></span><br><span class="line">    token = getToken();</span><br><span class="line">    t = main_function();</span><br><span class="line">    t-&gt;attr.name = copyString(tokenString);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (token == ID) &#123; <span class="comment">//或者仍然是其他函数</span></span><br><span class="line">    t-&gt;attr.name = copyString(tokenString);</span><br><span class="line">    token = getToken();</span><br><span class="line">    match(LPAREN);   <span class="comment">//匹配左括号</span></span><br><span class="line">    <span class="keyword">switch</span> (token) &#123; <span class="comment">//匹配参数</span></span><br><span class="line">    <span class="keyword">case</span> VOID:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      t-&gt;child[<span class="number">0</span>] = params();</span><br><span class="line">    &#125;</span><br><span class="line">    match(RPAREN);                 <span class="comment">//匹配右括号</span></span><br><span class="line">    match(LBPAREN);                <span class="comment">//匹配左大括号</span></span><br><span class="line">    t-&gt;child[<span class="number">1</span>] = stmt_sequence(); <span class="comment">//匹配函数体并作为函数节点的子节点</span></span><br><span class="line">    match(RBPAREN);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    syntaxError(<span class="string">&quot;unexpected token -&gt; &quot;</span>);</span><br><span class="line">    printToken(token, tokenString);</span><br><span class="line">    <span class="built_in">fprintf</span>(listing, <span class="string">&quot;      &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里我们用到了新的工具函数<code>newFuncNode</code>，这个函数的作用是初始化一个函数类型的节点并初始化相关信息</p>
<p>在until.h中添加函数声明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TreeNode * <span class="title function_">newFuncNode</span><span class="params">(FuncKind)</span>;</span><br></pre></td></tr></table></figure>

<p>在until.c中给出函数内容</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">TreeNode * <span class="title function_">newFuncNode</span><span class="params">(FuncKind kind)</span> &#123;</span><br><span class="line">  TreeNode * t = (TreeNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">if</span> (t==<span class="literal">NULL</span>)</span><br><span class="line">    <span class="built_in">fprintf</span>(listing,<span class="string">&quot;Out of memory error at line %d\n&quot;</span>,lineno);</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;MAXCHILDREN;i++) t-&gt;child[i] = <span class="literal">NULL</span>;</span><br><span class="line">    t-&gt;sibling = <span class="literal">NULL</span>;</span><br><span class="line">    t-&gt;nodekind = FuncK;</span><br><span class="line">    t-&gt;kind.func = kind;</span><br><span class="line">    t-&gt;lineno = lineno;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>other_function</code>在匹配过程中调用了<code>main_function</code>函数来把节点转换为主函数类型，下面完善<code>main_function()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TreeNode *<span class="title function_">main_function</span><span class="params">()</span> &#123;</span><br><span class="line">  TreeNode *t = newFuncNode(mainK);</span><br><span class="line">  <span class="comment">//由于是从other_function中调用，之前的过程已经匹配过了</span></span><br><span class="line">  match(LPAREN);</span><br><span class="line">  match(VOID);</span><br><span class="line">  match(RPAREN);</span><br><span class="line">  match(LBPAREN);</span><br><span class="line">  t-&gt;child[<span class="number">1</span>] = stmt_sequence();</span><br><span class="line">  match(RBPAREN);</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是params匹配函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">TreeNode *<span class="title function_">params</span><span class="params">()</span> &#123;</span><br><span class="line">  TreeNode *t = declaration_stmt();<span class="comment">//函数形参实际上是声明的过程</span></span><br><span class="line">  TreeNode *p = t;</span><br><span class="line">  <span class="keyword">while</span> (token != RPAREN) &#123;<span class="comment">//匹配到右括号则说明形参声明完毕</span></span><br><span class="line">    TreeNode *q;</span><br><span class="line">    match(COMMA);</span><br><span class="line">    q = declaration_stmt();</span><br><span class="line">    <span class="keyword">if</span> (q != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (t == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        t = p = q;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        p-&gt;sibling = q;<span class="comment">//构造参数链表</span></span><br><span class="line">        p = q;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>语句序列不用修改很多，但要注意结束时是在匹配到大括号时</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">TreeNode *<span class="title function_">stmt_sequence</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  TreeNode *t = statement();</span><br><span class="line">  TreeNode *p = t;</span><br><span class="line">  <span class="keyword">while</span> (token != RBPAREN) &#123;</span><br><span class="line">    TreeNode *q;</span><br><span class="line">    q = statement();</span><br><span class="line">    <span class="keyword">if</span> (q != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (t == <span class="literal">NULL</span>)</span><br><span class="line">        t = p = q;</span><br><span class="line">      <span class="keyword">else</span> <span class="comment">/* now p cannot be NULL either */</span></span><br><span class="line">      &#123;</span><br><span class="line">        p-&gt;sibling = q;</span><br><span class="line">        p = q;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是语句</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">TreeNode *<span class="title function_">statement</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  TreeNode *t = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">switch</span> (token) &#123;</span><br><span class="line">  <span class="keyword">case</span> IF:</span><br><span class="line">    t = if_stmt();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> WHILE:</span><br><span class="line">    t = while_stmt();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> ID:</span><br><span class="line">    t = assign_stmt();</span><br><span class="line">    match(SEMI);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> INPUT:</span><br><span class="line">    t = input_stmt();</span><br><span class="line">    match(SEMI);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> OUTPUT:</span><br><span class="line">    t = output_stmt();</span><br><span class="line">    match(SEMI);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> RETURN:</span><br><span class="line">    t = return_stmt();</span><br><span class="line">    match(SEMI);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> INT:</span><br><span class="line">    t = declaration_stmt();</span><br><span class="line">    match(SEMI);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    syntaxError(<span class="string">&quot;unexpected token -&gt; &quot;</span>);</span><br><span class="line">    printToken(token, tokenString);</span><br><span class="line">    token = getToken();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125; <span class="comment">/* end case */</span></span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有些语句需要分号，有些语句不需要分号，另外有些语句不能立马被判断出来（例如函数调用和赋值，开始都是ID,这里先默认是赋值）</p>
<p>各种语句的匹配函数如下（太多了，不想解释了。。）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line">TreeNode *<span class="title function_">if_stmt</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  TreeNode *t = newStmtNode(IfK);</span><br><span class="line">  match(IF);</span><br><span class="line">  match(LPAREN);</span><br><span class="line">  <span class="keyword">if</span> (t != <span class="literal">NULL</span>)</span><br><span class="line">    t-&gt;child[<span class="number">0</span>] = <span class="built_in">exp</span>();</span><br><span class="line">  match(RPAREN);</span><br><span class="line">  <span class="keyword">if</span> (token == LBPAREN) &#123;</span><br><span class="line">    match(LBPAREN);</span><br><span class="line">    <span class="keyword">if</span> (t != <span class="literal">NULL</span>)</span><br><span class="line">      t-&gt;child[<span class="number">1</span>] = stmt_sequence();</span><br><span class="line">    match(RBPAREN);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (t != <span class="literal">NULL</span>)</span><br><span class="line">      t-&gt;child[<span class="number">1</span>] = statement();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (token == ELSE) &#123;</span><br><span class="line">    match(ELSE);</span><br><span class="line">    <span class="keyword">if</span> (token == LBPAREN) &#123;</span><br><span class="line">      match(LBPAREN);</span><br><span class="line">      <span class="keyword">if</span> (t != <span class="literal">NULL</span>)</span><br><span class="line">        t-&gt;child[<span class="number">2</span>] = stmt_sequence();</span><br><span class="line">      match(RBPAREN);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (t != <span class="literal">NULL</span>)</span><br><span class="line">        t-&gt;child[<span class="number">2</span>] = statement();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode *<span class="title function_">while_stmt</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  TreeNode *t = newStmtNode(WhileK);</span><br><span class="line">  match(WHILE);</span><br><span class="line">  match(LPAREN);</span><br><span class="line">  <span class="keyword">if</span> (t != <span class="literal">NULL</span>)</span><br><span class="line">    t-&gt;child[<span class="number">0</span>] = <span class="built_in">exp</span>();</span><br><span class="line">  match(RPAREN);</span><br><span class="line">  <span class="keyword">if</span> (token == LBPAREN) &#123;</span><br><span class="line">    match(LBPAREN);</span><br><span class="line">    <span class="keyword">if</span> (t != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      t-&gt;child[<span class="number">1</span>] = stmt_sequence();</span><br><span class="line">    &#125;</span><br><span class="line">    match(RBPAREN);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (t != <span class="literal">NULL</span>)</span><br><span class="line">      t-&gt;child[<span class="number">1</span>] = statement();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode *<span class="title function_">assign_stmt</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  TreeNode *t = newStmtNode(AssignK);</span><br><span class="line">  <span class="keyword">if</span> ((t != <span class="literal">NULL</span>) &amp;&amp; (token == ID))</span><br><span class="line">    t-&gt;attr.name = copyString(tokenString);</span><br><span class="line">  match(ID);</span><br><span class="line">  <span class="keyword">if</span> (token == ASSIGN) &#123;</span><br><span class="line">    match(ASSIGN);</span><br><span class="line">    <span class="keyword">if</span> (t != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      t-&gt;child[<span class="number">0</span>] = <span class="built_in">exp</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (token == LPAREN) &#123;</span><br><span class="line">    t-&gt;kind.stmt = FunctionK;</span><br><span class="line">    match(LPAREN);</span><br><span class="line">    <span class="keyword">if</span> (t != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      t-&gt;child[<span class="number">0</span>] = arg_list();</span><br><span class="line">    &#125;</span><br><span class="line">    match(RPAREN);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode *<span class="title function_">arg_list</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  TreeNode *t = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">if</span> (token != RPAREN) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (token) &#123;</span><br><span class="line">    <span class="keyword">case</span> ID:</span><br><span class="line">      t = newExpNode(IdK);</span><br><span class="line">      t-&gt;attr.name = copyString(tokenString);</span><br><span class="line">      match(ID);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> NUM:</span><br><span class="line">      t = newExpNode(ConstK);</span><br><span class="line">      t-&gt;attr.val = atoi(tokenString);</span><br><span class="line">      match(NUM);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      syntaxError(<span class="string">&quot;unexpected token -&gt; &quot;</span>);</span><br><span class="line">      printToken(token, tokenString);</span><br><span class="line">      token = getToken();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode *p = t;</span><br><span class="line">    <span class="keyword">while</span> (token != RPAREN) &#123;</span><br><span class="line">      match(COMMA);</span><br><span class="line">      TreeNode *q;</span><br><span class="line">      <span class="keyword">switch</span> (token) &#123;</span><br><span class="line">      <span class="keyword">case</span> ID:</span><br><span class="line">        q = newExpNode(IdK);</span><br><span class="line">        q-&gt;attr.name = copyString(tokenString);</span><br><span class="line">        p-&gt;sibling = q;</span><br><span class="line">        p = q;</span><br><span class="line">        match(ID);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> NUM:</span><br><span class="line">        q = newExpNode(ConstK);</span><br><span class="line">        q-&gt;attr.val = atoi(tokenString);</span><br><span class="line">        p-&gt;sibling = q;</span><br><span class="line">        p = q;</span><br><span class="line">        match(NUM);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        syntaxError(<span class="string">&quot;unexpected token -&gt; &quot;</span>);</span><br><span class="line">        printToken(token, tokenString);</span><br><span class="line">        token = getToken();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode *<span class="title function_">input_stmt</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  TreeNode *t = newStmtNode(InputK);</span><br><span class="line">  match(INPUT);</span><br><span class="line">  match(LPAREN);</span><br><span class="line">  match(RPAREN);</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode *<span class="title function_">output_stmt</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  TreeNode *t = newStmtNode(OutputK);</span><br><span class="line">  match(OUTPUT);</span><br><span class="line">  match(LPAREN);</span><br><span class="line">  <span class="keyword">if</span> (t != <span class="literal">NULL</span> &amp;&amp; token != RPAREN) &#123;</span><br><span class="line">    TreeNode *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">switch</span> (token) &#123;</span><br><span class="line">    <span class="keyword">case</span> ID:</span><br><span class="line">      p = newExpNode(IdK);</span><br><span class="line">      p-&gt;attr.name = copyString(tokenString);</span><br><span class="line">      match(ID);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> NUM:</span><br><span class="line">      p = newExpNode(ConstK);</span><br><span class="line">      p-&gt;attr.val = atoi(tokenString);</span><br><span class="line">      match(NUM);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      syntaxError(<span class="string">&quot;unexpected token -&gt; &quot;</span>);</span><br><span class="line">      printToken(token, tokenString);</span><br><span class="line">      token = getToken();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    t-&gt;child[<span class="number">0</span>] = p;</span><br><span class="line">    match(RPAREN);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode *<span class="title function_">return_stmt</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  TreeNode *t = newStmtNode(ReturnK);</span><br><span class="line">  match(RETURN);</span><br><span class="line">  <span class="keyword">if</span> (t != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    t-&gt;child[<span class="number">0</span>] = <span class="built_in">exp</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode *<span class="title function_">declaration_stmt</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  TreeNode *t = newStmtNode(DeclareK);</span><br><span class="line">  match(INT);</span><br><span class="line">  <span class="keyword">if</span> (t != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (token == ID) &#123;</span><br><span class="line">      t-&gt;attr.name = copyString(tokenString);</span><br><span class="line">    &#125;</span><br><span class="line">    match(ID);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有些语句涉及到了在过程中改变类型</p>
<p>然后是表达式相关</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">TreeNode *<span class="title function_">exp</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  TreeNode *t = simple_exp();</span><br><span class="line">  <span class="keyword">if</span> ((token == LT) || (token == EQ) || (token == NEQ) || (token == NEQ) ||</span><br><span class="line">      (token == LET) || (token == BET) || (token == BT)) &#123;</span><br><span class="line">    TreeNode *p = newExpNode(OpK);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      p-&gt;child[<span class="number">0</span>] = t;</span><br><span class="line">      p-&gt;attr.op = token;</span><br><span class="line">      t = p;</span><br><span class="line">    &#125;</span><br><span class="line">    match(token);</span><br><span class="line">    <span class="keyword">if</span> (t != <span class="literal">NULL</span>)</span><br><span class="line">      t-&gt;child[<span class="number">1</span>] = simple_exp();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode *<span class="title function_">simple_exp</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  TreeNode *t = term();</span><br><span class="line">  <span class="keyword">while</span> ((token == PLUS) || (token == MINUS)) &#123;</span><br><span class="line">    TreeNode *p = newExpNode(OpK);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      p-&gt;child[<span class="number">0</span>] = t;</span><br><span class="line">      p-&gt;attr.op = token;</span><br><span class="line">      t = p;</span><br><span class="line">      match(token);</span><br><span class="line">      t-&gt;child[<span class="number">1</span>] = term();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode *<span class="title function_">term</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  TreeNode *t = factor();</span><br><span class="line">  <span class="keyword">while</span> ((token == TIMES) || (token == OVER)) &#123;</span><br><span class="line">    TreeNode *p = newExpNode(OpK);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      p-&gt;child[<span class="number">0</span>] = t;</span><br><span class="line">      p-&gt;attr.op = token;</span><br><span class="line">      t = p;</span><br><span class="line">      match(token);</span><br><span class="line">      p-&gt;child[<span class="number">1</span>] = factor();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode *<span class="title function_">factor</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  TreeNode *t = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">switch</span> (token) &#123;</span><br><span class="line">  <span class="keyword">case</span> INPUT:</span><br><span class="line">    t = newExpNode(FunK);</span><br><span class="line">    <span class="keyword">if</span> (t != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      t-&gt;attr.name = copyString(tokenString);</span><br><span class="line">      match(INPUT);</span><br><span class="line">      match(LPAREN);</span><br><span class="line">      match(RPAREN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> NUM:</span><br><span class="line">    t = newExpNode(ConstK);</span><br><span class="line">    <span class="keyword">if</span> (t != <span class="literal">NULL</span>)</span><br><span class="line">      t-&gt;attr.val = atoi(tokenString);</span><br><span class="line">    match(NUM);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> ID:</span><br><span class="line">    t = newExpNode(IdK);</span><br><span class="line">    <span class="keyword">if</span> (t != <span class="literal">NULL</span>)</span><br><span class="line">      t-&gt;attr.name = copyString(tokenString);</span><br><span class="line">    match(ID);</span><br><span class="line">    <span class="keyword">if</span> (token == LPAREN) &#123;</span><br><span class="line">      t-&gt;kind.<span class="built_in">exp</span> = FunK;</span><br><span class="line">      match(LPAREN);</span><br><span class="line">      t-&gt;child[<span class="number">0</span>] = arg_list();</span><br><span class="line">      match(RPAREN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> LPAREN:</span><br><span class="line">    match(LPAREN);</span><br><span class="line">    t = <span class="built_in">exp</span>();</span><br><span class="line">    match(RPAREN);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    syntaxError(<span class="string">&quot;unexpected token -&gt; &quot;</span>);</span><br><span class="line">    printToken(token, tokenString);</span><br><span class="line">    token = getToken();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大体的parse函数就是这样。</p>
<p>当然，如果想打印出过程的话涉及到util.c中函数的改变</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* procedure printTree prints a syntax tree to the</span></span><br><span class="line"><span class="comment"> * listing file using indentation to indicate subtrees</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printTree</span><span class="params">(TreeNode *tree)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  INDENT;</span><br><span class="line">  <span class="keyword">while</span> (tree != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    printSpaces();</span><br><span class="line">    <span class="keyword">if</span> (tree-&gt;nodekind == FuncK) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (tree-&gt;kind.func) &#123;</span><br><span class="line">      <span class="keyword">case</span> otherK:</span><br><span class="line">        <span class="built_in">fprintf</span>(listing, <span class="string">&quot;function declaration:%s\n&quot;</span>, tree-&gt;attr.name);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> mainK:</span><br><span class="line">        <span class="built_in">fprintf</span>(listing, <span class="string">&quot;function declaration: main\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">fprintf</span>(listing, <span class="string">&quot;Unknown FuncNode kind\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tree-&gt;nodekind == StmtK) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (tree-&gt;kind.stmt) &#123;</span><br><span class="line">      <span class="keyword">case</span> IfK:</span><br><span class="line">        <span class="built_in">fprintf</span>(listing, <span class="string">&quot;If\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> WhileK:</span><br><span class="line">        <span class="built_in">fprintf</span>(listing, <span class="string">&quot;While\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> AssignK:</span><br><span class="line">        <span class="built_in">fprintf</span>(listing, <span class="string">&quot;Assign to: %s\n&quot;</span>, tree-&gt;attr.name);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> InputK:</span><br><span class="line">        <span class="built_in">fprintf</span>(listing, <span class="string">&quot;Input\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> OutputK:</span><br><span class="line">        <span class="built_in">fprintf</span>(listing, <span class="string">&quot;Write\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> ReturnK:</span><br><span class="line">        <span class="built_in">fprintf</span>(listing, <span class="string">&quot;return:\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> DeclareK:</span><br><span class="line">        <span class="built_in">fprintf</span>(listing, <span class="string">&quot;Declare %s\n&quot;</span>, tree-&gt;attr.name);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">fprintf</span>(listing, <span class="string">&quot;Unknown ExpNode kind\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tree-&gt;nodekind == ExpK) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (tree-&gt;kind.<span class="built_in">exp</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> OpK:</span><br><span class="line">        <span class="built_in">fprintf</span>(listing, <span class="string">&quot;Op: &quot;</span>);</span><br><span class="line">        printToken(tree-&gt;attr.op, <span class="string">&quot;\0&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> ConstK:</span><br><span class="line">        <span class="built_in">fprintf</span>(listing, <span class="string">&quot;Const: %d\n&quot;</span>, tree-&gt;attr.val);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> IdK:</span><br><span class="line">        <span class="built_in">fprintf</span>(listing, <span class="string">&quot;Id: %s\n&quot;</span>, tree-&gt;attr.name);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> FunK:</span><br><span class="line">        <span class="built_in">fprintf</span>(listing, <span class="string">&quot;Func: %s\n&quot;</span>, tree-&gt;attr.name);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">fprintf</span>(listing, <span class="string">&quot;Unknown ExpNode kind\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">fprintf</span>(listing, <span class="string">&quot;Unknown node kind\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXCHILDREN; i++)</span><br><span class="line">      printTree(tree-&gt;child[i]);</span><br><span class="line">    tree = tree-&gt;sibling;</span><br><span class="line">  &#125;</span><br><span class="line">  UNINDENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行对斐波那契函数运行语法分析程序，同时打印出词法和语法分析过程的结果如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line">TINY COMPILATION: sample.tny</span><br><span class="line">        <span class="number">1</span>: reserved word: <span class="type">int</span></span><br><span class="line">        <span class="number">1</span>: ID, name= Fib</span><br><span class="line">        <span class="number">1</span>: (</span><br><span class="line">        <span class="number">1</span>: reserved word: <span class="type">int</span></span><br><span class="line">        <span class="number">1</span>: ID, name= num</span><br><span class="line">        <span class="number">1</span>: )</span><br><span class="line">        <span class="number">1</span>: &#123;</span><br><span class="line">        <span class="number">2</span>: reserved word: <span class="keyword">if</span></span><br><span class="line">        <span class="number">2</span>: (</span><br><span class="line">        <span class="number">2</span>: ID, name= num</span><br><span class="line">        <span class="number">2</span>: &gt;=</span><br><span class="line">        <span class="number">2</span>: NUM, val= <span class="number">0</span></span><br><span class="line">        <span class="number">2</span>: )</span><br><span class="line">        <span class="number">2</span>: &#123;</span><br><span class="line">        <span class="number">3</span>: reserved word: <span class="type">int</span></span><br><span class="line">        <span class="number">3</span>: ID, name= first</span><br><span class="line">        <span class="number">3</span>: ;</span><br><span class="line">        <span class="number">4</span>: reserved word: <span class="type">int</span></span><br><span class="line">        <span class="number">4</span>: ID, name= second</span><br><span class="line">        <span class="number">4</span>: ;</span><br><span class="line">        <span class="number">5</span>: reserved word: <span class="type">int</span></span><br><span class="line">        <span class="number">5</span>: ID, name= third</span><br><span class="line">        <span class="number">5</span>: ;</span><br><span class="line">        <span class="number">6</span>: reserved word: <span class="type">int</span></span><br><span class="line">        <span class="number">6</span>: ID, name= i</span><br><span class="line">        <span class="number">6</span>: ;</span><br><span class="line">        <span class="number">7</span>: ID, name= first</span><br><span class="line">        <span class="number">7</span>: =</span><br><span class="line">        <span class="number">7</span>: NUM, val= <span class="number">0</span></span><br><span class="line">        <span class="number">7</span>: ;</span><br><span class="line">        <span class="number">8</span>: ID, name= second</span><br><span class="line">        <span class="number">8</span>: =</span><br><span class="line">        <span class="number">8</span>: NUM, val= <span class="number">1</span></span><br><span class="line">        <span class="number">8</span>: ;</span><br><span class="line">        <span class="number">9</span>: ID, name= third</span><br><span class="line">        <span class="number">9</span>: =</span><br><span class="line">        <span class="number">9</span>: NUM, val= <span class="number">0</span></span><br><span class="line">        <span class="number">9</span>: ;</span><br><span class="line">        <span class="number">10</span>: reserved word: <span class="keyword">while</span></span><br><span class="line">        <span class="number">10</span>: (</span><br><span class="line">        <span class="number">10</span>: ID, name= i</span><br><span class="line">        <span class="number">10</span>: &lt;</span><br><span class="line">        <span class="number">10</span>: ID, name= num</span><br><span class="line">        <span class="number">10</span>: )</span><br><span class="line">        <span class="number">10</span>: &#123;</span><br><span class="line">        <span class="number">11</span>: ID, name= third</span><br><span class="line">        <span class="number">11</span>: =</span><br><span class="line">        <span class="number">11</span>: ID, name= first</span><br><span class="line">        <span class="number">11</span>: +</span><br><span class="line">        <span class="number">11</span>: ID, name= second</span><br><span class="line">        <span class="number">11</span>: ;</span><br><span class="line">        <span class="number">12</span>: ID, name= first</span><br><span class="line">        <span class="number">12</span>: =</span><br><span class="line">        <span class="number">12</span>: ID, name= second</span><br><span class="line">        <span class="number">12</span>: ;</span><br><span class="line">        <span class="number">13</span>: ID, name= second</span><br><span class="line">        <span class="number">13</span>: =</span><br><span class="line">        <span class="number">13</span>: ID, name= third</span><br><span class="line">        <span class="number">13</span>: ;</span><br><span class="line">        <span class="number">14</span>: &#125;</span><br><span class="line">        <span class="number">15</span>: &#125;</span><br><span class="line">        <span class="number">16</span>: reserved word: <span class="keyword">return</span></span><br><span class="line">        <span class="number">16</span>: ID, name= third</span><br><span class="line">        <span class="number">16</span>: ;</span><br><span class="line">        <span class="number">17</span>: &#125;</span><br><span class="line">        <span class="number">20</span>: reserved word: <span class="type">void</span></span><br><span class="line">        <span class="number">20</span>: reserved word: main</span><br><span class="line">        <span class="number">20</span>: (</span><br><span class="line">        <span class="number">20</span>: reserved word: <span class="type">void</span></span><br><span class="line">        <span class="number">20</span>: )</span><br><span class="line">        <span class="number">20</span>: &#123;</span><br><span class="line">        <span class="number">21</span>: reserved word: <span class="type">int</span></span><br><span class="line">        <span class="number">21</span>: ID, name= num</span><br><span class="line">        <span class="number">21</span>: ;</span><br><span class="line">        <span class="number">22</span>: reserved word: <span class="type">int</span></span><br><span class="line">        <span class="number">22</span>: ID, name= result</span><br><span class="line">        <span class="number">22</span>: ;</span><br><span class="line">        <span class="number">23</span>: ID, name= num</span><br><span class="line">        <span class="number">23</span>: =</span><br><span class="line">        <span class="number">23</span>: reserved word: input</span><br><span class="line">        <span class="number">23</span>: (</span><br><span class="line">        <span class="number">23</span>: )</span><br><span class="line">        <span class="number">23</span>: ;</span><br><span class="line">        <span class="number">24</span>: ID, name= result</span><br><span class="line">        <span class="number">24</span>: =</span><br><span class="line">        <span class="number">24</span>: ID, name= Fib</span><br><span class="line">        <span class="number">24</span>: (</span><br><span class="line">        <span class="number">24</span>: ID, name= num</span><br><span class="line">        <span class="number">24</span>: )</span><br><span class="line">        <span class="number">24</span>: ;</span><br><span class="line">        <span class="number">25</span>: reserved word: output</span><br><span class="line">        <span class="number">25</span>: (</span><br><span class="line">        <span class="number">25</span>: ID, name= result</span><br><span class="line">        <span class="number">25</span>: )</span><br><span class="line">        <span class="number">25</span>: ;</span><br><span class="line">        <span class="number">26</span>: &#125;</span><br><span class="line">        <span class="number">27</span>: EOF</span><br><span class="line"></span><br><span class="line">Syntax tree:</span><br><span class="line">  function declaration:Fib</span><br><span class="line">    Declare num</span><br><span class="line">    If</span><br><span class="line">      Op: &gt;=</span><br><span class="line">        Id: num</span><br><span class="line">        Const: <span class="number">0</span></span><br><span class="line">      Declare first</span><br><span class="line">      Declare second</span><br><span class="line">      Declare third</span><br><span class="line">      Declare i</span><br><span class="line">      Assign to: first</span><br><span class="line">        Const: <span class="number">0</span></span><br><span class="line">      Assign to: second</span><br><span class="line">        Const: <span class="number">1</span></span><br><span class="line">      Assign to: third</span><br><span class="line">        Const: <span class="number">0</span></span><br><span class="line">      While</span><br><span class="line">        Op: &lt;</span><br><span class="line">          Id: i</span><br><span class="line">          Id: num</span><br><span class="line">        Assign to: third</span><br><span class="line">          Op: +</span><br><span class="line">            Id: first</span><br><span class="line">            Id: second</span><br><span class="line">        Assign to: first</span><br><span class="line">          Id: second</span><br><span class="line">        Assign to: second</span><br><span class="line">          Id: third</span><br><span class="line">    <span class="keyword">return</span>:</span><br><span class="line">      Id: third</span><br><span class="line">  function declaration: main</span><br><span class="line">    Declare num</span><br><span class="line">    Declare result</span><br><span class="line">    Assign to: num</span><br><span class="line">      Func: input</span><br><span class="line">    Assign to: result</span><br><span class="line">      Func: Fib</span><br><span class="line">        Id: num</span><br><span class="line">    Write</span><br><span class="line">      Id: result</span><br></pre></td></tr></table></figure>

<p>下面是github源码</p>
<p><a target="_blank" rel="noopener" href="https://github.com/HUST-SE-LY/loucomp_linux">https://github.com/HUST-SE-LY/loucomp_linux</a></p>
<h3 id="报告部分"><a href="#报告部分" class="headerlink" title="报告部分"></a>报告部分</h3><h4 id="词法分析-1"><a href="#词法分析-1" class="headerlink" title="词法分析"></a>词法分析</h4><h5 id="主要设计和实现思路"><a href="#主要设计和实现思路" class="headerlink" title="主要设计和实现思路"></a>主要设计和实现思路</h5><p>词法分析过程将源程序文件视作一个字符型文本文件并读取字符，将其分为若干个记号（token）。每个token都是表示源程序中信息单元的字符序列，如关键字（keyword），标识符（identifier），特殊符号（special symbol）等。</p>
<p>词法分析的扫描程序由语法分析的分析程序所驱动，因此只需要关心获取单个token（getToken函数）的过程。</p>
<p>针对C–语言的语言规范，可以设计出如下token（含义在括号里表示）：</p>
<p>ENDFILE（文件结束符EOF）,ERROR（表示出现错误的token）,IF（if保留字）,ELSE（else保留字）,WHILE（while保留字）,INPUT（input系统函数保留字）,OUTPUT（output系统函数保留字）,RETURN（return保留字）,VOID（void类型保留字）,INT（int类型保留字）,MAIN（main函数保留字）,ID（标识符）,NUM（数字），ASSIGN（赋值符号&#x3D;）,EQ（相等比较符&#x3D;）,LT（小于比较符&lt;）,NEQ（不等于比较符!&#x3D;）,BT（大于比较符&gt;）,LET（小于等于比较符&lt;&#x3D;）,BET（大于等于比较符&gt;&#x3D;）,PLUS（加号运算符+）,MINUS（减号运算符-）,TIMES（乘号运算符*）,OVER（除号运算符&#x2F;）,LPAREN（左括号(）,RPAREN（右括号)）,SEMI（分号;）,LBPAREN（左大括号{）,RBPAREN（右大括号}）,COMMA（逗号,）</p>
<p>getToken函数的设计是基于有穷自动机（DFA）实现的，在构造DFA之前，我们需要先构造各个token对应的正则表达式</p>
<p>letter &#x3D; [a-zA-Z]<br>digit &#x3D; [0-9]<br>ID &#x3D; letter(letter|digit)*<br>NUM &#x3D; digit+<br>ASSIGN &#x3D; &#x3D;<br>EQ &#x3D; &#x3D;&#x3D;<br>LT &#x3D; &lt;<br>NEQ &#x3D; !&#x3D;<br>BT &#x3D; &gt;<br>LET &#x3D; &lt;&#x3D;<br>BET &#x3D; &gt;&#x3D;<br>PLUS &#x3D; +<br>MINUS &#x3D; -<br>TIMES &#x3D; *<br>OVER &#x3D; &#x2F;<br>LPAREN &#x3D; (<br>RPAREN &#x3D; )<br>LBPAREN &#x3D; {<br>RBPAREN &#x3D; }<br>COMMA &#x3D; ,</p>
<p>然后基于正则表达式构造各自的有穷自动机，再把有穷自动机结合起来形成分析程序依照的有穷自动机</p>
<p>这里配图</p>
<p>分析程序根据有穷自动机设计,这里给出分析程序的算法流程图</p>
<p>这里配图</p>
<p>主要的数据结构：</p>
<p>当前token的类型(TokenType)使用一个枚举类型定义</p>
<p>当前有穷自动机所处的状态(StateType)使用一个枚举类型定义</p>
<p>token的串值采用一个定长数组（41），表示标识符长度不能超过40</p>
<p>保留字的集合采用一个结构体数组定义</p>
<h5 id="词法分析程序代码"><a href="#词法分析程序代码" class="headerlink" title="词法分析程序代码"></a>词法分析程序代码</h5><p>token集合定义部分代码：</p>
<p>这里贴代码</p>
<p>有穷自动机状态集合定义部分代码：</p>
<p>这里贴代码</p>
<p>保留字集合定义部分代码：</p>
<p>这里贴代码</p>
<p>区别标识符和保留字的函数部分代码：</p>
<p>这里贴代码</p>
<p>从输入缓冲区中读入字符和处理先行问题的回退输入的代码：</p>
<p>这里贴代码</p>
<p>获取token的函数代码：</p>
<p>这里贴代码</p>
<p>根据token打印相关内容的工具函数的代码：</p>
<p>这里贴代码</p>
<h5 id="运行截图"><a href="#运行截图" class="headerlink" title="运行截图"></a>运行截图</h5><p>这里附截图</p>
<h4 id="Lex文件"><a href="#Lex文件" class="headerlink" title="Lex文件"></a>Lex文件</h4><h5 id="Lex输入文件代码"><a href="#Lex输入文件代码" class="headerlink" title="Lex输入文件代码"></a>Lex输入文件代码</h5><p>这里贴代码</p>
<h5 id="实验截图"><a href="#实验截图" class="headerlink" title="实验截图"></a>实验截图</h5><p>对Lex输入文件编译构建得到词法分析程序的截图：</p>
<p>这里附图</p>
<p>对斐波那契数代码运行该分析程序的截图：</p>
<p>这里附图</p>
<h4 id="BNF描述"><a href="#BNF描述" class="headerlink" title="BNF描述"></a>BNF描述</h4><p>C–语言的BNF描述：</p>
<p>program → function-sequence<br>function-sequence → other-function function-sequence | main-function<br>other-function → return-type identifier “(“(params|void)”)” { statement-sequence }<br>main-function → void main”(“void”)” {statement-sequence}<br>return-type → void|int<br>params → params,assignment-stmt|assignment-stmt<br>statement-sequence → statement-sequence statement|statement<br>statement → if-stmt|while-stmt|declaration-stmt|assignment-stmt|input-stmt|output-stmt|return-stmt|func-stmt<br>if-stmt → if”(“exp”)”({stmt-sequence}|statement)|<br>          if”(“exp”)”({stmt-sequence}|statment)else({stmt-sequence}|statement)<br>while-stmt → while”(“exp”)”({statement-seqence}|statement)<br>declaration-stmt → int identifier<br>assignment-stmt → identifier &#x3D; (number|identifier)<br>func-stmt → identifier”(“arg-list|ε”)”<br>arg-list → arg-list, exp|exp<br>input-stmt → input”(“”)”<br>output-stmt → output”(“(identifier|number)”)”<br>return-stmt → return (identifier|number)<br>exp → simple-exp comparasion-op simple-exp|simple-exp<br>comparation-op → &lt;|&lt;&#x3D;|&#x3D;&#x3D;|&gt;&#x3D;|&gt;|!&#x3D;<br>simple-exp → simple-exp addop term|term<br>addop → +|-<br>term → term mulop factor|factor<br>mulop → *|&#x2F;<br>factor → “(“exp”)”|num|identifier|func-exp<br>func-exp → func-stmt</p>
<h4 id="语法分析程序"><a href="#语法分析程序" class="headerlink" title="语法分析程序"></a>语法分析程序</h4><h5 id="主要的设计和实现思路"><a href="#主要的设计和实现思路" class="headerlink" title="主要的设计和实现思路"></a>主要的设计和实现思路</h5><p>首先设计抽象语法树节点的数据结构</p>
<p>一个抽象语法树节点由一个结构体构造而来，包括了至多3个子节点，一个兄弟节点，节点所在的行号，节点类型，用联合体（union）构造节点类型下更为细分的子类型和节点包含的属性，为表达式类型专门设计的表达式的值类型，为函数类型专门设计的返回值类型</p>
<p>用这样的语法树节点构造出的语法树可以用下图来粗略表示</p>
<p>上面给出了BNF，但在构造语法分析程序时使用的是EBNF，先将BNF转换为EBNF</p>
<p>program → function-sequence<br>function-sequence → {other-function} main-function<br>other-function → return-type identifier “(“(params|void)”)” “{“ statement-sequence “}”<br>main-function → void main”(“void”)” “{“statement-sequence”}”<br>return-type → void|int<br>params → declaration-stmt {,declaration-stmt}<br>statement-sequence → {statement}<br>statement → (if-stmt|while-stmt|declaration-stmt|assignment-stmt|input-stmt|output-stmt|return-stmt|<br>            func-statement);<br>if-stmt → if”(“exp”)” (“{“stmt-sequence”}”|statement)[else(“{“stmt-sequence”}”|statement)]<br>while-stmt → while”(“exp”)” (“{“statement-seqence”}”|statement)<br>declaration-stmt → int identifier<br>assignment-stmt → identifier &#x3D; (number|identifier)<br>input-stmt → input”(“”)”<br>output-stmt → output”(“(identifier|number)”)”<br>return-stmt → return (identifier|number)<br>exp → simple-exp[comparasion-op simple-exp]   </p>
<p> comparation-op → &lt;|&lt;&#x3D;|&#x3D;&#x3D;|&gt;&#x3D;|&gt;|!&#x3D;<br>simple-exp → term {addop term}<br>term → factor{mulop factor}<br>mulop → *|&#x2F;<br>factor → “(“exp”)” | number | identifier | func-exp<br>func-exp → func-stmt</p>
<p>然后根据EBNF构造出不同类型文法所对应的节点数据结构</p>
<p>下面一组图片是每种节点所对应的具体的数据结构</p>
<p>这里配很多图片</p>
<p>每种节点都对应一个匹配函数，在分析程序运行时，会递归地调用它们，递归程序的算法流程图如图所示</p>
<p>这里配图</p>
<p>在分析程序运行过程中同样会调用用于打印语法树的工具函数，实现打印缩进的原理是：</p>
<p>可以看到每调用一次工具函数都会先让缩进增加两格空格，如果有子节点的话就会递归调用工具函数，导致缩进继续增加，缩进效果就是这样实现的。而当没有孩子节点的时候转到兄弟节点（没有兄弟节点就结束while循环），转到兄弟节点后会让缩进减少两格空格，所以同级的节点缩进数一定相同，依靠缩进便于展示树状结构。用流程图表示如下：</p>
<p>这里配图</p>
<h5 id="递归下降语法分析代码"><a href="#递归下降语法分析代码" class="headerlink" title="递归下降语法分析代码"></a>递归下降语法分析代码</h5><p>语法树节点定义部分代码：</p>
<p>这里配代码</p>
<p>分析程序的代码：</p>
<p>这里配代码</p>
<h5 id="实验演示"><a href="#实验演示" class="headerlink" title="实验演示"></a>实验演示</h5><p>这里配图</p>
<p>​                                                                                                                                                                                                                                        </p>
<p>​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                </p>
<p>​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ​                 </p>
<h6 id=""><a href="#" class="headerlink" title=""></a></h6><p>​    </p>
<p>​    </p>
<p>​    </p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title="0" data-url="http://link.hhtjim.com/163/425570952.mp3"></li>
                        
                    
                        
                            <li title="1" data-url="http://link.hhtjim.com/163/425570952.mp3"></li>
                        
                    
                </ul>
            
        </div>
        
        
    <div id="gitalk-container" class="comment link"
		data-enable="false"
        data-ae="false"
        data-ci=""
        data-cs=""
        data-r=""
        data-o=""
        data-a=""
        data-d="false"
    >查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>






</html>
