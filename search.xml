<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>HTTP知识点总结</title>
    <url>/2022/08/03/HTTP/</url>
    <content><![CDATA[<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><hr>
<h2 id="第一章：了解web及网络基础"><a href="#第一章：了解web及网络基础" class="headerlink" title="第一章：了解web及网络基础"></a>第一章：了解web及网络基础</h2><h3 id="1-1-TCP-x2F-IP"><a href="#1-1-TCP-x2F-IP" class="headerlink" title="1.1 TCP&#x2F;IP"></a>1.1 TCP&#x2F;IP</h3><p>不同硬件，操作系统之间的通信都需要规则，这种规则成为<strong>协议</strong>。</p>
<p>把与互联网相关联的协议集合称为TCP&#x2F;IP</p>
<h3 id="1-2-TCP-x2F-IP分层管理"><a href="#1-2-TCP-x2F-IP分层管理" class="headerlink" title="1.2 TCP&#x2F;IP分层管理"></a>1.2 TCP&#x2F;IP分层管理</h3><p>TCP&#x2F;IP协议族分为四层：</p>
<ul>
<li>应用层：决定了向用户提供应用服务时通信的活动，如FTP,DNS,HTTP</li>
<li>传输层：提供处于网络连接中的两台计算机之间的数据传输，如TCP,UDP</li>
<li>网络层：用来处理在网络上流动的数据包</li>
<li>链路层：处理连接网络的硬件部分</li>
</ul>
<h3 id="1-3-IP-TCP-DNS"><a href="#1-3-IP-TCP-DNS" class="headerlink" title="1.3 IP,TCP,DNS"></a>1.3 IP,TCP,DNS</h3><h4 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h4><p>IP网络协议位于网络层，作用是把各种数据包传给对方。要想确保传输需要满足各种条件，最重要的是IP地址和MAC地址</p>
<p>IP地址是节点被分配的地址，MAC地址是网卡的固定地址，IP地址可变换，MAC地址一般不可变换</p>
<h5 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h5><p>IP间的通信依赖MAC地址，数据在网络上的传递需要经过多个中转站，通过MAC来搜索中转站，ARP协议可以通过IP地址反查出MAC地址</p>
<p>没有设备能够全面掌握数据的传输情况</p>
<h4 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h4><p>位于传输层，提供可靠的字节流服务</p>
<h5 id="确保数据能到达目标"><a href="#确保数据能到达目标" class="headerlink" title="确保数据能到达目标"></a>确保数据能到达目标</h5><p>采用三次握手策略。</p>
<p>握手过程中使用了TCP的标志：SYN和ACK</p>
<p>发送端发送带有SYN标志的数据包给对方，接收端返回带有SYN&#x2F;ACK标志的数据包以示传达确认信息，最后发送端回传带有ACK标志的数据包代表握手结束</p>
<p>若握手在某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包</p>
<h4 id="DNS服务"><a href="#DNS服务" class="headerlink" title="DNS服务"></a>DNS服务</h4><p>位于应用层，提供域名到IP的解析服务</p>
<h3 id="1-4-HTTP与其他协议的关系"><a href="#1-4-HTTP与其他协议的关系" class="headerlink" title="1.4 HTTP与其他协议的关系"></a>1.4 HTTP与其他协议的关系</h3><p>HTTP生成报文-&gt;TCP将报文分割处理-&gt;IP将报文段传输-&gt;TCP将报文段重组-&gt;HTTP对接受到的报文进行处理再回传</p>
<h3 id="1-5-URL和URI"><a href="#1-5-URL和URI" class="headerlink" title="1.5 URL和URI"></a>1.5 URL和URI</h3><p>URI用字符串标识某一互联网资源，URL表示资源的地点，URL是URI的子集</p>
<hr>
<h2 id="第二章：简单的HTTP协议"><a href="#第二章：简单的HTTP协议" class="headerlink" title="第二章：简单的HTTP协议"></a>第二章：简单的HTTP协议</h2><h3 id="2-1-HTTP协议用于客户端和服务器端之间的通信"><a href="#2-1-HTTP协议用于客户端和服务器端之间的通信" class="headerlink" title="2.1 HTTP协议用于客户端和服务器端之间的通信"></a>2.1 HTTP协议用于客户端和服务器端之间的通信</h3><p>请求访问文本等资源的一端成为客户端，提供资源做出响应的一端称为服务器端</p>
<h3 id="2-2-通过请求和响应的交换达成协议"><a href="#2-2-通过请求和响应的交换达成协议" class="headerlink" title="2.2 通过请求和响应的交换达成协议"></a>2.2 通过请求和响应的交换达成协议</h3><p>服务器在没有接收到请求时是不会响应的</p>
<p>一段请求报文：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/index.htm</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>hacker.jp</span><br></pre></td></tr></table></figure>

<ul>
<li>GET表示请求服务的类型，称为<strong>方法</strong></li>
<li><code>/index.htm</code>表示了请求访问的资源对象，也叫请求URI</li>
<li><code>HTTP/1.1</code>表示HTTP的版本号</li>
</ul>
<p>请求报文是由请求方法，请求URI，协议版本，可选的请求首部字段和内容实体构成的</p>
<p>请求首部字段和内容实体之后介绍</p>
<p>一段响应报文：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>TUe, 10 Jul 2012 6:50:15 GMT</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>362</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html</span><br><span class="line"></span><br><span class="line"><span class="language-lasso">&lt;html&gt;</span></span><br><span class="line"><span class="language-lasso"><span class="params">...</span><span class="params">...</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>HTTP/1.1</code>表示服务器对应的HTTP版本</p>
</li>
<li><p><code>200 OK</code>表示状态码和原因短语</p>
</li>
<li><p><code>Date Content</code>为首部字段内的属性</p>
</li>
<li><p>以一空行分隔，之后的内容为资源实体的主体</p>
</li>
</ul>
<p>响应报文由协议版本，状态码，解释状态码的原因短语，可选的响应首部字段以及实体主体构成</p>
<h3 id="2-3-HTTP是不保存状态的协议"><a href="#2-3-HTTP是不保存状态的协议" class="headerlink" title="2.3 HTTP是不保存状态的协议"></a>2.3 HTTP是不保存状态的协议</h3><p>HTTP协议自身不具备保存之前发送过的请求或响应的功能</p>
<p>为了实现保存状态，引入了Cookie技术</p>
<h3 id="2-4-请求URI定位资源"><a href="#2-4-请求URI定位资源" class="headerlink" title="2.4 请求URI定位资源"></a>2.4 请求URI定位资源</h3><p>HTTP协议使用URI定位互联网上的资源</p>
<p>指定请求URI的方式很多</p>
<p>如果不是访问资源而是对服务器本身发送请求，URI可以使用*代替</p>
<h3 id="2-5告知服务器意图的HTTP方法"><a href="#2-5告知服务器意图的HTTP方法" class="headerlink" title="2.5告知服务器意图的HTTP方法"></a>2.5告知服务器意图的HTTP方法</h3><h4 id="GET-获取资源"><a href="#GET-获取资源" class="headerlink" title="GET:获取资源"></a>GET:获取资源</h4><p>GET方法用来请求已被URI识别的资源</p>
<h4 id="POST：传输实体主体"><a href="#POST：传输实体主体" class="headerlink" title="POST：传输实体主体"></a>POST：传输实体主体</h4><p>POST方法用来传输实体的主体，虽说GET也能传输，但一般不用GET，POST的主要目的并不是获取响应的主体内容</p>
<h4 id="PUT：传输文件"><a href="#PUT：传输文件" class="headerlink" title="PUT：传输文件"></a>PUT：传输文件</h4><p>PUT方法用来传输文件。在报文的主体中包含文件内容，保存到请求URI的指定位置</p>
<p>由于不存在验证机制，任何人都可以上传，存在安全性问题，一般网站不使用PUT</p>
<h4 id="HEAD：获取报文首部"><a href="#HEAD：获取报文首部" class="headerlink" title="HEAD：获取报文首部"></a>HEAD：获取报文首部</h4><p>HEAD与GET一样，只是不返回报文的主体部分，用于确认URI的有效性以及资源更新的日期时间等</p>
<h4 id="DELETE-删除文件"><a href="#DELETE-删除文件" class="headerlink" title="DELETE:删除文件"></a>DELETE:删除文件</h4><p>与PUT相反的方法，一般不用</p>
<h4 id="OPTIONS：查询支持的方法"><a href="#OPTIONS：查询支持的方法" class="headerlink" title="OPTIONS：查询支持的方法"></a>OPTIONS：查询支持的方法</h4><p>查询针对URI指定的资源支持的方法</p>
<h4 id="TRACE：追踪路径"><a href="#TRACE：追踪路径" class="headerlink" title="TRACE：追踪路径"></a>TRACE：追踪路径</h4><p>不常用且可能引发XST攻击，通常不会用到</p>
<h4 id="CONNECT：要求用隧道协议连接代理"><a href="#CONNECT：要求用隧道协议连接代理" class="headerlink" title="CONNECT：要求用隧道协议连接代理"></a>CONNECT：要求用隧道协议连接代理</h4><p>主要使用SSL和TLS协议把通信加密后经网络隧道传输</p>
<h3 id="2-6-持久连接"><a href="#2-6-持久连接" class="headerlink" title="2.6 持久连接"></a>2.6 持久连接</h3><p>即在建立TCP连接后，如果一端没有明确要求断开链接，则保持TCP连接状态</p>
<h3 id="2-7-管线化"><a href="#2-7-管线化" class="headerlink" title="2.7 管线化"></a>2.7 管线化</h3><p>从前发送请求需要收到响应才能发送下一个请求，通过管线化技术不用等待即可发送下一个请求</p>
<h3 id="2-8-使用Cookie的状态管理"><a href="#2-8-使用Cookie的状态管理" class="headerlink" title="2.8 使用Cookie的状态管理"></a>2.8 使用Cookie的状态管理</h3><p>Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端状态</p>
<p>如果请求中没有cookie，则会在响应报文中添加cookie</p>
<p>如果请求中有cookie，服务器端会检查cookie识别状态做出响应</p>
<hr>
<h2 id="第三章：HTTP报文内的HTTP信息"><a href="#第三章：HTTP报文内的HTTP信息" class="headerlink" title="第三章：HTTP报文内的HTTP信息"></a>第三章：HTTP报文内的HTTP信息</h2><h3 id="3-1-HTTP报文"><a href="#3-1-HTTP报文" class="headerlink" title="3.1 HTTP报文"></a>3.1 HTTP报文</h3><p>用于HTTP协议交互的信息叫做HTTP报文，请求端的HTTP报文叫请求报文，相应端的叫响应报文</p>
<p>HTTP报文大致可分为报文首部和报文主体两部分，由空行划分，通常并不一定有报文主体</p>
<h3 id="3-2-请求报文和响应报文的结构"><a href="#3-2-请求报文和响应报文的结构" class="headerlink" title="3.2 请求报文和响应报文的结构"></a>3.2 请求报文和响应报文的结构</h3><ul>
<li>报文首部<ul>
<li>请求行：包含用于请求的方法，请求URI和HTTP版本</li>
<li>状态行：包含表明响应结果的状态码，原因短语和HTTP版本</li>
<li>首部字段：包含表示请求和响应的各种条件和属性的各类首部<ul>
<li>通用首部</li>
<li>请求首部</li>
<li>响应首部</li>
<li>实体首部</li>
</ul>
</li>
<li>其他（HTTP的RFC未规定的首部，如Cookie）</li>
</ul>
</li>
<li>空行</li>
<li>报文主体</li>
</ul>
<h3 id="3-3-编码提升传输速率"><a href="#3-3-编码提升传输速率" class="headerlink" title="3.3 编码提升传输速率"></a>3.3 编码提升传输速率</h3><h4 id="报文主体和实体主体"><a href="#报文主体和实体主体" class="headerlink" title="报文主体和实体主体"></a>报文主体和实体主体</h4><p>一般来说报文主体等于实体主体，当编码后实体主体发生变化，与报文主体不同</p>
<h4 id="压缩传输的内容编码"><a href="#压缩传输的内容编码" class="headerlink" title="压缩传输的内容编码"></a>压缩传输的内容编码</h4><p>内容编码指明应用在实体内容上的编码格式，并保持实体信息原样进行压缩，编码后的实体主体由客户端接收并负责解码</p>
<h4 id="分割发送的分块传输编码"><a href="#分割发送的分块传输编码" class="headerlink" title="分割发送的分块传输编码"></a>分割发送的分块传输编码</h4><p>把数据分割成多块，能够让浏览器逐步显示页面</p>
<p>这种把实体主体分块的功能称为分块传输编码，由客户端负责解码</p>
<h3 id="3-4-发送多种数据的多部分对象集合"><a href="#3-4-发送多种数据的多部分对象集合" class="headerlink" title="3.4 发送多种数据的多部分对象集合"></a>3.4 发送多种数据的多部分对象集合</h3><p>HTTP协议采用了多部分对象集合，发送的一份报文主体内可能含有多种类型的实体</p>
<p>多部分对象集合包含的对象如下：</p>
<ul>
<li><p><code>multipart/form-data</code>：在web表单文件上传时使用</p>
</li>
<li><p><code>multipart/byteranges</code>：在状态码206响应报文包含了多个范围的内容时使用</p>
</li>
</ul>
<p>详见p48</p>
<h3 id="3-5-获取部分内容的范围请求"><a href="#3-5-获取部分内容的范围请求" class="headerlink" title="3.5 获取部分内容的范围请求"></a>3.5 获取部分内容的范围请求</h3><p>为指定范围发送的请求称为范围请求</p>
<p>针对范围请求，响应会返回状态码为<code>206 Partial Content</code>的响应报文。对于多重范围的范围请求，响应会在首部字段Content-Type标明multipart&#x2F;byteranges后返回响应报文</p>
<p>如果服务器端无法响应范围请求，则会返回状态码200 OK和完整的实体内容</p>
<h3 id="3-6-内容协商返回最合适的内容"><a href="#3-6-内容协商返回最合适的内容" class="headerlink" title="3.6 内容协商返回最合适的内容"></a>3.6 内容协商返回最合适的内容</h3><p>内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，最终提供给客户端最合适的资源。内容协商会以语言，字符集，编码方式等作为基准判断响应的资源</p>
<p>包含在请求报文中的某些首部字段就是判断标准</p>
<ul>
<li><code>Accept</code></li>
<li><code>Accept-Charset</code></li>
<li><code>Accept-Encoding</code></li>
<li><code>Accept-Language</code></li>
<li><code>Content-Language</code></li>
</ul>
<p>内容协商技术分为以下三种类型</p>
<ul>
<li>服务器驱动协商：以请求的首部字段为参考，由服务器端自动进行内容协商，未必能选择出最优内容</li>
<li>客户端驱动协商：由客户端进行内容协商。用户可从浏览器的可选列表里手动选择，还可以利用JS脚本自动选择</li>
<li>透明协商：是服务器驱动和客户端驱动的结合体，是服务器端和客户端各自进行内容协商的一种方法</li>
</ul>
<hr>
<h2 id="第四章：返回结果状态的HTTP状态码"><a href="#第四章：返回结果状态的HTTP状态码" class="headerlink" title="第四章：返回结果状态的HTTP状态码"></a>第四章：返回结果状态的HTTP状态码</h2><h3 id="4-1-状态码告知服务器端返回的请求结果"><a href="#4-1-状态码告知服务器端返回的请求结果" class="headerlink" title="4.1 状态码告知服务器端返回的请求结果"></a>4.1 状态码告知服务器端返回的请求结果</h3><p>借助状态码，用户可以知道服务器端是正常处理了请求还是出现了错误</p>
<p>响应类别有如下5种</p>
<ul>
<li>1XX<ul>
<li>信息性状态码</li>
<li>表示接收的请求正在处理</li>
</ul>
</li>
<li>2XX<ul>
<li>成功状态码</li>
<li>表示请求正常处理完毕</li>
</ul>
</li>
<li>3XX<ul>
<li>重定向状态码</li>
<li>需要进行附加操作以完成请求</li>
</ul>
</li>
<li>4XX<ul>
<li>客户端错误状态码</li>
<li>服务器无法处理请求</li>
</ul>
</li>
<li>5XX<ul>
<li>服务器错误状态码</li>
<li>服务器处理请求出错</li>
</ul>
</li>
</ul>
<p>经常使用的状态码有14种</p>
<h3 id="4-2-2XX-成功"><a href="#4-2-2XX-成功" class="headerlink" title="4.2 2XX 成功"></a>4.2 2XX 成功</h3><h4 id="200-OK"><a href="#200-OK" class="headerlink" title="200 OK"></a>200 OK</h4><p>表示从客户端发来的请求在服务器端被正常处理了</p>
<p>随状态码返回的信息会因方法不同而发生改变</p>
<h4 id="204-No-Content"><a href="#204-No-Content" class="headerlink" title="204 No Content"></a>204 No Content</h4><p>表示接收的请求已被成功处理，但返回的响应报文中不含实体的主体部分，也不允许返回任何实体的主体</p>
<p>在客户端忘服务器端发送信息，而客户端不需要更新信息内容时使用</p>
<h4 id="206-Partial-Content"><a href="#206-Partial-Content" class="headerlink" title="206 Partial Content"></a>206 Partial Content</h4><p>表示客户端进行了范围请求，服务器成功执行了这部分的GET请求。响应报文中包含有Content-Range指定范围的实体内容</p>
<h3 id="4-3-3XX-重定向"><a href="#4-3-3XX-重定向" class="headerlink" title="4.3 3XX 重定向"></a>4.3 3XX 重定向</h3><h4 id="301-Moved-Permanently"><a href="#301-Moved-Permanently" class="headerlink" title="301 Moved Permanently"></a>301 Moved Permanently</h4><p>永久性重定向。表示请求的资源已经被分配了新的URI，以后应使用资源现在所指的URI</p>
<h4 id="302-Found"><a href="#302-Found" class="headerlink" title="302 Found"></a>302 Found</h4><p>临时重定向。表示请求的资源已经被分配了新的URI，本次应使用资源现在所指的URI</p>
<h4 id="303-See-Other"><a href="#303-See-Other" class="headerlink" title="303 See Other"></a>303 See Other</h4><p>表示请求的资源存在着另一个URI，应使用GET方法定向获取请求的资源</p>
<p>与302有着相同的功能，但明确表示客户端应该使用GET方法获取资源</p>
<h4 id="304-Not-Modified"><a href="#304-Not-Modified" class="headerlink" title="304 Not Modified"></a>304 Not Modified</h4><p>表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但因发生请求未满足条件的情况后直接返回304</p>
<p>和重定向没有关系</p>
<h4 id="307-Temporary-Redirect"><a href="#307-Temporary-Redirect" class="headerlink" title="307 Temporary Redirect"></a>307 Temporary Redirect</h4><p>临时重定向，与302有相同的含义</p>
<p>302标准禁止POST变为GET，但大家并不遵守</p>
<p>307会遵照浏览器标准，不会从POST变为GET。但是对于处理响应时的行为，不同浏览器有可能出现不同情况</p>
<h3 id="4-4-4XX-客户端错误"><a href="#4-4-4XX-客户端错误" class="headerlink" title="4.4 4XX 客户端错误"></a>4.4 4XX 客户端错误</h3><h4 id="400-Bad-Request"><a href="#400-Bad-Request" class="headerlink" title="400 Bad Request"></a>400 Bad Request</h4><p>表示请求报文中有语法错误，需要修改请求内容后再次发送请求</p>
<h4 id="401-Unauthorized"><a href="#401-Unauthorized" class="headerlink" title="401 Unauthorized"></a>401 Unauthorized</h4><p>表示发送的请求需要有通过HTTP认证（BASIC认证，DIGEST认证）的认证信息。若之前已经进行过一次请求，则表示用户认证失败</p>
<p>浏览器初次接收到401响应会弹出认证用的对话窗口</p>
<h4 id="403-Forbidden"><a href="#403-Forbidden" class="headerlink" title="403 Forbidden"></a>403 Forbidden</h4><p>表示对请求资源的访问被服务器拒绝了</p>
<h4 id="404-Not-Found"><a href="#404-Not-Found" class="headerlink" title="404 Not Found"></a>404 Not Found</h4><p>表明服务器上没有请求的资源</p>
<h3 id="4-5-5XX-服务器错误"><a href="#4-5-5XX-服务器错误" class="headerlink" title="4.5 5XX 服务器错误"></a>4.5 5XX 服务器错误</h3><h4 id="500-Internet-Server-Error"><a href="#500-Internet-Server-Error" class="headerlink" title="500 Internet Server Error"></a>500 Internet Server Error</h4><p>表明服务器端在执行请求时发生了错误，也许是web应用的bug所致</p>
<h4 id="503-Server-Unavailable"><a href="#503-Server-Unavailable" class="headerlink" title="503 Server Unavailable"></a>503 Server Unavailable</h4><p>表明服务器正处于超负载或停机维护，暂时无法处理请求</p>
<hr>
<h2 id="第五章-与HTTP协作的web服务器"><a href="#第五章-与HTTP协作的web服务器" class="headerlink" title="第五章 与HTTP协作的web服务器"></a>第五章 与HTTP协作的web服务器</h2><h3 id="5-1-用单台虚拟主机实现多个域名"><a href="#5-1-用单台虚拟主机实现多个域名" class="headerlink" title="5.1 用单台虚拟主机实现多个域名"></a>5.1 用单台虚拟主机实现多个域名</h3><p>即使物理层面只有一个服务器，但使用了虚拟主机的功能，则可以假想已经具有了多台服务器</p>
<p>当两个域名被部署在一个服务器上时，使用DNS服务解析域名后会得到相同的IP地址。</p>
<p>在相同的IP地址下，由于虚拟主机可以寄存多个不同主机名和域名的web网站，因此在发送HTTP请求时，必须在HOST主部中完整指定主机名和域名的URI</p>
<h3 id="5-2-代理，网关，隧道"><a href="#5-2-代理，网关，隧道" class="headerlink" title="5.2 代理，网关，隧道"></a>5.2 代理，网关，隧道</h3><h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><p>代理服务器的基本行为就是接收客户端发送的请求后转发给其他服务器。代理不改变请求URI</p>
<p>持有资源实体的服务器称为源服务器，源服务器返回的响应经过代理服务器传回客户端</p>
<p>可级联多台代理服务器。转发时需要用Via首部字段以标记经处的主机信息</p>
<p>代理有多种使用方法，按两种基准分类</p>
<ul>
<li>缓存代理：代理转发响应时，缓存代理会预先将资源副本（缓存）保存在代理服务器上，当代理再次接收到相同资源的请求时，将缓存的资源直接返回</li>
<li>透明代理：不对报文做任何类型加工的代理类型称为透明代理，反之称为非透明代理</li>
</ul>
<h3 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h3><p>网关的工作方式与代理相似，但网关能使通信链路上的服务器提供非HTTP协议服务</p>
<p>利用网关能提高通信的安全性，因为可以在客户端和网关之间的通信链路上加密以确保连接的安全</p>
<h4 id="隧道"><a href="#隧道" class="headerlink" title="隧道"></a>隧道</h4><p>隧道可按要求建立起一条与其他服务器的通信链路，使用SSL等加密手段进行通信。隧道的目的是确保服务器和客户端能安全通信</p>
<p>隧道本身不会解析HTTP请求，请求保持原样中转给之后的服务器</p>
<h3 id="5-3-缓存"><a href="#5-3-缓存" class="headerlink" title="5.3 缓存"></a>5.3 缓存</h3><p>缓存指代理服务器或客户端本地磁盘内保存的资源副本</p>
<p>利用缓存可减少对源服务器的访问，节省了通信流量和通信时间</p>
<p>缓存服务器是代理服务器的一种，归类在缓存代理类型中</p>
<p>缓存服务器的优势在于利用缓存可以避免多次从源服务器转发资源。</p>
<h4 id="缓存的有效期限"><a href="#缓存的有效期限" class="headerlink" title="缓存的有效期限"></a>缓存的有效期限</h4><p>即使缓存服务器内存在缓存，也会因为客户端的要求，缓存的有效期限等因素，向原服务器确认资源的有效性。若判断缓存失效，缓存服务器会再次从原服务器上获取”新”资源</p>
<h4 id="客户端的缓存"><a href="#客户端的缓存" class="headerlink" title="客户端的缓存"></a>客户端的缓存</h4><p>除了代理服务器中存在缓存，客户端浏览器中也能存在缓存。如果缓存有效，则不用向服务器发送请求，直接从本地磁盘中读取资源</p>
<p>和缓存服务器相同，当判定缓存过期后，会向源服务器确认资源的有效性，若判断缓存失效，浏览器会再次请求新资源</p>
<hr>
<h2 id="第六章-HTTP首部"><a href="#第六章-HTTP首部" class="headerlink" title="第六章 HTTP首部"></a>第六章 HTTP首部</h2><h3 id="6-1-HTTP报文首部"><a href="#6-1-HTTP报文首部" class="headerlink" title="6.1 HTTP报文首部"></a>6.1 HTTP报文首部</h3><p>HTTP请求和响应报文中必定包含报文首部，报文首部由几个字段组成</p>
<ul>
<li>HTTP请求报文：由方法，HTTP版本，HTTP首部字段等部分构成</li>
<li>HTTP响应报文：由HTTP版本，状态码（数字和原因短语），HTTP首部字段三部分构成</li>
</ul>
<h3 id="6-2-HTTP首部字段"><a href="#6-2-HTTP首部字段" class="headerlink" title="6.2 HTTP首部字段"></a>6.2 HTTP首部字段</h3><h4 id="6-2-1-首部字段传递重要信息"><a href="#6-2-1-首部字段传递重要信息" class="headerlink" title="6.2.1 首部字段传递重要信息"></a>6.2.1 首部字段传递重要信息</h4><p>使用首部字段是为了给浏览器和服务器提供报文主体大小，所使用的语言，认证信息等内容</p>
<h4 id="6-2-2-HTTP首部字段结构"><a href="#6-2-2-HTTP首部字段结构" class="headerlink" title="6.2.2 HTTP首部字段结构"></a>6.2.2 HTTP首部字段结构</h4><p>首部字段名： 字段值</p>
<p>可以有多个值，用逗号隔开</p>
<h4 id="6-2-3-4种HTTP首部字段类型"><a href="#6-2-3-4种HTTP首部字段类型" class="headerlink" title="6.2.3 4种HTTP首部字段类型"></a>6.2.3 4种HTTP首部字段类型</h4><ul>
<li>通用首部字段：请求和响应报文双方都会使用的首部</li>
<li>请求首部字段：从客户端向服务器端发送请求报文时使用的首部</li>
<li>响应首部字段：从服务器端向客户端发送响应报文时使用的首部</li>
<li>实体首部字段：针对请求报文和响应报文的实体部分使用的首部</li>
</ul>
<h4 id="6-2-4-HTTP-x2F-1-1首部字段一览"><a href="#6-2-4-HTTP-x2F-1-1首部字段一览" class="headerlink" title="6.2.4 HTTP&#x2F;1.1首部字段一览"></a>6.2.4 HTTP&#x2F;1.1首部字段一览</h4><ul>
<li>通用首部字段<ul>
<li><code>Cache-Control</code>:控制缓存行为</li>
<li><code>Connection</code>:逐跳首部、连接的管理</li>
<li><code>Date</code>:创建报文的日期时间</li>
<li><code>Pragma</code>:报文指令</li>
<li><code>Trailer</code>:报文末端的首部一览</li>
<li><code>Transfer-Encoding</code>:指定报文主体的传输编码方式</li>
<li><code>Upgrade</code>:升级为其他协议</li>
<li><code>Via</code>:代理服务器的相关信息</li>
<li><code>Warning</code>:错误通知</li>
</ul>
</li>
<li>请求首部字段<ul>
<li><code>Accept</code>:用户代理可处理的媒体类型</li>
<li><code>Accept-Charset</code>:优先的字符集</li>
<li><code>Accept-Encoding</code>:优先的内容编码</li>
<li><code>Accept-Language</code>:优先的语言（自然语言）</li>
<li><code>Authorized</code>:Web认证信息</li>
<li><code>Expect</code>:期待服务器的特定行为</li>
<li><code>From</code>:用户的电子邮箱地址</li>
<li><code>Host</code>:请求资源所在的服务器</li>
<li><code>If-Match</code>:比较实体标记（ETag）</li>
<li><code>If-Modified-Since</code>:比较资源的更新时间</li>
<li><code>If-None-Match</code>:比较实体标记（与If-Match相反）</li>
<li><code>If-Range</code>:资源未更新时发送实体Byte的范围请求</li>
<li><code>If-Unmodified-Since</code>:比较资源的更新时间（与If-Modified-Since相反）</li>
<li><code>Max-Forwards</code>:最大传输跳转数</li>
<li><code>Proxy-Authorization</code>:代理服务器要求客户端的认证信息</li>
<li><code>Range</code>:实体的字节范围请求</li>
<li><code>Referer</code>:对请求中URI的原始获取方</li>
<li><code>TE</code>:传输编码的优先级</li>
<li><code>User-Agent</code>:HTTP客户端程序的信息</li>
</ul>
</li>
<li>响应首部字段<ul>
<li><code>Accept-Ranges</code>:是否接收字节范围请求</li>
<li><code>Age</code>:推算资源创建经过时间</li>
<li><code>ETAG</code>:资源的匹配信息</li>
<li><code>Location</code>:令客户端重定向至指定URI</li>
<li><code>Proxy-Authenticate</code>:代理服务器对客户端的认证信息</li>
<li><code>Retry-After</code>:对再次发起请求的时间要求</li>
<li><code>Server</code>:HTTP服务器的安装信息</li>
<li><code>Vary</code>:代理服务器缓存的管理信息</li>
<li><code>WWW-Authenticate</code>:服务器对客户端的认证信息</li>
</ul>
</li>
<li>实体首部字段：<ul>
<li><code>Allow</code>:资源可支持的HTTP方法</li>
<li><code>Content-Encoding</code>:实体主体适用的编码方式</li>
<li><code>Content-Language</code>:实体主体的自然语言</li>
<li><code>Content-Length</code>:实体主体的大小</li>
<li><code>Content-Location</code>:替代对应资源的URI</li>
<li><code>Content-MD5</code>:实体主体的报文摘要</li>
<li><code>Content-Range</code>:实体主体的位置范围</li>
<li><code>Content-Type</code>:实体主体的媒体类型</li>
<li><code>Expires</code>:实体主体过期的日期时间</li>
<li><code>Last-Modified</code>:资源最后的修改日期</li>
</ul>
</li>
</ul>
<h4 id="6-2-5-非HTTP-x2F-1-1首部字段"><a href="#6-2-5-非HTTP-x2F-1-1首部字段" class="headerlink" title="6.2.5 非HTTP&#x2F;1.1首部字段"></a>6.2.5 非HTTP&#x2F;1.1首部字段</h4><p>除了RFC2616中定义的47种首部字段，还有Cookie，Set-Cookie和Content-Disposition等在其他RFC中定义的首部字段，它们的使用频率很高</p>
<h4 id="6-2-6-End-to-end首部和Hop-by-hop首部"><a href="#6-2-6-End-to-end首部和Hop-by-hop首部" class="headerlink" title="6.2.6 End-to-end首部和Hop-by-hop首部"></a>6.2.6 End-to-end首部和Hop-by-hop首部</h4><ul>
<li>端到端首部：分在此类的首部会转发给请求&#x2F;响应对应的最终接受目标，且必须保存在由缓存生成的响应中，另外规定它必须被转发</li>
<li>逐跳首部：分在此类别中的首部只对单次转发有效，会因通过缓存或代理而不再转发</li>
</ul>
<p>HTTP&#x2F;1.1及之后版本中，使用逐跳首部需要提供Connection首部字段</p>
<h3 id="6-3-HTTP通用首部字段"><a href="#6-3-HTTP通用首部字段" class="headerlink" title="6.3 HTTP通用首部字段"></a>6.3 HTTP通用首部字段</h3><p>看书！</p>
<hr>
<h2 id="第七章-确保Web安全的HTTPS"><a href="#第七章-确保Web安全的HTTPS" class="headerlink" title="第七章 确保Web安全的HTTPS"></a>第七章 确保Web安全的HTTPS</h2><h3 id="7-1-HTTP的缺点"><a href="#7-1-HTTP的缺点" class="headerlink" title="7.1 HTTP的缺点"></a>7.1 HTTP的缺点</h3><h4 id="7-1-1-通信使用明文可能被窃听"><a href="#7-1-1-通信使用明文可能被窃听" class="headerlink" title="7.1.1 通信使用明文可能被窃听"></a>7.1.1 通信使用明文可能被窃听</h4><p>HTTP使用未经加密的报文发送。</p>
<p>按TCP&#x2F;IP协议族的工作机制，通信内容在所有的通信链路上都可能遭到窥视</p>
<p>加密后的报文也会被人看到，但是不容易破解而得到其中的含义</p>
<p>可以通过加密处理防止被窃听，加密对象可以如下：</p>
<ul>
<li>通信的加密</li>
</ul>
<p>通过SSL（安全套接层）和TLS（安全传输层协议）组合使用，加密HTTP的通信内容</p>
<p>用SSL建立安全通信链路后，就可以在这条链路上进行HTTP通信，与SSL组合使用的HTTP称为HTTPS（超文本传输安全协议）.</p>
<ul>
<li>内容的加密</li>
</ul>
<p>即把HTTP报文里所含的内容进行加密，前提是客户端和服务器端同时具有加密和解密的功能</p>
<p>这种方式所传输的内容仍有被篡改的风险</p>
<h4 id="7-1-2-不验证通信方的身份就可能遭遇伪装"><a href="#7-1-2-不验证通信方的身份就可能遭遇伪装" class="headerlink" title="7.1.2 不验证通信方的身份就可能遭遇伪装"></a>7.1.2 不验证通信方的身份就可能遭遇伪装</h4><p>HTTP协议中的请求和响应不会对通信方进行确认</p>
<p><strong>任何人可发起请求</strong></p>
<ul>
<li>无法确定目标web服务器是否是伪装服务器</li>
<li>无法确认收到响应的客户端是否是伪装客户端</li>
<li>无法确定正在通信的对方是否具备访问权限</li>
<li>无法判断请求来自何方</li>
<li>无意义的请求也会照单全收，无法阻止Dos攻击</li>
</ul>
<p><strong>查明对手的证书</strong></p>
<p>单单使用HTTP协议无法确定通信方，但使用SSL则可以</p>
<p>SSL不仅提供加密处理，还提供了一种名为证书的手段，用于确定通信方</p>
<p>证书由值得信任的第三方机构提供，用以证明服务器和客户端是实际存在的，伪造证书在技术上异常困难，因此只要能确认证书，就能判断通信方的真实意图</p>
<p>通过使用证书证明通信方就是意料中的服务器，减少了个人信息泄露的可能</p>
<p>客户端持有证书可以用于完成个人身份的确认，也可以用于web网站的认证环节</p>
<h4 id="7-1-3-无法证明报文完整性，可能已遭篡改"><a href="#7-1-3-无法证明报文完整性，可能已遭篡改" class="headerlink" title="7.1.3 无法证明报文完整性，可能已遭篡改"></a>7.1.3 无法证明报文完整性，可能已遭篡改</h4><p><strong>接收到的内容可能有误</strong></p>
<p>HTTP协议无法证明通信报文的完整性，也就是说，没有任何办法确认发送的报文和通信方接收到的报文是相同的</p>
<p><strong>如何防止篡改</strong></p>
<p>常用的方法是用MD5和SHA-1等散列值校验的方法，以及用来确认文件数字签名的方法（PGP）</p>
<p>用户需要自己查看下载的文件是否是原来服务器上的文件，浏览器无法帮助查看</p>
<p>但一旦MD5和PGP本身被改写，用户是无法察觉到的，因此无法确认结果一定正确</p>
<p>因此有必要使用HTTPS</p>
<h3 id="7-2-HTTP-加密-认证-完整性保护-x3D-HTTPS"><a href="#7-2-HTTP-加密-认证-完整性保护-x3D-HTTPS" class="headerlink" title="7.2 HTTP+加密+认证+完整性保护&#x3D;HTTPS"></a>7.2 HTTP+加密+认证+完整性保护&#x3D;HTTPS</h3><h4 id="7-2-1-HTTP加上加密处理和认证及完整性保护后就是HTTPS"><a href="#7-2-1-HTTP加上加密处理和认证及完整性保护后就是HTTPS" class="headerlink" title="7.2.1 HTTP加上加密处理和认证及完整性保护后就是HTTPS"></a>7.2.1 HTTP加上加密处理和认证及完整性保护后就是HTTPS</h4><p>使用HTTPS通信时，使用<code>https://</code>，访问HTTPS通信有效的web网站时，地址栏会出现一个锁。对HTTPS的显示方式会因浏览器不同有所改变</p>
<h4 id="7-2-2-HTTPS是身披SSL外壳的HTTP"><a href="#7-2-2-HTTPS是身披SSL外壳的HTTP" class="headerlink" title="7.2.2 HTTPS是身披SSL外壳的HTTP"></a>7.2.2 HTTPS是身披SSL外壳的HTTP</h4><p>HTTPS并不是全新的协议，只是HTTP通信接口部分用SSL和TLS协议代替</p>
<p>通常HTTP直接和TCP通信，使用SSL时，先和SSL通信，再由SSL和TCP通信</p>
<p>SSL是独立于HTTP的协议，不光HTTP，其他应用层协议也可配合SSL使用</p>
<h4 id="7-2-3-相互交换密钥的公开密钥交换技术"><a href="#7-2-3-相互交换密钥的公开密钥交换技术" class="headerlink" title="7.2.3 相互交换密钥的公开密钥交换技术"></a>7.2.3 相互交换密钥的公开密钥交换技术</h4><p><strong>共享加密密钥的困境</strong></p>
<p>加密和解密公用一个密钥的方式称为共享密钥加密（对称密钥加密）</p>
<p>但发送密钥有被窃听的风险，不发送通信方就无法解密，而且若密钥能安全发送，直接发送数据也能安全到达</p>
<p><strong>使用两种密钥的公开密钥加密</strong></p>
<p>公开密钥加密使用非对称的密钥。一把叫私钥，一把叫公钥。私钥不能让其他任何人知道，公钥可以发送给任何人</p>
<p>发送数据一方使用对方的公钥对数据进行加密，对方收到加密后的数据后使用私钥解密</p>
<p>只有公钥对密文还原是非常困难的</p>
<p><strong>HTTPS使用混合加密机制</strong></p>
<p>HTTPS使用共享密钥加密和公开密钥加密两者并用的混合加密机制。但公开密钥加密比共享密钥加密速度慢</p>
<p>因此充分利用二者优势，在交换密钥环节使用公开密钥加密，之后建立通信交换报文阶段使用共享密钥加密方式</p>
<p>即用公开密钥加密之后会在共享密钥加密过程中使用的密钥。</p>
<h4 id="7-2-4-证明公开密钥正确的证书"><a href="#7-2-4-证明公开密钥正确的证书" class="headerlink" title="7.2.4 证明公开密钥正确的证书"></a>7.2.4 证明公开密钥正确的证书</h4><p>公开密钥加密还是存在一些问题的，那就是无法证明公钥本身是否货真价实</p>
<p>为解决这个问题，可以由数字证书认证机构和其相关机关颁布的公开密钥证书</p>
<p>数字证书认证机构会将服务器运营人员发来的公开密钥添加进入数字证书并标记上数字签名，服务器取得了数字证书后将其发给客户端，客户端可使用数字证书机构的公开密钥对证书上的数字签名进行验证。一旦验证通过，客户端即可确定：1.认证服务器的公开密钥的是真实有效的数字机构 2.服务器的公开密钥值得信赖</p>
<p>认证机构的公共密钥也必须安全的转交给客户端，因此多数浏览器开发商都会事先在浏览器内部植入常用认证机关的公钥</p>
<p><strong>EV SSL证书</strong></p>
<p>此证书可以确认服务器背后运营的企业真实存在</p>
<p>持有该证书的网站的浏览器地址栏处的背景颜色是绿色的</p>
<p>愿意图是防止用户被钓鱼攻击，但实际效果不佳，因为大部分用户不了解该证书相关知识，并不会注意</p>
<p><strong>客户端证书</strong></p>
<p>客户端也可以申请客户端证书，发挥服务器证书相同的作用</p>
<p>但每申请一张证书都要相应的费用，安装证书也需要用户自身的知识水平，客户端证书只在少数情况下使用</p>
<p>如银行的网上银行采用客户端证书，登录网银时不仅要确认id和密码，还需要客户端证书来确认是否从特定终端上访问</p>
<p>客户端证书只能证明客户端实际存在，却无法证明客户端用户身份，若用户控制了计算机的使用权，也就拥有了客户端证书的使用权</p>
<p><strong>自签名证书</strong></p>
<p>由个体自己给自己的服务器颁布的证书称为自签名证书。独立构建的认证机构被称为自认证机构。自签名证书在互联网上无法被当作证书使用</p>
<p>当访问使用自签名证书的网站时，会提示”该网站的证书存在问题“等提示</p>
<h4 id="7-2-5-HTTPS的安全通信机制"><a href="#7-2-5-HTTPS的安全通信机制" class="headerlink" title="7.2.5 HTTPS的安全通信机制"></a>7.2.5 HTTPS的安全通信机制</h4><p>以TLS握手为例</p>
<ul>
<li>客户端发送clienthello消息，包含TLS版本，加密算法集，随机数</li>
<li>服务器端接收消息后发送serverHello消息，包含TLS版本，加密算法集，随机数</li>
<li>服务器端发送包含公钥的证书</li>
<li>服务器端发送serverHelloDone消息</li>
<li>客户端接收服务器端消息后验证证书机构是否权威和服务器是否为值得信赖的服务器，获取公钥</li>
<li>客户端发送由公钥加密的premaster secret</li>
<li>服务器端用私钥解密premaster secret</li>
<li>客户端和服务端使用之前生成的两个随机数＋premaster secret生成master secret用于对之后通信的所有数据加密</li>
<li>客户端发送ChangeCipherSpec消息和用master secret加密的finish消息</li>
<li>服务器端接收并验证，发送ChangeCipherSpec消息和用master secret加密的finish消息</li>
<li>客户端接收并认证，握手结束</li>
</ul>
<hr>
<h2 id="第八章-确认访问用户身份的认证"><a href="#第八章-确认访问用户身份的认证" class="headerlink" title="第八章 确认访问用户身份的认证"></a>第八章 确认访问用户身份的认证</h2><h3 id="8-1-何为认证"><a href="#8-1-何为认证" class="headerlink" title="8.1 何为认证"></a>8.1 何为认证</h3><p>认证用于核实客户端使用者的身份</p>
<p>HTTP&#x2F;1.1的认证方式如下</p>
<ul>
<li><p>BASIC认证（基本认证）</p>
</li>
<li><p>DIGEST认证（摘要认证）</p>
</li>
<li><p>SSL客户端认证</p>
</li>
<li><p>FormBase认证（基于表单认证）</p>
</li>
</ul>
<h3 id="8-2-BASIC认证"><a href="#8-2-BASIC认证" class="headerlink" title="8.2 BASIC认证"></a>8.2 BASIC认证</h3><ul>
<li>用户发送请求后，服务器返回401状态码，返回带WWW-Authenticate首部字段的响应，字段内含有认证方式和Request-URI安全域字符串（realm）</li>
<li>接到401状态码的客户端为了通过认证需要将用户id和密码发送给服务器，发送内容由“ID：密码”组成，经Base64编码处理后写入Authorization字段发送。若用户代理为浏览器，输入ID和密码即可，浏览器自动进行Base64编码</li>
<li>接到含首部字段Authorization请求的服务器对其进行验证，若通过则返回包含Request-URI资源的响应</li>
</ul>
<p>BASIC认证的Base编码并不是加密，可以直接解码为明文，因此在非加密通信的链路上进行认证时有可能被窃听</p>
<p>一般的浏览器无法实现认证注销</p>
<h3 id="8-3-DIGEST认证"><a href="#8-3-DIGEST认证" class="headerlink" title="8.3 DIGEST认证"></a>8.3 DIGEST认证</h3><p>DIGEST认证不会像BASIC认证那样直接发送明文密码</p>
<p>但同样安全系数有限，不被常用</p>
<h3 id="8-4-SSL客户端认证"><a href="#8-4-SSL客户端认证" class="headerlink" title="8.4 SSL客户端认证"></a>8.4 SSL客户端认证</h3><p>服务器端发送报文要求客户端发送客户端证书内容，客户端发送含公钥的客户端证书，服务器端收到证书后开启HTTPS连接</p>
<p><strong>双因素认证</strong></p>
<p>通过客户端认证确认终端，通过表单认证确认是用户本人操作，这种认证方式称为双因素认证</p>
<h3 id="8-5-基于表单认证"><a href="#8-5-基于表单认证" class="headerlink" title="8.5 基于表单认证"></a>8.5 基于表单认证</h3><p>并不是在HTTP中定义。客户端会向服务器的web应用发送登录信息，按登录信息的验证结果进行认证</p>
<p>现实中大多为基于表单的认证</p>
<p><strong>session管理和cookie应用</strong></p>
<p>客户端向服务器发送账号密码，服务器端验证后返回包含session-id的cookie，客户端再次登录时直接发送含session的cookie，服务器通过验证session信息验证是否为以登录的用户</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Welcome to my BLOG!</title>
    <url>/2022/08/03/hello-world/</url>
    <content><![CDATA[<p>欢迎来到我的博客</p>
]]></content>
      <categories>
        <category>欢迎</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器的工作原理</title>
    <url>/2022/08/03/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%88%E7%AE%80%E6%98%93%E7%89%88%EF%BC%89/</url>
    <content><![CDATA[<h3 id="浏览器的工作原理（简易版）"><a href="#浏览器的工作原理（简易版）" class="headerlink" title="浏览器的工作原理（简易版）"></a>浏览器的工作原理（简易版）</h3><p>输入url后</p>
<ol>
<li><p>浏览器进行dns查找，把域名转换为ip地址，根据ip地址找到对应的服务器</p>
</li>
<li><p>浏览器通过TCP握手机制跟服务器建立连接，如果为https还有一步TLS握手</p>
</li>
<li><p>浏览器发起http&#x2F;https请求，获取响应。在浏览器接收响应时，受制于TCP连接的性质，浏览器先收到前14kb的数据，后续才会慢慢增加传输速度下载其他文件</p>
</li>
<li><p>收到html代码后，浏览器开始渲染网页</p>
<ol>
<li><p>解析html代码，构建DOM树（HTML文档在浏览器中的对象表示）</p>
<p>浏览器在解析HTML时顺序执行并且只有一个主线程负责，遇到script标签会先执行js代码，暂停解析html代码。对于图片，css文件，设置了defer&#x2F;async的script标签不会影响html解析，会异步加载</p>
<p>浏览器具有预扫描线程，扫描html代码，提前把css文件，字体，js文件下载下来，不影响主线程</p>
<p><img src="/image/image1.png" alt="dom树"></p>
</li>
<li><p>构建CSSOM树</p>
<p><img src="/image/image2.png" alt="CSSOM树"></p>
</li>
<li><p>合并DOM和CSSOM，形成渲染树</p>
<p><img src="/image/image3.png" alt="渲染树"></p>
</li>
<li><p>布局</p>
<p>对于图片这样的结点，如果没有指定宽高，会先忽略大小。图片下载完成后，浏览器根据图片的大小重新计算受影响的结点的宽高，这种方法被称为回流（reflow）</p>
</li>
<li><p>绘制</p>
<p>第一次布局之后，浏览器会把结点和结点的样式绘制在屏幕上，要求过程快速</p>
<p>如果布局发生回流，浏览器会发生重绘，把变化的布局重新绘制在屏幕上</p>
<p>绘制期间可能会有组合发生（产生了新的图层）,浏览器需要把图层组合起来，按正确的图层顺序渲染，发生了重绘也会导致重新组合</p>
<p>上述五步完成后，设置了defer&#x2F;async的script中的内容，网页加载完成</p>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
</search>
