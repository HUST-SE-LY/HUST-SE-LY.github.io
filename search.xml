<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>css中的float</title>
    <url>/2022/08/04/CSS%E6%B5%AE%E5%8A%A8/</url>
    <content><![CDATA[<h1 id="CSS浮动"><a href="#CSS浮动" class="headerlink" title="CSS浮动"></a>CSS浮动</h1><h3 id="浮动规则"><a href="#浮动规则" class="headerlink" title="浮动规则"></a>浮动规则</h3><p>1.浮动元素不会超过容纳块的边界</p>
<p>2.排队浮动</p>
<p>3.浮动元素间不会重叠</p>
<p>4.浮动元素的顶边不能比父级元素的内顶边高</p>
<p>5.浮动元素的顶边不能比之前任何一个浮动元素或块元素的顶边高</p>
<p>6.浮动元素顶边不能高于源码中出现浮动元素之前的元素生成的框体所在行框的顶边</p>
<p>7.浮动元素必须放在尽可能高的位置</p>
<p>8.左浮动元素尽量向左移动，右浮动元素尽量向右移动</p>
<p>浮动元素的后代也会浮动</p>
<h3 id="浮动元素与内容重叠"><a href="#浮动元素与内容重叠" class="headerlink" title="浮动元素与内容重叠"></a>浮动元素与内容重叠</h3><p>与行内元素重叠时：行内元素边框背景内容都会在浮动元素”之上“渲染</p>
<p>与块元素重叠时：边框和背景在浮动元素”背后“渲染，内容在”之上“渲染</p>
<p>重叠方式与元素出现顺序无关</p>
<h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><p>禁止每个区域的第一个元素出现在浮动元素旁</p>
<p>如：禁止元素出现在左浮动元素的右侧：<code>clear：left</code></p>
<p>确保某个元素不与任何浮动元素共处一行：<code>clear both</code></p>
<p>实现方式：<strong>间距</strong></p>
<p><strong>间距</strong>：为了把元素向下移动，确保显示在浮动元素下方而在元素上外边距<strong>上方额外增加的空白</strong>，不影响上外边距</p>
<p>为确保清除浮动了的元素与浮动元素间的边距，可以为浮动元素设置下外边距</p>
<h3 id="形状浮动"><a href="#形状浮动" class="headerlink" title="形状浮动"></a>形状浮动</h3><p>可以让文字按照浮动<strong>透明</strong>图片的轮廓填充在旁边</p>
<p>先为浮动图片定义一个形状：</p>
<p><code>shape-outside:url(&quot;绝对路径&quot;);</code></p>
<p>若图片向左浮动则会填充在右边，若为向右浮动则填充左边</p>
<p><strong>必须是透明图片！！！！</strong></p>
<p>shape-outside还可以直接使用设置其他形状,分为basic-shape和shape-box两类</p>
<p>basic-shape:</p>
<p><code>inset() circle() ellipse() polygon()</code></p>
<p>shape-box:</p>
<p><code>margin-box border-box padding-box content-box</code>指形状最外边的界限</p>
<p>默认使用外边距框</p>
<p>如果设置的形状超过了浮动框，则不会按形状填充而是按浮动框进行填充</p>
<p>可以使用shape-margin为形状设置”外边距“</p>
<p>但设置时要注意设置之后有没有超过浮动框，有时候浮动框要设置的更大才能体现出效果</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>浮动是css的基础，虽然简单，但十分强大和有用。浮动不可或缺，有了浮动才能把内容放在某一边，让其他内容围绕它流动。引入浮动形状后，浮动框不再局限为方形</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>自学Vue第一章笔记</title>
    <url>/2022/08/03/VUE-chapter3/</url>
    <content><![CDATA[<h1 id="VUE"><a href="#VUE" class="headerlink" title="VUE"></a>VUE</h1><p>创建Vue应用:<code>Vue.createApp().mount(&quot;&quot;)</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app=<span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">        <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">name</span>:<span class="string">&quot;世界&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="使用data-绑定html元素"><a href="#使用data-绑定html元素" class="headerlink" title="使用data()绑定html元素"></a>使用data()绑定html元素</h4><ul>
<li>要渲染的元素用<code>&#123;&#123;&#125;&#125;</code>括起来，如<code>&#123;&#123;name&#125;&#125;</code></li>
<li>data是一个函数，返回一个类，类中声明需要渲染的元素和对应的值，如上述代码</li>
</ul>
<h4 id="使用v-bind绑定属性元素"><a href="#使用v-bind绑定属性元素" class="headerlink" title="使用v-bind绑定属性元素"></a>使用v-bind绑定属性元素</h4><p>对于html标签中的属性，不能通过直接用<code>&#123;&#123;&#125;&#125;</code>绑定，这时候需要使用v-bind</p>
<p>在html中使用v-bind</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;link&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>也可以省略v-bind只保留：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">&quot;link&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后在data中添加</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app=<span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">        <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">link</span>:<span class="string">&quot;https://website.com&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="使用v-for绑定列表元素"><a href="#使用v-for绑定列表元素" class="headerlink" title="使用v-for绑定列表元素"></a>使用v-for绑定列表元素</h4><p>对于多个列表元素可以用数组控制</p>
<p>在JavaScript中添加</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app=<span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">        <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">todos</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                  	<span class="attr">content</span>:<span class="string">&quot;goal1&quot;</span>,</span><br><span class="line">                    <span class="attr">complete</span>:<span class="literal">true</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                  	<span class="attr">content</span>:<span class="string">&quot;goal2&quot;</span>,</span><br><span class="line">                    <span class="attr">complete</span>:<span class="literal">true</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                  	<span class="attr">content</span>:<span class="string">&quot;goal3&quot;</span>,</span><br><span class="line">                    <span class="attr">complete</span>:<span class="literal">false</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">                </span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>使用v-for遍历数组只需要在html中加入一行li</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(todo,index) in todos&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">:checked</span>=<span class="string">&quot;todo.complete&quot;</span>&gt;</span>&#123;&#123;index+1&#125;&#125;:&#123;&#123;todo.content&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>v-for采用类似js中for-in的遍历方式，（）中第一个值是访问的数组元素，第二个是数组元素对应下标</p>
<p>采用js访问对象属性相同的方法访问数组中对象元素中的属性</p>
<h4 id="v-if和v-show"><a href="#v-if和v-show" class="headerlink" title="v-if和v-show"></a>v-if和v-show</h4><p>v-if可以通过js判断语句返回的值条件渲染html，使用<code>v-if,v-else-if,v-else</code>是要紧挨着</p>
<p>v-show则通过给元素设置display：none来实现显示与否</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app=<span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">        <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">books</span>:[<span class="string">&quot;js权威指南&quot;</span>,<span class="string">&quot;css权威指南&quot;</span>,<span class="string">&quot;js高级编程&quot;</span>],</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-show</span>=<span class="string">&quot;books.length===0&quot;</span>&gt;</span>没有图书<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">v-show</span>=<span class="string">&quot;books.length&gt;0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;book in books&quot;</span>&gt;</span>&#123;&#123;book&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="使用-注册事件"><a href="#使用-注册事件" class="headerlink" title="使用@注册事件"></a>使用@注册事件</h4><p>在html中使用@来注册事件及其响应</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;showAnswer=!showAnswer&quot;</span>&gt;</span>&#123;&#123;showAnswer?&quot;隐藏答案&quot;:&quot;显示答案&quot;&#125;&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="使用computed计算方法"><a href="#使用computed计算方法" class="headerlink" title="使用computed计算方法"></a>使用computed计算方法</h4><p>使用computed计算方法把一些需要重复执行的内容写入函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app=<span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;val=<span class="literal">false</span>&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">computed</span>:&#123;</span><br><span class="line">        <span class="title function_">label</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">val</span>=!<span class="variable language_">this</span>.<span class="property">val</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">val</span>?<span class="string">&quot;1&quot;</span>:<span class="string">&quot;2&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&quot;#div&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在html加入计算函数</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">app</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        &#123;&#123;label&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="使用methods方法"><a href="#使用methods方法" class="headerlink" title="使用methods方法"></a>使用methods方法</h4><p>使用methods方法处理事件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app=<span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">judgement</span>:<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>:&#123;</span><br><span class="line">        <span class="title function_">change</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">judgement</span>=!<span class="variable language_">this</span>.<span class="property">judgement</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>html中使用</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;change&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123;judgement&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="使用watch注册监听器"><a href="#使用watch注册监听器" class="headerlink" title="使用watch注册监听器"></a>使用watch注册监听器</h4><p>使用watch可以监听变量值的变化</p>
<p>watch中的函数名必须为需要监听的变量名,它有两个参数，分别是新值和旧值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app=<span class="title class_">Vue</span>.<span class="title function_">ccreateApp</span>(&#123;</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">judgement</span>:<span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>:&#123;</span><br><span class="line">        <span class="title function_">change</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">judgement</span>=!<span class="variable language_">this</span>.<span class="property">judgement</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attr">watch</span>:&#123;</span><br><span class="line">        <span class="title function_">judgement</span>(<span class="params">newVal,oldVal</span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(newVal)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;change&quot;</span>&gt;</span>judgement<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>点击按钮时会控制台输出改变后的值</p>
<h4 id="computed和methods的区别"><a href="#computed和methods的区别" class="headerlink" title="computed和methods的区别"></a>computed和methods的区别</h4><ul>
<li>计算属性缓存结果，多次使用计算属性或组件刷新时，如果计算属性使用的data属性无变化，computed会直接从缓存中读取</li>
<li>methods不缓存结果，任何属性变化都会导致methods重新执行，执行大量运算时比较慢。方法也可以作为普通的js函数被computed调用</li>
</ul>
<h4 id="computed-和-watch的区别"><a href="#computed-和-watch的区别" class="headerlink" title="computed 和 watch的区别"></a>computed 和 watch的区别</h4><ul>
<li>computed一般不直接修改data中属性，而是经过计算返回一个新值，使用时能像data中属性一样使用，data中的属性被修改后，计算属性也立即更新</li>
<li>watch监听到属性变化时直接修改data中数据值，不会返回计算结果，不能直接使用，需要在data中额外维护一个属性供watch使用</li>
</ul>
<p><img src="/image/img.png" alt="computed和watch的区别"></p>
<h4 id="methods和watch的区别"><a href="#methods和watch的区别" class="headerlink" title="methods和watch的区别"></a>methods和watch的区别</h4><ul>
<li>methods定义的方法可以在watch中调用，适合做一些更复杂的计算</li>
</ul>
<h4 id="使用事件监听处理表单输入数据"><a href="#使用事件监听处理表单输入数据" class="headerlink" title="使用事件监听处理表单输入数据"></a>使用事件监听处理表单输入数据</h4><p>使用methods方法定义事件处理函数，@input监听事件</p>
<h4 id="使用双向绑定，v-model处理表单输入数据"><a href="#使用双向绑定，v-model处理表单输入数据" class="headerlink" title="使用双向绑定，v-model处理表单输入数据"></a>使用双向绑定，v-model处理表单输入数据</h4><p><img src="/image/img_1.png" alt="双向绑定是什么"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app=<span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">        <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">username</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">methods</span>: &#123;</span><br><span class="line">            <span class="title function_">calculate</span>(<span class="params">e</span>) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">username</span>=e.<span class="property">target</span>.<span class="property">value</span>;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="title function_">clear</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">username</span>=<span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>html部分：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;username&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;calculate&quot;</span>&gt;</span>&#123;&#123;username&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;clear&quot;</span>&gt;</span>清空<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="其他表单控件的处理"><a href="#其他表单控件的处理" class="headerlink" title="其他表单控件的处理"></a>其他表单控件的处理</h4><p>其他表单控件的双向绑定绑定的为其value值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app=<span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">       <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> &#123;</span><br><span class="line">               <span class="attr">username</span>:<span class="string">&quot;&quot;</span>,</span><br><span class="line">               <span class="attr">gender</span>:<span class="string">&quot;&quot;</span>,</span><br><span class="line">               <span class="attr">checkbox</span>:[],</span><br><span class="line">               <span class="attr">introduction</span>:<span class="string">&quot;&quot;</span></span><br><span class="line">           &#125;;</span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="attr">methods</span>: &#123;</span><br><span class="line">           <span class="title function_">clear</span>(<span class="params"></span>) &#123;</span><br><span class="line">               <span class="variable language_">this</span>.<span class="property">username</span>=<span class="string">&quot;&quot;</span>;</span><br><span class="line">               <span class="variable language_">this</span>.<span class="property">gender</span>=<span class="string">&quot;&quot;</span>;</span><br><span class="line">               <span class="variable language_">this</span>.<span class="property">checkbox</span>=[];</span><br><span class="line">               <span class="variable language_">this</span>.<span class="property">introduction</span>=<span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">   app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;username&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;姓名&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;clear&quot;</span>&gt;</span>清除<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;male&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;gender&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>男<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;female&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;gender&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>女<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;interest&quot;</span> <span class="attr">value</span>=<span class="string">&quot;answer1&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>选项一<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;interest&quot;</span> <span class="attr">value</span>=<span class="string">&quot;answer2&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>选项二<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;interest&quot;</span> <span class="attr">value</span>=<span class="string">&quot;answer3&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>选项三<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">rows</span>=<span class="string">&quot;10&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;introduction&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;自我介绍&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;username&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;gender&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;checkbox&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;introduction&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="表单事件提交处理和事件修饰符"><a href="#表单事件提交处理和事件修饰符" class="headerlink" title="表单事件提交处理和事件修饰符"></a>表单事件提交处理和事件修饰符</h4><p>表单事件处理函数使用@submit绑定，使用.绑定事件修饰符，如<code>@submit.prevent</code>绑定禁止默认行为（e.preventDefault）</p>
<h4 id="根据条件控制class"><a href="#根据条件控制class" class="headerlink" title="根据条件控制class"></a>根据条件控制class</h4><p>使用v-bind:绑定class属性，在data中定义要使用的样式，使用数组设置多个class，使用对象形式完成根据条件修改样式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app=<span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">        <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">blue</span>: <span class="string">&quot;blue&quot;</span>,</span><br><span class="line">                <span class="attr">red</span>: <span class="string">&quot;red&quot;</span>,</span><br><span class="line">                <span class="attr">isHidden</span>:<span class="literal">false</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">methods</span>: &#123;</span><br><span class="line">            <span class="title function_">clear</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">isHidden</span>=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">:class</span>=<span class="string">&quot;[blue,red,&#123;hide: isHidden&#125;]&quot;</span>&gt;</span>A paragraph<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;clear&quot;</span>&gt;</span>清除<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP知识点总结</title>
    <url>/2022/08/03/HTTP/</url>
    <content><![CDATA[<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><hr>
<h2 id="第一章：了解web及网络基础"><a href="#第一章：了解web及网络基础" class="headerlink" title="第一章：了解web及网络基础"></a>第一章：了解web及网络基础</h2><h3 id="1-1-TCP-x2F-IP"><a href="#1-1-TCP-x2F-IP" class="headerlink" title="1.1 TCP&#x2F;IP"></a>1.1 TCP&#x2F;IP</h3><p>不同硬件，操作系统之间的通信都需要规则，这种规则成为<strong>协议</strong>。</p>
<p>把与互联网相关联的协议集合称为TCP&#x2F;IP</p>
<h3 id="1-2-TCP-x2F-IP分层管理"><a href="#1-2-TCP-x2F-IP分层管理" class="headerlink" title="1.2 TCP&#x2F;IP分层管理"></a>1.2 TCP&#x2F;IP分层管理</h3><p>TCP&#x2F;IP协议族分为四层：</p>
<ul>
<li>应用层：决定了向用户提供应用服务时通信的活动，如FTP,DNS,HTTP</li>
<li>传输层：提供处于网络连接中的两台计算机之间的数据传输，如TCP,UDP</li>
<li>网络层：用来处理在网络上流动的数据包</li>
<li>链路层：处理连接网络的硬件部分</li>
</ul>
<h3 id="1-3-IP-TCP-DNS"><a href="#1-3-IP-TCP-DNS" class="headerlink" title="1.3 IP,TCP,DNS"></a>1.3 IP,TCP,DNS</h3><h4 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h4><p>IP网络协议位于网络层，作用是把各种数据包传给对方。要想确保传输需要满足各种条件，最重要的是IP地址和MAC地址</p>
<p>IP地址是节点被分配的地址，MAC地址是网卡的固定地址，IP地址可变换，MAC地址一般不可变换</p>
<h5 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h5><p>IP间的通信依赖MAC地址，数据在网络上的传递需要经过多个中转站，通过MAC来搜索中转站，ARP协议可以通过IP地址反查出MAC地址</p>
<p>没有设备能够全面掌握数据的传输情况</p>
<h4 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h4><p>位于传输层，提供可靠的字节流服务</p>
<h5 id="确保数据能到达目标"><a href="#确保数据能到达目标" class="headerlink" title="确保数据能到达目标"></a>确保数据能到达目标</h5><p>采用三次握手策略。</p>
<p>握手过程中使用了TCP的标志：SYN和ACK</p>
<p>发送端发送带有SYN标志的数据包给对方，接收端返回带有SYN&#x2F;ACK标志的数据包以示传达确认信息，最后发送端回传带有ACK标志的数据包代表握手结束</p>
<p>若握手在某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包</p>
<h4 id="DNS服务"><a href="#DNS服务" class="headerlink" title="DNS服务"></a>DNS服务</h4><p>位于应用层，提供域名到IP的解析服务</p>
<h3 id="1-4-HTTP与其他协议的关系"><a href="#1-4-HTTP与其他协议的关系" class="headerlink" title="1.4 HTTP与其他协议的关系"></a>1.4 HTTP与其他协议的关系</h3><p>HTTP生成报文-&gt;TCP将报文分割处理-&gt;IP将报文段传输-&gt;TCP将报文段重组-&gt;HTTP对接受到的报文进行处理再回传</p>
<h3 id="1-5-URL和URI"><a href="#1-5-URL和URI" class="headerlink" title="1.5 URL和URI"></a>1.5 URL和URI</h3><p>URI用字符串标识某一互联网资源，URL表示资源的地点，URL是URI的子集</p>
<hr>
<h2 id="第二章：简单的HTTP协议"><a href="#第二章：简单的HTTP协议" class="headerlink" title="第二章：简单的HTTP协议"></a>第二章：简单的HTTP协议</h2><h3 id="2-1-HTTP协议用于客户端和服务器端之间的通信"><a href="#2-1-HTTP协议用于客户端和服务器端之间的通信" class="headerlink" title="2.1 HTTP协议用于客户端和服务器端之间的通信"></a>2.1 HTTP协议用于客户端和服务器端之间的通信</h3><p>请求访问文本等资源的一端成为客户端，提供资源做出响应的一端称为服务器端</p>
<h3 id="2-2-通过请求和响应的交换达成协议"><a href="#2-2-通过请求和响应的交换达成协议" class="headerlink" title="2.2 通过请求和响应的交换达成协议"></a>2.2 通过请求和响应的交换达成协议</h3><p>服务器在没有接收到请求时是不会响应的</p>
<p>一段请求报文：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/index.htm</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>hacker.jp</span><br></pre></td></tr></table></figure>

<ul>
<li>GET表示请求服务的类型，称为<strong>方法</strong></li>
<li><code>/index.htm</code>表示了请求访问的资源对象，也叫请求URI</li>
<li><code>HTTP/1.1</code>表示HTTP的版本号</li>
</ul>
<p>请求报文是由请求方法，请求URI，协议版本，可选的请求首部字段和内容实体构成的</p>
<p>请求首部字段和内容实体之后介绍</p>
<p>一段响应报文：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>TUe, 10 Jul 2012 6:50:15 GMT</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>362</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html</span><br><span class="line"></span><br><span class="line"><span class="language-lasso">&lt;html&gt;</span></span><br><span class="line"><span class="language-lasso"><span class="params">...</span><span class="params">...</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>HTTP/1.1</code>表示服务器对应的HTTP版本</p>
</li>
<li><p><code>200 OK</code>表示状态码和原因短语</p>
</li>
<li><p><code>Date Content</code>为首部字段内的属性</p>
</li>
<li><p>以一空行分隔，之后的内容为资源实体的主体</p>
</li>
</ul>
<p>响应报文由协议版本，状态码，解释状态码的原因短语，可选的响应首部字段以及实体主体构成</p>
<h3 id="2-3-HTTP是不保存状态的协议"><a href="#2-3-HTTP是不保存状态的协议" class="headerlink" title="2.3 HTTP是不保存状态的协议"></a>2.3 HTTP是不保存状态的协议</h3><p>HTTP协议自身不具备保存之前发送过的请求或响应的功能</p>
<p>为了实现保存状态，引入了Cookie技术</p>
<h3 id="2-4-请求URI定位资源"><a href="#2-4-请求URI定位资源" class="headerlink" title="2.4 请求URI定位资源"></a>2.4 请求URI定位资源</h3><p>HTTP协议使用URI定位互联网上的资源</p>
<p>指定请求URI的方式很多</p>
<p>如果不是访问资源而是对服务器本身发送请求，URI可以使用*代替</p>
<h3 id="2-5告知服务器意图的HTTP方法"><a href="#2-5告知服务器意图的HTTP方法" class="headerlink" title="2.5告知服务器意图的HTTP方法"></a>2.5告知服务器意图的HTTP方法</h3><h4 id="GET-获取资源"><a href="#GET-获取资源" class="headerlink" title="GET:获取资源"></a>GET:获取资源</h4><p>GET方法用来请求已被URI识别的资源</p>
<h4 id="POST：传输实体主体"><a href="#POST：传输实体主体" class="headerlink" title="POST：传输实体主体"></a>POST：传输实体主体</h4><p>POST方法用来传输实体的主体，虽说GET也能传输，但一般不用GET，POST的主要目的并不是获取响应的主体内容</p>
<h4 id="PUT：传输文件"><a href="#PUT：传输文件" class="headerlink" title="PUT：传输文件"></a>PUT：传输文件</h4><p>PUT方法用来传输文件。在报文的主体中包含文件内容，保存到请求URI的指定位置</p>
<p>由于不存在验证机制，任何人都可以上传，存在安全性问题，一般网站不使用PUT</p>
<h4 id="HEAD：获取报文首部"><a href="#HEAD：获取报文首部" class="headerlink" title="HEAD：获取报文首部"></a>HEAD：获取报文首部</h4><p>HEAD与GET一样，只是不返回报文的主体部分，用于确认URI的有效性以及资源更新的日期时间等</p>
<h4 id="DELETE-删除文件"><a href="#DELETE-删除文件" class="headerlink" title="DELETE:删除文件"></a>DELETE:删除文件</h4><p>与PUT相反的方法，一般不用</p>
<h4 id="OPTIONS：查询支持的方法"><a href="#OPTIONS：查询支持的方法" class="headerlink" title="OPTIONS：查询支持的方法"></a>OPTIONS：查询支持的方法</h4><p>查询针对URI指定的资源支持的方法</p>
<h4 id="TRACE：追踪路径"><a href="#TRACE：追踪路径" class="headerlink" title="TRACE：追踪路径"></a>TRACE：追踪路径</h4><p>不常用且可能引发XST攻击，通常不会用到</p>
<h4 id="CONNECT：要求用隧道协议连接代理"><a href="#CONNECT：要求用隧道协议连接代理" class="headerlink" title="CONNECT：要求用隧道协议连接代理"></a>CONNECT：要求用隧道协议连接代理</h4><p>主要使用SSL和TLS协议把通信加密后经网络隧道传输</p>
<h3 id="2-6-持久连接"><a href="#2-6-持久连接" class="headerlink" title="2.6 持久连接"></a>2.6 持久连接</h3><p>即在建立TCP连接后，如果一端没有明确要求断开链接，则保持TCP连接状态</p>
<h3 id="2-7-管线化"><a href="#2-7-管线化" class="headerlink" title="2.7 管线化"></a>2.7 管线化</h3><p>从前发送请求需要收到响应才能发送下一个请求，通过管线化技术不用等待即可发送下一个请求</p>
<h3 id="2-8-使用Cookie的状态管理"><a href="#2-8-使用Cookie的状态管理" class="headerlink" title="2.8 使用Cookie的状态管理"></a>2.8 使用Cookie的状态管理</h3><p>Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端状态</p>
<p>如果请求中没有cookie，则会在响应报文中添加cookie</p>
<p>如果请求中有cookie，服务器端会检查cookie识别状态做出响应</p>
<hr>
<h2 id="第三章：HTTP报文内的HTTP信息"><a href="#第三章：HTTP报文内的HTTP信息" class="headerlink" title="第三章：HTTP报文内的HTTP信息"></a>第三章：HTTP报文内的HTTP信息</h2><h3 id="3-1-HTTP报文"><a href="#3-1-HTTP报文" class="headerlink" title="3.1 HTTP报文"></a>3.1 HTTP报文</h3><p>用于HTTP协议交互的信息叫做HTTP报文，请求端的HTTP报文叫请求报文，相应端的叫响应报文</p>
<p>HTTP报文大致可分为报文首部和报文主体两部分，由空行划分，通常并不一定有报文主体</p>
<h3 id="3-2-请求报文和响应报文的结构"><a href="#3-2-请求报文和响应报文的结构" class="headerlink" title="3.2 请求报文和响应报文的结构"></a>3.2 请求报文和响应报文的结构</h3><ul>
<li>报文首部<ul>
<li>请求行：包含用于请求的方法，请求URI和HTTP版本</li>
<li>状态行：包含表明响应结果的状态码，原因短语和HTTP版本</li>
<li>首部字段：包含表示请求和响应的各种条件和属性的各类首部<ul>
<li>通用首部</li>
<li>请求首部</li>
<li>响应首部</li>
<li>实体首部</li>
</ul>
</li>
<li>其他（HTTP的RFC未规定的首部，如Cookie）</li>
</ul>
</li>
<li>空行</li>
<li>报文主体</li>
</ul>
<h3 id="3-3-编码提升传输速率"><a href="#3-3-编码提升传输速率" class="headerlink" title="3.3 编码提升传输速率"></a>3.3 编码提升传输速率</h3><h4 id="报文主体和实体主体"><a href="#报文主体和实体主体" class="headerlink" title="报文主体和实体主体"></a>报文主体和实体主体</h4><p>一般来说报文主体等于实体主体，当编码后实体主体发生变化，与报文主体不同</p>
<h4 id="压缩传输的内容编码"><a href="#压缩传输的内容编码" class="headerlink" title="压缩传输的内容编码"></a>压缩传输的内容编码</h4><p>内容编码指明应用在实体内容上的编码格式，并保持实体信息原样进行压缩，编码后的实体主体由客户端接收并负责解码</p>
<h4 id="分割发送的分块传输编码"><a href="#分割发送的分块传输编码" class="headerlink" title="分割发送的分块传输编码"></a>分割发送的分块传输编码</h4><p>把数据分割成多块，能够让浏览器逐步显示页面</p>
<p>这种把实体主体分块的功能称为分块传输编码，由客户端负责解码</p>
<h3 id="3-4-发送多种数据的多部分对象集合"><a href="#3-4-发送多种数据的多部分对象集合" class="headerlink" title="3.4 发送多种数据的多部分对象集合"></a>3.4 发送多种数据的多部分对象集合</h3><p>HTTP协议采用了多部分对象集合，发送的一份报文主体内可能含有多种类型的实体</p>
<p>多部分对象集合包含的对象如下：</p>
<ul>
<li><p><code>multipart/form-data</code>：在web表单文件上传时使用</p>
</li>
<li><p><code>multipart/byteranges</code>：在状态码206响应报文包含了多个范围的内容时使用</p>
</li>
</ul>
<p>详见p48</p>
<h3 id="3-5-获取部分内容的范围请求"><a href="#3-5-获取部分内容的范围请求" class="headerlink" title="3.5 获取部分内容的范围请求"></a>3.5 获取部分内容的范围请求</h3><p>为指定范围发送的请求称为范围请求</p>
<p>针对范围请求，响应会返回状态码为<code>206 Partial Content</code>的响应报文。对于多重范围的范围请求，响应会在首部字段Content-Type标明multipart&#x2F;byteranges后返回响应报文</p>
<p>如果服务器端无法响应范围请求，则会返回状态码200 OK和完整的实体内容</p>
<h3 id="3-6-内容协商返回最合适的内容"><a href="#3-6-内容协商返回最合适的内容" class="headerlink" title="3.6 内容协商返回最合适的内容"></a>3.6 内容协商返回最合适的内容</h3><p>内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，最终提供给客户端最合适的资源。内容协商会以语言，字符集，编码方式等作为基准判断响应的资源</p>
<p>包含在请求报文中的某些首部字段就是判断标准</p>
<ul>
<li><code>Accept</code></li>
<li><code>Accept-Charset</code></li>
<li><code>Accept-Encoding</code></li>
<li><code>Accept-Language</code></li>
<li><code>Content-Language</code></li>
</ul>
<p>内容协商技术分为以下三种类型</p>
<ul>
<li>服务器驱动协商：以请求的首部字段为参考，由服务器端自动进行内容协商，未必能选择出最优内容</li>
<li>客户端驱动协商：由客户端进行内容协商。用户可从浏览器的可选列表里手动选择，还可以利用JS脚本自动选择</li>
<li>透明协商：是服务器驱动和客户端驱动的结合体，是服务器端和客户端各自进行内容协商的一种方法</li>
</ul>
<hr>
<h2 id="第四章：返回结果状态的HTTP状态码"><a href="#第四章：返回结果状态的HTTP状态码" class="headerlink" title="第四章：返回结果状态的HTTP状态码"></a>第四章：返回结果状态的HTTP状态码</h2><h3 id="4-1-状态码告知服务器端返回的请求结果"><a href="#4-1-状态码告知服务器端返回的请求结果" class="headerlink" title="4.1 状态码告知服务器端返回的请求结果"></a>4.1 状态码告知服务器端返回的请求结果</h3><p>借助状态码，用户可以知道服务器端是正常处理了请求还是出现了错误</p>
<p>响应类别有如下5种</p>
<ul>
<li>1XX<ul>
<li>信息性状态码</li>
<li>表示接收的请求正在处理</li>
</ul>
</li>
<li>2XX<ul>
<li>成功状态码</li>
<li>表示请求正常处理完毕</li>
</ul>
</li>
<li>3XX<ul>
<li>重定向状态码</li>
<li>需要进行附加操作以完成请求</li>
</ul>
</li>
<li>4XX<ul>
<li>客户端错误状态码</li>
<li>服务器无法处理请求</li>
</ul>
</li>
<li>5XX<ul>
<li>服务器错误状态码</li>
<li>服务器处理请求出错</li>
</ul>
</li>
</ul>
<p>经常使用的状态码有14种</p>
<h3 id="4-2-2XX-成功"><a href="#4-2-2XX-成功" class="headerlink" title="4.2 2XX 成功"></a>4.2 2XX 成功</h3><h4 id="200-OK"><a href="#200-OK" class="headerlink" title="200 OK"></a>200 OK</h4><p>表示从客户端发来的请求在服务器端被正常处理了</p>
<p>随状态码返回的信息会因方法不同而发生改变</p>
<h4 id="204-No-Content"><a href="#204-No-Content" class="headerlink" title="204 No Content"></a>204 No Content</h4><p>表示接收的请求已被成功处理，但返回的响应报文中不含实体的主体部分，也不允许返回任何实体的主体</p>
<p>在客户端忘服务器端发送信息，而客户端不需要更新信息内容时使用</p>
<h4 id="206-Partial-Content"><a href="#206-Partial-Content" class="headerlink" title="206 Partial Content"></a>206 Partial Content</h4><p>表示客户端进行了范围请求，服务器成功执行了这部分的GET请求。响应报文中包含有Content-Range指定范围的实体内容</p>
<h3 id="4-3-3XX-重定向"><a href="#4-3-3XX-重定向" class="headerlink" title="4.3 3XX 重定向"></a>4.3 3XX 重定向</h3><h4 id="301-Moved-Permanently"><a href="#301-Moved-Permanently" class="headerlink" title="301 Moved Permanently"></a>301 Moved Permanently</h4><p>永久性重定向。表示请求的资源已经被分配了新的URI，以后应使用资源现在所指的URI</p>
<h4 id="302-Found"><a href="#302-Found" class="headerlink" title="302 Found"></a>302 Found</h4><p>临时重定向。表示请求的资源已经被分配了新的URI，本次应使用资源现在所指的URI</p>
<h4 id="303-See-Other"><a href="#303-See-Other" class="headerlink" title="303 See Other"></a>303 See Other</h4><p>表示请求的资源存在着另一个URI，应使用GET方法定向获取请求的资源</p>
<p>与302有着相同的功能，但明确表示客户端应该使用GET方法获取资源</p>
<h4 id="304-Not-Modified"><a href="#304-Not-Modified" class="headerlink" title="304 Not Modified"></a>304 Not Modified</h4><p>表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但因发生请求未满足条件的情况后直接返回304</p>
<p>和重定向没有关系</p>
<h4 id="307-Temporary-Redirect"><a href="#307-Temporary-Redirect" class="headerlink" title="307 Temporary Redirect"></a>307 Temporary Redirect</h4><p>临时重定向，与302有相同的含义</p>
<p>302标准禁止POST变为GET，但大家并不遵守</p>
<p>307会遵照浏览器标准，不会从POST变为GET。但是对于处理响应时的行为，不同浏览器有可能出现不同情况</p>
<h3 id="4-4-4XX-客户端错误"><a href="#4-4-4XX-客户端错误" class="headerlink" title="4.4 4XX 客户端错误"></a>4.4 4XX 客户端错误</h3><h4 id="400-Bad-Request"><a href="#400-Bad-Request" class="headerlink" title="400 Bad Request"></a>400 Bad Request</h4><p>表示请求报文中有语法错误，需要修改请求内容后再次发送请求</p>
<h4 id="401-Unauthorized"><a href="#401-Unauthorized" class="headerlink" title="401 Unauthorized"></a>401 Unauthorized</h4><p>表示发送的请求需要有通过HTTP认证（BASIC认证，DIGEST认证）的认证信息。若之前已经进行过一次请求，则表示用户认证失败</p>
<p>浏览器初次接收到401响应会弹出认证用的对话窗口</p>
<h4 id="403-Forbidden"><a href="#403-Forbidden" class="headerlink" title="403 Forbidden"></a>403 Forbidden</h4><p>表示对请求资源的访问被服务器拒绝了</p>
<h4 id="404-Not-Found"><a href="#404-Not-Found" class="headerlink" title="404 Not Found"></a>404 Not Found</h4><p>表明服务器上没有请求的资源</p>
<h3 id="4-5-5XX-服务器错误"><a href="#4-5-5XX-服务器错误" class="headerlink" title="4.5 5XX 服务器错误"></a>4.5 5XX 服务器错误</h3><h4 id="500-Internet-Server-Error"><a href="#500-Internet-Server-Error" class="headerlink" title="500 Internet Server Error"></a>500 Internet Server Error</h4><p>表明服务器端在执行请求时发生了错误，也许是web应用的bug所致</p>
<h4 id="503-Server-Unavailable"><a href="#503-Server-Unavailable" class="headerlink" title="503 Server Unavailable"></a>503 Server Unavailable</h4><p>表明服务器正处于超负载或停机维护，暂时无法处理请求</p>
<hr>
<h2 id="第五章-与HTTP协作的web服务器"><a href="#第五章-与HTTP协作的web服务器" class="headerlink" title="第五章 与HTTP协作的web服务器"></a>第五章 与HTTP协作的web服务器</h2><h3 id="5-1-用单台虚拟主机实现多个域名"><a href="#5-1-用单台虚拟主机实现多个域名" class="headerlink" title="5.1 用单台虚拟主机实现多个域名"></a>5.1 用单台虚拟主机实现多个域名</h3><p>即使物理层面只有一个服务器，但使用了虚拟主机的功能，则可以假想已经具有了多台服务器</p>
<p>当两个域名被部署在一个服务器上时，使用DNS服务解析域名后会得到相同的IP地址。</p>
<p>在相同的IP地址下，由于虚拟主机可以寄存多个不同主机名和域名的web网站，因此在发送HTTP请求时，必须在HOST主部中完整指定主机名和域名的URI</p>
<h3 id="5-2-代理，网关，隧道"><a href="#5-2-代理，网关，隧道" class="headerlink" title="5.2 代理，网关，隧道"></a>5.2 代理，网关，隧道</h3><h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><p>代理服务器的基本行为就是接收客户端发送的请求后转发给其他服务器。代理不改变请求URI</p>
<p>持有资源实体的服务器称为源服务器，源服务器返回的响应经过代理服务器传回客户端</p>
<p>可级联多台代理服务器。转发时需要用Via首部字段以标记经处的主机信息</p>
<p>代理有多种使用方法，按两种基准分类</p>
<ul>
<li>缓存代理：代理转发响应时，缓存代理会预先将资源副本（缓存）保存在代理服务器上，当代理再次接收到相同资源的请求时，将缓存的资源直接返回</li>
<li>透明代理：不对报文做任何类型加工的代理类型称为透明代理，反之称为非透明代理</li>
</ul>
<h3 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h3><p>网关的工作方式与代理相似，但网关能使通信链路上的服务器提供非HTTP协议服务</p>
<p>利用网关能提高通信的安全性，因为可以在客户端和网关之间的通信链路上加密以确保连接的安全</p>
<h4 id="隧道"><a href="#隧道" class="headerlink" title="隧道"></a>隧道</h4><p>隧道可按要求建立起一条与其他服务器的通信链路，使用SSL等加密手段进行通信。隧道的目的是确保服务器和客户端能安全通信</p>
<p>隧道本身不会解析HTTP请求，请求保持原样中转给之后的服务器</p>
<h3 id="5-3-缓存"><a href="#5-3-缓存" class="headerlink" title="5.3 缓存"></a>5.3 缓存</h3><p>缓存指代理服务器或客户端本地磁盘内保存的资源副本</p>
<p>利用缓存可减少对源服务器的访问，节省了通信流量和通信时间</p>
<p>缓存服务器是代理服务器的一种，归类在缓存代理类型中</p>
<p>缓存服务器的优势在于利用缓存可以避免多次从源服务器转发资源。</p>
<h4 id="缓存的有效期限"><a href="#缓存的有效期限" class="headerlink" title="缓存的有效期限"></a>缓存的有效期限</h4><p>即使缓存服务器内存在缓存，也会因为客户端的要求，缓存的有效期限等因素，向原服务器确认资源的有效性。若判断缓存失效，缓存服务器会再次从原服务器上获取”新”资源</p>
<h4 id="客户端的缓存"><a href="#客户端的缓存" class="headerlink" title="客户端的缓存"></a>客户端的缓存</h4><p>除了代理服务器中存在缓存，客户端浏览器中也能存在缓存。如果缓存有效，则不用向服务器发送请求，直接从本地磁盘中读取资源</p>
<p>和缓存服务器相同，当判定缓存过期后，会向源服务器确认资源的有效性，若判断缓存失效，浏览器会再次请求新资源</p>
<hr>
<h2 id="第六章-HTTP首部"><a href="#第六章-HTTP首部" class="headerlink" title="第六章 HTTP首部"></a>第六章 HTTP首部</h2><h3 id="6-1-HTTP报文首部"><a href="#6-1-HTTP报文首部" class="headerlink" title="6.1 HTTP报文首部"></a>6.1 HTTP报文首部</h3><p>HTTP请求和响应报文中必定包含报文首部，报文首部由几个字段组成</p>
<ul>
<li>HTTP请求报文：由方法，HTTP版本，HTTP首部字段等部分构成</li>
<li>HTTP响应报文：由HTTP版本，状态码（数字和原因短语），HTTP首部字段三部分构成</li>
</ul>
<h3 id="6-2-HTTP首部字段"><a href="#6-2-HTTP首部字段" class="headerlink" title="6.2 HTTP首部字段"></a>6.2 HTTP首部字段</h3><h4 id="6-2-1-首部字段传递重要信息"><a href="#6-2-1-首部字段传递重要信息" class="headerlink" title="6.2.1 首部字段传递重要信息"></a>6.2.1 首部字段传递重要信息</h4><p>使用首部字段是为了给浏览器和服务器提供报文主体大小，所使用的语言，认证信息等内容</p>
<h4 id="6-2-2-HTTP首部字段结构"><a href="#6-2-2-HTTP首部字段结构" class="headerlink" title="6.2.2 HTTP首部字段结构"></a>6.2.2 HTTP首部字段结构</h4><p>首部字段名： 字段值</p>
<p>可以有多个值，用逗号隔开</p>
<h4 id="6-2-3-4种HTTP首部字段类型"><a href="#6-2-3-4种HTTP首部字段类型" class="headerlink" title="6.2.3 4种HTTP首部字段类型"></a>6.2.3 4种HTTP首部字段类型</h4><ul>
<li>通用首部字段：请求和响应报文双方都会使用的首部</li>
<li>请求首部字段：从客户端向服务器端发送请求报文时使用的首部</li>
<li>响应首部字段：从服务器端向客户端发送响应报文时使用的首部</li>
<li>实体首部字段：针对请求报文和响应报文的实体部分使用的首部</li>
</ul>
<h4 id="6-2-4-HTTP-x2F-1-1首部字段一览"><a href="#6-2-4-HTTP-x2F-1-1首部字段一览" class="headerlink" title="6.2.4 HTTP&#x2F;1.1首部字段一览"></a>6.2.4 HTTP&#x2F;1.1首部字段一览</h4><ul>
<li>通用首部字段<ul>
<li><code>Cache-Control</code>:控制缓存行为</li>
<li><code>Connection</code>:逐跳首部、连接的管理</li>
<li><code>Date</code>:创建报文的日期时间</li>
<li><code>Pragma</code>:报文指令</li>
<li><code>Trailer</code>:报文末端的首部一览</li>
<li><code>Transfer-Encoding</code>:指定报文主体的传输编码方式</li>
<li><code>Upgrade</code>:升级为其他协议</li>
<li><code>Via</code>:代理服务器的相关信息</li>
<li><code>Warning</code>:错误通知</li>
</ul>
</li>
<li>请求首部字段<ul>
<li><code>Accept</code>:用户代理可处理的媒体类型</li>
<li><code>Accept-Charset</code>:优先的字符集</li>
<li><code>Accept-Encoding</code>:优先的内容编码</li>
<li><code>Accept-Language</code>:优先的语言（自然语言）</li>
<li><code>Authorized</code>:Web认证信息</li>
<li><code>Expect</code>:期待服务器的特定行为</li>
<li><code>From</code>:用户的电子邮箱地址</li>
<li><code>Host</code>:请求资源所在的服务器</li>
<li><code>If-Match</code>:比较实体标记（ETag）</li>
<li><code>If-Modified-Since</code>:比较资源的更新时间</li>
<li><code>If-None-Match</code>:比较实体标记（与If-Match相反）</li>
<li><code>If-Range</code>:资源未更新时发送实体Byte的范围请求</li>
<li><code>If-Unmodified-Since</code>:比较资源的更新时间（与If-Modified-Since相反）</li>
<li><code>Max-Forwards</code>:最大传输跳转数</li>
<li><code>Proxy-Authorization</code>:代理服务器要求客户端的认证信息</li>
<li><code>Range</code>:实体的字节范围请求</li>
<li><code>Referer</code>:对请求中URI的原始获取方</li>
<li><code>TE</code>:传输编码的优先级</li>
<li><code>User-Agent</code>:HTTP客户端程序的信息</li>
</ul>
</li>
<li>响应首部字段<ul>
<li><code>Accept-Ranges</code>:是否接收字节范围请求</li>
<li><code>Age</code>:推算资源创建经过时间</li>
<li><code>ETAG</code>:资源的匹配信息</li>
<li><code>Location</code>:令客户端重定向至指定URI</li>
<li><code>Proxy-Authenticate</code>:代理服务器对客户端的认证信息</li>
<li><code>Retry-After</code>:对再次发起请求的时间要求</li>
<li><code>Server</code>:HTTP服务器的安装信息</li>
<li><code>Vary</code>:代理服务器缓存的管理信息</li>
<li><code>WWW-Authenticate</code>:服务器对客户端的认证信息</li>
</ul>
</li>
<li>实体首部字段：<ul>
<li><code>Allow</code>:资源可支持的HTTP方法</li>
<li><code>Content-Encoding</code>:实体主体适用的编码方式</li>
<li><code>Content-Language</code>:实体主体的自然语言</li>
<li><code>Content-Length</code>:实体主体的大小</li>
<li><code>Content-Location</code>:替代对应资源的URI</li>
<li><code>Content-MD5</code>:实体主体的报文摘要</li>
<li><code>Content-Range</code>:实体主体的位置范围</li>
<li><code>Content-Type</code>:实体主体的媒体类型</li>
<li><code>Expires</code>:实体主体过期的日期时间</li>
<li><code>Last-Modified</code>:资源最后的修改日期</li>
</ul>
</li>
</ul>
<h4 id="6-2-5-非HTTP-x2F-1-1首部字段"><a href="#6-2-5-非HTTP-x2F-1-1首部字段" class="headerlink" title="6.2.5 非HTTP&#x2F;1.1首部字段"></a>6.2.5 非HTTP&#x2F;1.1首部字段</h4><p>除了RFC2616中定义的47种首部字段，还有Cookie，Set-Cookie和Content-Disposition等在其他RFC中定义的首部字段，它们的使用频率很高</p>
<h4 id="6-2-6-End-to-end首部和Hop-by-hop首部"><a href="#6-2-6-End-to-end首部和Hop-by-hop首部" class="headerlink" title="6.2.6 End-to-end首部和Hop-by-hop首部"></a>6.2.6 End-to-end首部和Hop-by-hop首部</h4><ul>
<li>端到端首部：分在此类的首部会转发给请求&#x2F;响应对应的最终接受目标，且必须保存在由缓存生成的响应中，另外规定它必须被转发</li>
<li>逐跳首部：分在此类别中的首部只对单次转发有效，会因通过缓存或代理而不再转发</li>
</ul>
<p>HTTP&#x2F;1.1及之后版本中，使用逐跳首部需要提供Connection首部字段</p>
<h3 id="6-3-HTTP通用首部字段"><a href="#6-3-HTTP通用首部字段" class="headerlink" title="6.3 HTTP通用首部字段"></a>6.3 HTTP通用首部字段</h3><p>看书！</p>
<hr>
<h2 id="第七章-确保Web安全的HTTPS"><a href="#第七章-确保Web安全的HTTPS" class="headerlink" title="第七章 确保Web安全的HTTPS"></a>第七章 确保Web安全的HTTPS</h2><h3 id="7-1-HTTP的缺点"><a href="#7-1-HTTP的缺点" class="headerlink" title="7.1 HTTP的缺点"></a>7.1 HTTP的缺点</h3><h4 id="7-1-1-通信使用明文可能被窃听"><a href="#7-1-1-通信使用明文可能被窃听" class="headerlink" title="7.1.1 通信使用明文可能被窃听"></a>7.1.1 通信使用明文可能被窃听</h4><p>HTTP使用未经加密的报文发送。</p>
<p>按TCP&#x2F;IP协议族的工作机制，通信内容在所有的通信链路上都可能遭到窥视</p>
<p>加密后的报文也会被人看到，但是不容易破解而得到其中的含义</p>
<p>可以通过加密处理防止被窃听，加密对象可以如下：</p>
<ul>
<li>通信的加密</li>
</ul>
<p>通过SSL（安全套接层）和TLS（安全传输层协议）组合使用，加密HTTP的通信内容</p>
<p>用SSL建立安全通信链路后，就可以在这条链路上进行HTTP通信，与SSL组合使用的HTTP称为HTTPS（超文本传输安全协议）.</p>
<ul>
<li>内容的加密</li>
</ul>
<p>即把HTTP报文里所含的内容进行加密，前提是客户端和服务器端同时具有加密和解密的功能</p>
<p>这种方式所传输的内容仍有被篡改的风险</p>
<h4 id="7-1-2-不验证通信方的身份就可能遭遇伪装"><a href="#7-1-2-不验证通信方的身份就可能遭遇伪装" class="headerlink" title="7.1.2 不验证通信方的身份就可能遭遇伪装"></a>7.1.2 不验证通信方的身份就可能遭遇伪装</h4><p>HTTP协议中的请求和响应不会对通信方进行确认</p>
<p><strong>任何人可发起请求</strong></p>
<ul>
<li>无法确定目标web服务器是否是伪装服务器</li>
<li>无法确认收到响应的客户端是否是伪装客户端</li>
<li>无法确定正在通信的对方是否具备访问权限</li>
<li>无法判断请求来自何方</li>
<li>无意义的请求也会照单全收，无法阻止Dos攻击</li>
</ul>
<p><strong>查明对手的证书</strong></p>
<p>单单使用HTTP协议无法确定通信方，但使用SSL则可以</p>
<p>SSL不仅提供加密处理，还提供了一种名为证书的手段，用于确定通信方</p>
<p>证书由值得信任的第三方机构提供，用以证明服务器和客户端是实际存在的，伪造证书在技术上异常困难，因此只要能确认证书，就能判断通信方的真实意图</p>
<p>通过使用证书证明通信方就是意料中的服务器，减少了个人信息泄露的可能</p>
<p>客户端持有证书可以用于完成个人身份的确认，也可以用于web网站的认证环节</p>
<h4 id="7-1-3-无法证明报文完整性，可能已遭篡改"><a href="#7-1-3-无法证明报文完整性，可能已遭篡改" class="headerlink" title="7.1.3 无法证明报文完整性，可能已遭篡改"></a>7.1.3 无法证明报文完整性，可能已遭篡改</h4><p><strong>接收到的内容可能有误</strong></p>
<p>HTTP协议无法证明通信报文的完整性，也就是说，没有任何办法确认发送的报文和通信方接收到的报文是相同的</p>
<p><strong>如何防止篡改</strong></p>
<p>常用的方法是用MD5和SHA-1等散列值校验的方法，以及用来确认文件数字签名的方法（PGP）</p>
<p>用户需要自己查看下载的文件是否是原来服务器上的文件，浏览器无法帮助查看</p>
<p>但一旦MD5和PGP本身被改写，用户是无法察觉到的，因此无法确认结果一定正确</p>
<p>因此有必要使用HTTPS</p>
<h3 id="7-2-HTTP-加密-认证-完整性保护-x3D-HTTPS"><a href="#7-2-HTTP-加密-认证-完整性保护-x3D-HTTPS" class="headerlink" title="7.2 HTTP+加密+认证+完整性保护&#x3D;HTTPS"></a>7.2 HTTP+加密+认证+完整性保护&#x3D;HTTPS</h3><h4 id="7-2-1-HTTP加上加密处理和认证及完整性保护后就是HTTPS"><a href="#7-2-1-HTTP加上加密处理和认证及完整性保护后就是HTTPS" class="headerlink" title="7.2.1 HTTP加上加密处理和认证及完整性保护后就是HTTPS"></a>7.2.1 HTTP加上加密处理和认证及完整性保护后就是HTTPS</h4><p>使用HTTPS通信时，使用<code>https://</code>，访问HTTPS通信有效的web网站时，地址栏会出现一个锁。对HTTPS的显示方式会因浏览器不同有所改变</p>
<h4 id="7-2-2-HTTPS是身披SSL外壳的HTTP"><a href="#7-2-2-HTTPS是身披SSL外壳的HTTP" class="headerlink" title="7.2.2 HTTPS是身披SSL外壳的HTTP"></a>7.2.2 HTTPS是身披SSL外壳的HTTP</h4><p>HTTPS并不是全新的协议，只是HTTP通信接口部分用SSL和TLS协议代替</p>
<p>通常HTTP直接和TCP通信，使用SSL时，先和SSL通信，再由SSL和TCP通信</p>
<p>SSL是独立于HTTP的协议，不光HTTP，其他应用层协议也可配合SSL使用</p>
<h4 id="7-2-3-相互交换密钥的公开密钥交换技术"><a href="#7-2-3-相互交换密钥的公开密钥交换技术" class="headerlink" title="7.2.3 相互交换密钥的公开密钥交换技术"></a>7.2.3 相互交换密钥的公开密钥交换技术</h4><p><strong>共享加密密钥的困境</strong></p>
<p>加密和解密公用一个密钥的方式称为共享密钥加密（对称密钥加密）</p>
<p>但发送密钥有被窃听的风险，不发送通信方就无法解密，而且若密钥能安全发送，直接发送数据也能安全到达</p>
<p><strong>使用两种密钥的公开密钥加密</strong></p>
<p>公开密钥加密使用非对称的密钥。一把叫私钥，一把叫公钥。私钥不能让其他任何人知道，公钥可以发送给任何人</p>
<p>发送数据一方使用对方的公钥对数据进行加密，对方收到加密后的数据后使用私钥解密</p>
<p>只有公钥对密文还原是非常困难的</p>
<p><strong>HTTPS使用混合加密机制</strong></p>
<p>HTTPS使用共享密钥加密和公开密钥加密两者并用的混合加密机制。但公开密钥加密比共享密钥加密速度慢</p>
<p>因此充分利用二者优势，在交换密钥环节使用公开密钥加密，之后建立通信交换报文阶段使用共享密钥加密方式</p>
<p>即用公开密钥加密之后会在共享密钥加密过程中使用的密钥。</p>
<h4 id="7-2-4-证明公开密钥正确的证书"><a href="#7-2-4-证明公开密钥正确的证书" class="headerlink" title="7.2.4 证明公开密钥正确的证书"></a>7.2.4 证明公开密钥正确的证书</h4><p>公开密钥加密还是存在一些问题的，那就是无法证明公钥本身是否货真价实</p>
<p>为解决这个问题，可以由数字证书认证机构和其相关机关颁布的公开密钥证书</p>
<p>数字证书认证机构会将服务器运营人员发来的公开密钥添加进入数字证书并标记上数字签名，服务器取得了数字证书后将其发给客户端，客户端可使用数字证书机构的公开密钥对证书上的数字签名进行验证。一旦验证通过，客户端即可确定：1.认证服务器的公开密钥的是真实有效的数字机构 2.服务器的公开密钥值得信赖</p>
<p>认证机构的公共密钥也必须安全的转交给客户端，因此多数浏览器开发商都会事先在浏览器内部植入常用认证机关的公钥</p>
<p><strong>EV SSL证书</strong></p>
<p>此证书可以确认服务器背后运营的企业真实存在</p>
<p>持有该证书的网站的浏览器地址栏处的背景颜色是绿色的</p>
<p>愿意图是防止用户被钓鱼攻击，但实际效果不佳，因为大部分用户不了解该证书相关知识，并不会注意</p>
<p><strong>客户端证书</strong></p>
<p>客户端也可以申请客户端证书，发挥服务器证书相同的作用</p>
<p>但每申请一张证书都要相应的费用，安装证书也需要用户自身的知识水平，客户端证书只在少数情况下使用</p>
<p>如银行的网上银行采用客户端证书，登录网银时不仅要确认id和密码，还需要客户端证书来确认是否从特定终端上访问</p>
<p>客户端证书只能证明客户端实际存在，却无法证明客户端用户身份，若用户控制了计算机的使用权，也就拥有了客户端证书的使用权</p>
<p><strong>自签名证书</strong></p>
<p>由个体自己给自己的服务器颁布的证书称为自签名证书。独立构建的认证机构被称为自认证机构。自签名证书在互联网上无法被当作证书使用</p>
<p>当访问使用自签名证书的网站时，会提示”该网站的证书存在问题“等提示</p>
<h4 id="7-2-5-HTTPS的安全通信机制"><a href="#7-2-5-HTTPS的安全通信机制" class="headerlink" title="7.2.5 HTTPS的安全通信机制"></a>7.2.5 HTTPS的安全通信机制</h4><p>以TLS握手为例</p>
<ul>
<li>客户端发送clienthello消息，包含TLS版本，加密算法集，随机数</li>
<li>服务器端接收消息后发送serverHello消息，包含TLS版本，加密算法集，随机数</li>
<li>服务器端发送包含公钥的证书</li>
<li>服务器端发送serverHelloDone消息</li>
<li>客户端接收服务器端消息后验证证书机构是否权威和服务器是否为值得信赖的服务器，获取公钥</li>
<li>客户端发送由公钥加密的premaster secret</li>
<li>服务器端用私钥解密premaster secret</li>
<li>客户端和服务端使用之前生成的两个随机数＋premaster secret生成master secret用于对之后通信的所有数据加密</li>
<li>客户端发送ChangeCipherSpec消息和用master secret加密的finish消息</li>
<li>服务器端接收并验证，发送ChangeCipherSpec消息和用master secret加密的finish消息</li>
<li>客户端接收并认证，握手结束</li>
</ul>
<hr>
<h2 id="第八章-确认访问用户身份的认证"><a href="#第八章-确认访问用户身份的认证" class="headerlink" title="第八章 确认访问用户身份的认证"></a>第八章 确认访问用户身份的认证</h2><h3 id="8-1-何为认证"><a href="#8-1-何为认证" class="headerlink" title="8.1 何为认证"></a>8.1 何为认证</h3><p>认证用于核实客户端使用者的身份</p>
<p>HTTP&#x2F;1.1的认证方式如下</p>
<ul>
<li><p>BASIC认证（基本认证）</p>
</li>
<li><p>DIGEST认证（摘要认证）</p>
</li>
<li><p>SSL客户端认证</p>
</li>
<li><p>FormBase认证（基于表单认证）</p>
</li>
</ul>
<h3 id="8-2-BASIC认证"><a href="#8-2-BASIC认证" class="headerlink" title="8.2 BASIC认证"></a>8.2 BASIC认证</h3><ul>
<li>用户发送请求后，服务器返回401状态码，返回带WWW-Authenticate首部字段的响应，字段内含有认证方式和Request-URI安全域字符串（realm）</li>
<li>接到401状态码的客户端为了通过认证需要将用户id和密码发送给服务器，发送内容由“ID：密码”组成，经Base64编码处理后写入Authorization字段发送。若用户代理为浏览器，输入ID和密码即可，浏览器自动进行Base64编码</li>
<li>接到含首部字段Authorization请求的服务器对其进行验证，若通过则返回包含Request-URI资源的响应</li>
</ul>
<p>BASIC认证的Base编码并不是加密，可以直接解码为明文，因此在非加密通信的链路上进行认证时有可能被窃听</p>
<p>一般的浏览器无法实现认证注销</p>
<h3 id="8-3-DIGEST认证"><a href="#8-3-DIGEST认证" class="headerlink" title="8.3 DIGEST认证"></a>8.3 DIGEST认证</h3><p>DIGEST认证不会像BASIC认证那样直接发送明文密码</p>
<p>但同样安全系数有限，不被常用</p>
<h3 id="8-4-SSL客户端认证"><a href="#8-4-SSL客户端认证" class="headerlink" title="8.4 SSL客户端认证"></a>8.4 SSL客户端认证</h3><p>服务器端发送报文要求客户端发送客户端证书内容，客户端发送含公钥的客户端证书，服务器端收到证书后开启HTTPS连接</p>
<p><strong>双因素认证</strong></p>
<p>通过客户端认证确认终端，通过表单认证确认是用户本人操作，这种认证方式称为双因素认证</p>
<h3 id="8-5-基于表单认证"><a href="#8-5-基于表单认证" class="headerlink" title="8.5 基于表单认证"></a>8.5 基于表单认证</h3><p>并不是在HTTP中定义。客户端会向服务器的web应用发送登录信息，按登录信息的验证结果进行认证</p>
<p>现实中大多为基于表单的认证</p>
<p><strong>session管理和cookie应用</strong></p>
<p>客户端向服务器发送账号密码，服务器端验证后返回包含session-id的cookie，客户端再次登录时直接发送含session的cookie，服务器通过验证session信息验证是否为以登录的用户</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>自学Vue第二章笔记</title>
    <url>/2022/08/03/VUE-chapter4/</url>
    <content><![CDATA[<h4 id="v-html在模板中输出html"><a href="#v-html在模板中输出html" class="headerlink" title="v-html在模板中输出html"></a>v-html在模板中输出html</h4><p>使用v-html在标签内输出html，为防止恶意代码，最好使用自己定义的html，对于用户输入要做过滤处理</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app=<span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">        <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">content</span>:<span class="string">&quot;&lt;p&gt;用v-html输出html&lt;/p&gt;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-html</span>=<span class="string">&quot;content&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="v-once只渲染一次模板"><a href="#v-once只渲染一次模板" class="headerlink" title="v-once只渲染一次模板"></a>v-once只渲染一次模板</h4><p>如果只需要显示原始数据，当数据发生改变时不重新渲染，可以使用v-once</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app=<span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">       <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> &#123;</span><br><span class="line">               <span class="attr">list</span>:[],</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">   app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-once</span>&gt;</span>原始长度:&#123;&#123;list.length&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>当前长度:&#123;&#123;list.length&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;this.list.push(this.list.length)&quot;</span>&gt;</span>添加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="v-bind和v-on绑定动态参数"><a href="#v-bind和v-on绑定动态参数" class="headerlink" title="v-bind和v-on绑定动态参数"></a>v-bind和v-on绑定动态参数</h4><p>在：或@后加上中括号[]，在中括号中加入js代码，就可以为v-bind和v-on绑定动态参数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app=<span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">        <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">attr</span>:<span class="string">&quot;placeholder&quot;</span>,</span><br><span class="line">                <span class="attr">event</span>:<span class="string">&quot;change&quot;</span>,</span><br><span class="line">                <span class="attr">value</span>:<span class="string">&quot;请输入内容&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">methods</span>:&#123;</span><br><span class="line">            <span class="title function_">handleInput</span>(<span class="params"></span>)&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;changed!&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">:</span>[<span class="attr">attr</span>]=<span class="string">&quot;value&quot;</span> @[<span class="attr">event</span>]=<span class="string">&quot;handleInput&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="v-for高级用法"><a href="#v-for高级用法" class="headerlink" title="v-for高级用法"></a>v-for高级用法</h4><ul>
<li>v-for循环除了可以遍历数组外还可以遍历对象，形式与遍历数组基本一致</li>
<li>v-for循环中可以为循环变量增添一个key值，当数组或对象中的元素顺序改变时，vue也会做出顺序的改变而不是直接修改值</li>
<li>v-for还可以直接指定一个数，如n in 5,结果输出12345</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app=<span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">        <span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">todo_list</span>:&#123;</span><br><span class="line">                    <span class="attr">todo1</span>:&#123;</span><br><span class="line">                        <span class="attr">id</span>:<span class="number">1</span>,</span><br><span class="line">                        <span class="attr">content</span>:<span class="string">&quot;代办1&quot;</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="attr">todo2</span>:&#123;</span><br><span class="line">                        <span class="attr">id</span>:<span class="number">2</span>,</span><br><span class="line">                        <span class="attr">content</span>:<span class="string">&quot;代办2&quot;</span>,</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="attr">todo3</span>:&#123;</span><br><span class="line">                        <span class="attr">id</span>:<span class="number">3</span>,</span><br><span class="line">                        <span class="attr">content</span>:<span class="string">&quot;代办3&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;todo in todo_list&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;todo.id&quot;</span>&gt;</span>&#123;&#123;todo.content&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;n in 5&quot;</span>&gt;</span>&#123;&#123;n&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="template标签"><a href="#template标签" class="headerlink" title="template标签"></a>template标签</h4><p>使用<code>&lt;template&gt;</code>标签可以只渲染里面的内容而不渲染外层的template标签</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app=<span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">        <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="number">10</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">&quot;value&gt;0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>不会渲染出外层template标签<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="事件传参和多事件处理"><a href="#事件传参和多事件处理" class="headerlink" title="事件传参和多事件处理"></a>事件传参和多事件处理</h4><p>可以在@绑定的事件函数中直接调用函数并传入参数，事件参数固定为@event，想绑定多个事件函数可以用<code>,</code>，事件函数会依次执行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app=<span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">        <span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">todos</span>:[&#123;</span><br><span class="line">                    <span class="attr">content</span>:<span class="string">&quot;代办1&quot;</span>,</span><br><span class="line">                    <span class="attr">id</span>:<span class="number">1</span>,</span><br><span class="line">                &#125;,&#123;</span><br><span class="line">                    <span class="attr">content</span>:<span class="string">&quot;代办2&quot;</span>,</span><br><span class="line">                    <span class="attr">id</span>:<span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">                &#125;,&#123;</span><br><span class="line">                    <span class="attr">content</span>:<span class="string">&quot;代办3&quot;</span>,</span><br><span class="line">                    <span class="attr">id</span>:<span class="number">3</span>,</span><br><span class="line">                &#125;]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">methods</span>:&#123;</span><br><span class="line">            <span class="title function_">calculate</span>(<span class="params">msg,e</span>)&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(msg);</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">clientX</span>+<span class="string">&quot; &quot;</span>+e.<span class="property">clientY</span>);</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="title function_">output</span>(<span class="params">msg</span>)&#123;</span><br><span class="line">                <span class="title function_">alert</span>(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;todo in todos&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;todo.id&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;calculate(todo.content,$event), output(todo.id)&quot;</span>&gt;</span>&#123;&#123;todo.content&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="事件相关修饰符"><a href="#事件相关修饰符" class="headerlink" title="事件相关修饰符"></a>事件相关修饰符</h4><ul>
<li>.prevent:阻止浏览器默认行为</li>
<li>.stop：阻止事件冒泡</li>
<li>.capture:捕获触发，从父元素触发至子元素</li>
<li>.self:当元素自身触发事件时才执行函数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app=<span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">        <span class="attr">methods</span>:&#123;</span><br><span class="line">            <span class="title function_">handleFather</span>(<span class="params"></span>)&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;触发父事件&#x27;</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="title function_">handleChild</span>(<span class="params"></span>)&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;触发子事件&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> @<span class="attr">click</span>=<span class="string">&quot;handleFather&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> @<span class="attr">click.prevent</span>&gt;</span>.prevent阻止默认行为，点击链接不会跳转<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> @<span class="attr">click.stop</span>=<span class="string">&quot;handleChild&quot;</span>&gt;</span>.stop阻止事件冒泡<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> @<span class="attr">click</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> @<span class="attr">click.capture</span>=<span class="string">&quot;handleFather&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> @<span class="attr">click</span>=<span class="string">&quot;handleChild&quot;</span>&gt;</span>capture会让事件的触发变为捕获触发，即会先捕获父元素，再触发子元素<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> @<span class="attr">click.self</span>=<span class="string">&quot;handleFather&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> @<span class="attr">click</span>=<span class="string">&quot;handleChild&quot;</span>&gt;</span>self使只有当元素自身触发事件时才会执行函数<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="处理键盘和鼠标事件"><a href="#处理键盘和鼠标事件" class="headerlink" title="处理键盘和鼠标事件"></a>处理键盘和鼠标事件</h4><p>使用.+按键名来绑定特定键位</p>
<p>使用.exact使只有特定按键被按下且其他按键没有被按下时才触发事件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app=<span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">list</span>:[<span class="string">&quot;好&quot;</span>,<span class="string">&quot;非常好&quot;</span>,<span class="string">&quot;很好&quot;</span>],</span><br><span class="line">            <span class="attr">content</span>:<span class="string">&quot;&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>:&#123;</span><br><span class="line">        <span class="title function_">submitlist</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">list</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">content</span>);</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">content</span>=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;comment in list&quot;</span>&gt;</span>&#123;&#123;comment&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;content&quot;</span> @<span class="attr">keyup.ctrl.enter.exact</span>=<span class="string">&quot;submitlist&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>查询按键的网址：</p>
<h4 id="与表单相关的修饰符"><a href="#与表单相关的修饰符" class="headerlink" title="与表单相关的修饰符"></a>与表单相关的修饰符</h4><ul>
<li>.lazy：当用户输入完，取消聚焦之后才触发双向绑定</li>
<li>.number：把用户输入的字段转换成num类型</li>
<li>.trim：去除用户输入的前后空格</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app=<span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">        <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">username</span>:<span class="string">&quot;&quot;</span>,</span><br><span class="line">                <span class="attr">year</span>:<span class="number">2000</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model.lazy.trim</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model.number</span>=<span class="string">&quot;year&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    &#123;&#123;username&#125;&#125;</span><br><span class="line">    &#123;&#123;year&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="通过vue实例访问和修改应用配置"><a href="#通过vue实例访问和修改应用配置" class="headerlink" title="通过vue实例访问和修改应用配置"></a>通过vue实例访问和修改应用配置</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vm=app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>然后可以访问vm的属性值或者做修改，是得可以使用外部js修改vue内部的值</p>
<h4 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h4><p>生命周期钩子是一个函数，会在合适的时期自动调用</p>
<ul>
<li><p><img src="/image/img_2.png" alt="image-20220709171124439"></p>
</li>
<li><p><img src="/image/img_3.png" alt="image-20220709171145368"></p>
</li>
<li><p><img src="/image/img_4.png" alt="image-20220709171208373"></p>
</li>
<li><p><img src="/image/img_5.png" alt="image-20220709171232027"></p>
</li>
<li><p><img src="/image/img_6.png" alt="image-20220709171335571"></p>
</li>
<li><p><img src="/image/img_7.png" alt="image-20220709171349173"></p>
</li>
<li><p><img src="/image/img_8.png" alt="image-20220709171400830"></p>
</li>
<li><p><img src="/image/img_9.png" alt="image-20220709171417499"></p>
</li>
</ul>
<p>常用的为created和mounted钩子</p>
<p><img src="/image/img_10.png" alt="image-20220709171500826"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app=<span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">        <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">posts</span>: [],</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">methods</span>:&#123;</span><br><span class="line">            <span class="keyword">async</span> <span class="title function_">getPosts</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> res=<span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&quot;./posts.json&quot;</span>);</span><br><span class="line">                <span class="keyword">const</span> data=<span class="keyword">await</span> res.<span class="title function_">json</span>();</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">posts</span>=data;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">getPosts</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">const</span> vm=app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;post in posts&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;post.id&quot;</span>&gt;</span>&#123;&#123;post.content&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Welcome to my BLOG!</title>
    <url>/2022/08/03/hello-world/</url>
    <content><![CDATA[<p>欢迎来到我的博客<br>我会在这里记录自己的学习，生活<br>谢谢你的到来！！</p>
]]></content>
      <categories>
        <category>欢迎</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title>css中list列表相关</title>
    <url>/2022/08/03/%E5%88%97%E8%A1%A8%E5%92%8C%E7%94%9F%E6%88%90%E7%9A%84%E5%86%85%E5%AE%B9/</url>
    <content><![CDATA[<h1 id="列表和生成的内容"><a href="#列表和生成的内容" class="headerlink" title="列表和生成的内容"></a>列表和生成的内容</h1><h3 id="改变记号类型"><a href="#改变记号类型" class="headerlink" title="改变记号类型"></a>改变记号类型</h3><p>使用<code>list-style-type</code>属性</p>
<p>与列表相关的属性只能应用到display属性为list-item的元素上，css并不区分有序列表和无序列表的项目。可以让有序列表使用圆点</p>
<p>如果不想要记号，可以设置none值，但none值只是让记号不显示，并没有阻断计数</p>
<p><code>list-style-type</code>的值是继承的，因此如果嵌套的列表需要使用不同的记号需要分别定义</p>
<p>除了默认提供的<code>list-style-type</code>值外，还可以使用字符串值作为记号</p>
<p>使用<code>list-style-image</code>属性</p>
<p>使用该属性可以将列表记号设置为图片</p>
<p>可以在声明图片记号之后再声明一个<code>list-style-type</code>作为后备记号类型</p>
<p>嵌套的列表同样会继承image属性</p>
<p>为嵌套的列表的image设置none阻止继承</p>
<p>但实际情况中用户代理可能会为列表设置一个list-style-type值，因此继承的list-style-type值可能不能生效</p>
<p>使用<code>list-style-position</code></p>
<p>该属性会改变列表记号的位置，设置为outside（默认值）时，记号显示在外部，设置为inside时，显示在内容内部</p>
<p>使用<code>list-style</code>简写属性</p>
<p><code>list-style:list-style-type list-style-image list-style-position</code></p>
<p>可以按任意顺序列出</p>
<p>列表项目本身是类似块级的元素，放在列表内容外部的记号对其他元素的布局没有影响，记号相对于列表内容类似于绝对定位</p>
<h3 id="生成的内容"><a href="#生成的内容" class="headerlink" title="生成的内容"></a>生成的内容</h3><p>生成的内容使用::before和::after伪元素插入文档。通过设置伪元素的content属性将指定的内容插入文档内容之前或之后</p>
<p>如果::before或::after选择符的目标是块级元素，那么display的值只能为none，inline，block，和marker，其他值都为block</p>
<p>如果是行内元素，那么display的值只能为none或inline，其他值都为inline</p>
<h5 id="content"><a href="#content" class="headerlink" title="content"></a>content</h5><p>content的值为字符串时，显示为字面当量，即使有特殊标签也直接显示出来</p>
<p>如果需要换行需要添加\A,如果需要将较长的字符串分多行书写需要\</p>
<p>content值为URI时，会将引入的资源插入合适的位置，如果是用户代理不支持的资源会完全忽略</p>
<p>如果想把属性值显示出来，可以使用<code>attr()</code>,如<code>content:attr(href)</code></p>
<p>如果属性不存在，将显示空字符串</p>
<h5 id="生成引号"><a href="#生成引号" class="headerlink" title="生成引号"></a>生成引号</h5><p>引号使用quote或open-quote等值生成</p>
<p><code>quote:&lt;string&gt; &lt;string&gt;</code></p>
<p>第一个字符定义开始引号，第二个字符定义结束引号</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>不常用</tag>
      </tags>
  </entry>
  <entry>
    <title>css动画</title>
    <url>/2022/08/03/%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<h1 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h1><h2 id="定义关键帧"><a href="#定义关键帧" class="headerlink" title="定义关键帧"></a>定义关键帧</h2><p>一个<code>@keyframes</code>规则有一个动画标识符（动画名称），以及一到多个关键帧块。</p>
<p>每个关键帧块有一到多个关键帧选择符（百分数或from&#x2F;to），声明属性及其值</p>
<p>关键帧没有指明动画的持续时间，在选择符中使用时间会使动画失效</p>
<p>0必须写成0%</p>
<p>选择符无需按照升序排序，但为了方便辨识建议从0%到100%</p>
<p>如果没有定义0%和100%的状态，默认到初始状态</p>
<p>如果定义了重复的关键帧选择符，那么会进行层叠（覆盖）</p>
<h2 id="把动画应用到元素上"><a href="#把动画应用到元素上" class="headerlink" title="把动画应用到元素上"></a>把动画应用到元素上</h2><p><code>animation-name</code>属性的值为一个逗号分隔的列表，指定想应用的关键帧动画的名称</p>
<p>如果列表中有标识符不存在，则会单个失效而不会全体失效</p>
<h3 id="定义时长"><a href="#定义时长" class="headerlink" title="定义时长"></a>定义时长</h3><p><code>animation-duration</code>用于定义动画时长，单位为秒或毫秒</p>
<p>必须带单位，且可以用逗号分隔来定义不同动画</p>
<p>如果时间比动画数少，那么缺少的值将成组复制</p>
<p>如果时间比动画数多或定义不存在的动画，动画和对应的时间都会被忽略</p>
<h3 id="声明迭代次数"><a href="#声明迭代次数" class="headerlink" title="声明迭代次数"></a>声明迭代次数</h3><p><code>animation-iteration-count</code>声明迭代次数</p>
<p>初始值为1，即动画只播放一次</p>
<p>如果值不是整数，动画会在最后一次迭代的中途停止</p>
<p>不允许设置负值，无效值会变成1</p>
<p>0是有效值，但动画迭代0次，仍会触发开始和结束事件</p>
<p>多出的值忽略，缺少的值根据现有的值重复</p>
<p>无效的值会使整个声明失效，受影响的动画只会播放一次</p>
<p>值为infinite无限次迭代播放</p>
<h3 id="设置播放方向"><a href="#设置播放方向" class="headerlink" title="设置播放方向"></a>设置播放方向</h3><p><code>animation-direction</code>属性可以控制动画播放的方向（从0%到100%还是从100%到0%）</p>
<p><code>animation-direction:normal/reverse/alternate/alternate-reverse</code></p>
<p>初始值：normal:动画每次都从0%到100%播放</p>
<p><code>reverse</code>:每次迭代都从100%到0%播放</p>
<p><code>alternate</code>:奇数次迭代从0%到100%，偶数次迭代从100%到0%</p>
<p><code>alternate-reverse</code>:奇数次迭代从100%到0%，偶数次迭代从0%到100%</p>
<h3 id="延迟播放"><a href="#延迟播放" class="headerlink" title="延迟播放"></a>延迟播放</h3><p><code>animation-delay</code>属性定义元素等待多久开始第一次迭代</p>
<p>单位为秒或毫秒</p>
<p>如果设置为负值，元素将立即开始播放，但是是从动画中途开始的</p>
<h3 id="动画事件"><a href="#动画事件" class="headerlink" title="动画事件"></a>动画事件</h3><p>与动画有关的事件有三个：<code>animationstart  animationiteration  animationend</code></p>
<p>每个事件都有三个只读属性：<code>animationName elapsedTime pseudoElement</code></p>
<p><code>animation-start</code>事件在动画开始时触发，如果delay为负值，则立即触发</p>
<p><code>animation-end</code>事件在动画结束时出啊发，如果迭代次数为infinite且duration值为正数，将永远不会触发animation-end事件，如果duration为0，<code>animationstart</code>和<code>animationend</code>将同时触发，而且按此顺序</p>
<p><code>animationiteration</code>事件在两次迭代之间触发，只要一次迭代后又发生迭代（不管是否完整），该事件都会触发</p>
<h3 id="改变动画的内部时序"><a href="#改变动画的内部时序" class="headerlink" title="改变动画的内部时序"></a>改变动画的内部时序</h3><p><code>animation-timing-function</code>指明动画在一次循环（或迭代）中如何演进</p>
<p>内容与<code>transition-timing-function</code>相同</p>
<p>如果将其应用到关键帧上，只对当前关键帧块上的元素有影响，且只有播放到包含那些属性的关键帧时时序函数才会生效</p>
<h3 id="设置动画的播放状态"><a href="#设置动画的播放状态" class="headerlink" title="设置动画的播放状态"></a>设置动画的播放状态</h3><p>使用<code>animation-play-state</code>属性定义动画的播放状态</p>
<p>值为running时动画播放，值为pause时动画暂停，在delay时pause也会使delay时钟暂停</p>
<h3 id="动画的填充模式"><a href="#动画的填充模式" class="headerlink" title="动画的填充模式"></a>动画的填充模式</h3><p><code>animation-fill-mode</code>属性定义动画播放结束后是否应用原来的属性值</p>
<p><code>animation-fill-mode:none/forwards/backwards/both</code></p>
<p><code>none</code>:动画不播放就没有效果，在delay结束前0%的效果不会应用到元素上</p>
<p><code>backwards</code>:0%定义的属性立即生效，而不用等待animation-delay属性结束</p>
<p><code>forwards</code>:动画触发<code>animationend</code>时的属性继续应用到元素上</p>
<p><code>both</code>:同时包含<code>backwards</code>和<code>forwards</code>两个值的作用</p>
<h2 id="写为一个属性"><a href="#写为一个属性" class="headerlink" title="写为一个属性"></a>写为一个属性</h2><p><code>animation</code></p>
<p>前面的时间是duration,后面的是delay</p>
<p>如果动画标识符的值和某个动画属性的值相同，<code>animation-name</code>应该放在最后</p>
<p>如果有多个动画为同一个属性指定了不同的值，最后一个应用的动画覆盖之前动画中声明的值</p>
<p>先把后声明的先走完，如果有多余时间再播放前面声明的动画</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>css中transform</title>
    <url>/2022/08/03/%E5%8F%98%E5%BD%A2/</url>
    <content><![CDATA[<h1 id="变形"><a href="#变形" class="headerlink" title="变形"></a>变形</h1><h2 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h2><p>笛卡尔坐标系：即xyz坐标系，x向右，y向下，z和z-index相同</p>
<p>球坐标系：显示3D效果所用的坐标系</p>
<h2 id="变形-1"><a href="#变形-1" class="headerlink" title="变形"></a>变形</h2><p>使用<code>transform:&lt;transform-list&gt;</code></p>
<p>变形的元素在视觉上可能会缩小或放大，但在页面中所占的空间是不变的</p>
<p>变形函数一次只处理一个，从左向右。如果顺序变了结果可能大变</p>
<p>有多个变形函数时，一旦有一个设置不正确导致失效，整个transform都会失效</p>
<p>变形通常不叠加</p>
<h3 id="平移函数"><a href="#平移函数" class="headerlink" title="平移函数"></a>平移函数</h3><p>平移函数是指沿一个轴或多个轴移动</p>
<p><code>translateX()和translateY()</code>通常称为2D平移函数</p>
<p>如果先进行旋转变形，那么xy轴也会对应旋转变换从而影响平移效果</p>
<p>如果值是百分数，那么移动距离相对于元素自身的尺寸计算</p>
<p>只移动XY轴方向时，可以使用<code>translate()</code>简写，第一个值是x轴移动量，第二个是y轴移动量，如果只有一个值，空缺的值视为0</p>
<p>使用<code>translateZ</code>沿z轴平移</p>
<p><code>translateZ()</code>只接受长度值</p>
<p><code>translate3d()</code>可以同时设置XYZ轴方向的平移量，如果赋值小于3个，视作无效</p>
<h3 id="缩放函数"><a href="#缩放函数" class="headerlink" title="缩放函数"></a>缩放函数</h3><p>缩放函数把元素放大或缩小，值始终为没有单位的正数</p>
<p><code>scaleX() scaleY() scaleZ()</code></p>
<p>赋值当作乘数，但缩放值不能为百分数</p>
<p>如果想在两个轴上同时缩放，可以使用<code>scale()</code>，第一个值是x，第二个值是y，如果只提供一个值，视作两个值相等</p>
<p><code>scaleZ()</code>仅在z轴上缩放，需要元素具有一定的深度，如沿x，y轴旋转</p>
<p><code>scale3d()</code>可以在三个轴方向缩放，不足三个值同样视为无效</p>
<h3 id="旋转函数"><a href="#旋转函数" class="headerlink" title="旋转函数"></a>旋转函数</h3><p><code>rotate() rotateX() rotateY() rotateZ()</code></p>
<p>只接受一种值，即角度（deg grad rad turn）,当不使用动画时，如果角度超过了常规范围，将转换为常规范围内的值</p>
<p><code>rotate</code>使用的是2d旋转，和<code>rotateZ()</code>功能相同</p>
<p><code>rotateX()</code>沿x轴旋转，<code>rotateY()</code>沿y轴旋转，使元素倾斜</p>
<p><code>rotate3d()</code>可以在3d空间内旋转元素，前三个值是xyz轴分量，第四个值是旋转角度</p>
<p>绕两个轴旋转和在绕3d空间中的向量旋转是有区别的</p>
<h3 id="倾斜函数"><a href="#倾斜函数" class="headerlink" title="倾斜函数"></a>倾斜函数</h3><p><code>skewX() skewY()</code>值为角度，z轴方向不允许倾斜</p>
<p><code>skew(a,b)</code>通过矩阵运算[ax,ay]实施2d倾斜，与分别设置的效果有所不同</p>
<h3 id="视域函数"><a href="#视域函数" class="headerlink" title="视域函数"></a>视域函数</h3><p>视域为元素赋予先后深度</p>
<p>使用<code>perspective(&lt;length&gt;)</code>设置</p>
<p>小于200px的值特别失真，2000px以上的值失真“特别温和”，500px-100px值产生“适中的视域”</p>
<p><code>perspective</code>函数在变形函数列表中的位置十分重要，一般将其放在首位</p>
<h3 id="矩阵函数"><a href="#矩阵函数" class="headerlink" title="矩阵函数"></a>矩阵函数</h3><p><code>martrix()</code>函数通过6个值确定的变换矩阵指定2d空间内的变形</p>
<p><code>martrix3d()</code>指定3d变形</p>
<p>可以使用多个变形函数达到matrix函数的最终状态</p>
<h2 id="其他变形属性"><a href="#其他变形属性" class="headerlink" title="其他变形属性"></a>其他变形属性</h2><h3 id="移动原点"><a href="#移动原点" class="headerlink" title="移动原点"></a>移动原点</h3><p>不设置移动原点，默认的移动原点是元素的绝对中心</p>
<p>可以使用<code>transform-origin</code>修改</p>
<p><code>transform-origin</code>的值为2个或三个关键字，用于指定相对于哪个点变形，第一个值指定横向，第二个值指定纵向，可选的第三个值是z轴长度。前两个值可以使用top和right，也可以使用百分数等，z轴只能使用长度</p>
<p>长度值设置的是距元素左上角的距离</p>
<p>百分数根据元素尺寸计算</p>
<h3 id="选择3D变形方式"><a href="#选择3D变形方式" class="headerlink" title="选择3D变形方式"></a>选择3D变形方式</h3><p>通过<code>transform-style:preserve-3d</code>修改3D变形方式</p>
<p>然而这样设定的3D变形方式可能被其他属性覆盖，因为那些属性必须要元素扁平才能发挥作用</p>
<p>如果修改CSS属性时发现3d元素被拍扁了，可能是</p>
<ul>
<li>overflow</li>
<li>filter</li>
<li>clip</li>
<li>clip-path</li>
<li>mask-image</li>
<li>mask-border-source</li>
<li>mix-blend-mode</li>
</ul>
<p>中的某些值发生了改变</p>
<h3 id="修改视域"><a href="#修改视域" class="headerlink" title="修改视域"></a>修改视域</h3><h4 id="定义视距"><a href="#定义视距" class="headerlink" title="定义视距"></a>定义视距</h4><p>使用perspective修改视域</p>
<p><code>perspective</code>与<code>perspective()</code>的区别：</p>
<p><code>perspective</code>运用到当前元素的所有子元素中，而<code>perspective()</code>只运用到当前元素上</p>
<p>多数时候应该使用perspective</p>
<h4 id="移动视距原点"><a href="#移动视距原点" class="headerlink" title="移动视距原点"></a>移动视距原点</h4><p>使用<code>perspective-origin</code>修改</p>
<p>初始值：50% 50%</p>
<p>和<code>transform-origin</code>用法类似</p>
<p><code>transform-origin</code>定义在哪点变形，<code>perspective-origin</code>定义视线汇聚于哪一点</p>
<h3 id="处理背面"><a href="#处理背面" class="headerlink" title="处理背面"></a>处理背面</h3><p>由<code>backface-visibility</code>属性决定</p>
<p>值：visible&#x2F;hidden</p>
<p>该属性仅仅决定当背面朝向我们时是否渲染背面</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>变形在二维和三维空间中改变元素形态，可以制作出很多引人注目的效果，利用3d变形还可以创造出交互界面，为设计开辟了新天地</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>css中position</title>
    <url>/2022/08/03/%E5%AE%9A%E4%BD%8D/</url>
    <content><![CDATA[<h1 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h1><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>static:正常生成元素框</p>
<p>relative：元素框偏移一定距离，所占空间不变</p>
<p>absolute：元素框完全从文档流中移除，相对容纳块定位</p>
<p>fixed：行为类似absolute，容纳块是视区自身</p>
<p>sticky：触发粘滞条件时，相当于相对容纳块绝对定位；触发粘滞的条件失效后，回到最初位置</p>
<h3 id="容纳块"><a href="#容纳块" class="headerlink" title="容纳块"></a>容纳块</h3><p>一般来说，容纳块指包含另一个元素的框体</p>
<p>对定位元素：</p>
<p>relative或static：容纳块由最近的祖辈元素框体的内容边界划定</p>
<p>absolute：容纳块是最近的不是static的祖辈元素</p>
<ul>
<li>块级元素：内边距边界</li>
<li>行内元素：内容边界</li>
<li>没有：初始容纳块</li>
</ul>
<p>定位元素可能位于容纳块之外</p>
<h3 id="偏移属性"><a href="#偏移属性" class="headerlink" title="偏移属性"></a>偏移属性</h3><p>top</p>
<p>bottom</p>
<p>left</p>
<p>right</p>
<h3 id="限制宽高"><a href="#限制宽高" class="headerlink" title="限制宽高"></a>限制宽高</h3><p>min-height,min-width:限制最小</p>
<p>max-width,max-height:限制最大</p>
<h3 id="内容溢出"><a href="#内容溢出" class="headerlink" title="内容溢出"></a>内容溢出</h3><p>某个元素在内容里放不下：设置overflow属性</p>
<p>visible：超出内容的部分可见</p>
<p>hidden：超出部分不可见</p>
<p>scroll：超出部分会隐藏，但可以通过滚动条查看</p>
<p>auto：让用户代理自己决定使用哪种方式，在必要时使用滚动条</p>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p><code>visibility:visible/hidden/collapse</code></p>
<p><code>visible</code>:可见</p>
<p><code>hidden</code>:隐藏（仍会占据空间，但不显示，相当于完全透明）</p>
<p><code>collapse</code>:用于渲染表格，在渲染非表格元素时和hidden一致</p>
<h3 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h3><p>如果文档能滚动，绝对定位元素也会随之滚动</p>
<h5 id="自动确定边界"><a href="#自动确定边界" class="headerlink" title="自动确定边界"></a>自动确定边界</h5><p>将绝对定位元素除bottom外的某个偏移属性值设置为auto将得到一种特殊的行为</p>
<p>即元素的位置会成为静态状态时的位置（即在常规文档流中的位置）</p>
<p>将left和right同时设成auto会让绝对定位元素水平居中</p>
<p>当元素各种属性值加起来不足容纳块的长度时（过约束），会对auto的值重新计算，当无auto时，会重新计算left或right的值</p>
<p>如果属性的值导致过约束，top将永远<strong>不被</strong>忽略</p>
<h3 id="Z-index"><a href="#Z-index" class="headerlink" title="Z-index"></a>Z-index</h3><p>z-index值越大，元素离读者越近</p>
<p>设立z-index的父元素的子元素的位置是相对于父元素的，无论子元素设置多小的z-index值都会显示在父元素上方</p>
<p>z-index：auto可视为z-index：0</p>
<h3 id="固定定位"><a href="#固定定位" class="headerlink" title="固定定位"></a>固定定位</h3><p>与绝对定位类似，但容纳块是整个视区</p>
<h3 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h3><p>相对定位使用偏移属性移动元素</p>
<p>如<code>bottom:20px</code>将把元素向上平移20px</p>
<p>在相对定位中，元素从常规的位置移开了，但其占据的空间没有消失</p>
<p>相对定位的元素同样可能会重叠</p>
<h3 id="粘滞定位"><a href="#粘滞定位" class="headerlink" title="粘滞定位"></a>粘滞定位</h3><p>粘滞定位元素通过设置偏移属性确定相对容纳块的粘滞定位矩形</p>
<p>如<code>.h2 &#123;position:stick;top:2em;bottom:auto;left:auto;right:auto&#125;</code></p>
<p>就设置了一个到达顶部就被粘滞的举行，想要让矩形在某个方向被粘滞，只需要将那个方向不设成auto即可</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>借助定位可以随意移动元素，这是常规文档流难以企及的。通过z轴确定叠放次序，加上各种溢出模式，定位依旧有用武之力</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>css中的flex布局</title>
    <url>/2022/08/03/%E5%BC%B9%E6%80%A7%E7%9B%92%E5%B8%83%E5%B1%80%EF%BC%9Aflex/</url>
    <content><![CDATA[<h1 id="弹性盒布局：flex"><a href="#弹性盒布局：flex" class="headerlink" title="弹性盒布局：flex"></a>弹性盒布局：flex</h1><h3 id="弹性盒基础"><a href="#弹性盒基础" class="headerlink" title="弹性盒基础"></a>弹性盒基础</h3><p>使用弹性盒后内容呈现顺序不再受到源码顺序的限制</p>
<p>声明<code>display:flex</code>或<code>display:inline-flex</code>即可激活弹性盒布局，然后该元素被称为弹性容器，其子元素被成为弹性元素</p>
<p>两种的区别是前者生成一个块级框，子元素在其中布局</p>
<p>后者生成一个行内级框，子元素在其中布局</p>
<p>把一个元素设为弹性容器后，只有直接子元素使用弹性盒布局</p>
<h3 id="flex-direction属性"><a href="#flex-direction属性" class="headerlink" title="flex-direction属性"></a>flex-direction属性</h3><p>设置布局的方向，指定在弹性容器中如何摆放弹性元素</p>
<p>可使用：</p>
<p><code>row</code>:横向</p>
<p><code>row-reverse</code>:横向相反</p>
<p><code>column</code>:竖向</p>
<p><code>column-reverse</code>:竖向相反</p>
<p>如果改变了书写模式，例如规定书写模式是竖向书写（如从上向下），则row表示从上到下</p>
<p>column表示从右向左</p>
<h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><p>默认情况下元素不会换行，有可能从容器框的边界溢出</p>
<p>设置flex-wrap属性允许弹性元素换行</p>
<p><code>flex-wrap:nowrap/wrap/wrap-reverse</code>(默认<code>nowrap</code>)</p>
<p>默认情况下：无论多少元素都在一行显示</p>
<p>warp：超出的部分换行到之后</p>
<p>wrap-reverse:超出部分换行到之前</p>
<h3 id="定义弹性流"><a href="#定义弹性流" class="headerlink" title="定义弹性流"></a>定义弹性流</h3><p>flex-flow：确定主轴和垂轴方向，以及元素是否换行</p>
<p><code>flex-flow:&lt;flex-direction&gt; &lt;flex-wrap&gt;</code></p>
<p>弹性元素沿主轴排列，沿垂轴添加（如果换行的话）</p>
<p>主轴一定和垂轴垂直</p>
<h3 id="调整内容"><a href="#调整内容" class="headerlink" title="调整内容"></a>调整内容</h3><p><code>justify-content</code>属性指明在弹性容器的主轴上如何分布各行里的弹性元素</p>
<p>应用于弹性容器上而不是弹性元素上</p>
<p><code>justify-content:flex-start/flex-end/center/space-between/space-around/space-evenly</code></p>
<p>默认flex-start</p>
<p><code>flex-start</code>:元素沿主轴起边排列</p>
<p><code>flex-end</code>:元素沿主轴终边排列</p>
<p><code>center</code>:元素视为一个整体排列在主轴中央</p>
<p><code>space-between</code>:把第一个元素放在主轴起边，最后一个元素放在主轴终边，中间的元素等间距排列</p>
<p><code>space-around</code>:让元素左边和右边分出等同的距离（第一个元素距离主轴起边的距离会是每两个元素之间距离的一半）</p>
<p><code>space-evenly</code>:与space-around类似但第一个元素距离主轴起边的距离与每两个元素之间距离相等</p>
<p>justify-content还会影响元素的溢出方式</p>
<h3 id="对齐元素"><a href="#对齐元素" class="headerlink" title="对齐元素"></a>对齐元素</h3><p>justify-content定义主轴方向的对齐方式，而align-items定义垂轴方向的对齐方式</p>
<p>align-items同样应用于容器上</p>
<p><code>align-items:flex-start/flex-end/center/baseline/stretch</code></p>
<p>初始值：stretch</p>
<p>stretch:可拉伸：即所有可拉伸的弹性元素将与所在行最高或最宽的弹性元素一样高或一样宽</p>
<p>如果显示设置了元素的垂轴方向尺寸，元素将不可拉伸</p>
<p>拉伸后的元素尺寸包含外边距的长度</p>
<p>弹性元素行的高或宽是正好能够放下弹性元素的尺寸</p>
<p>baseline：基线对齐，基线是文本第一行文字的底部，受到字号影响</p>
<h3 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h3><p>align-self设置的值会覆盖align-items的值</p>
<p>取值与align-item相同</p>
<h3 id="对齐内容"><a href="#对齐内容" class="headerlink" title="对齐内容"></a>对齐内容</h3><p>align-content属性指定弹性容器中垂轴方向上的额外空间如何分配到弹性元素行之间和周围</p>
<p>取值与align-items相同</p>
<p>如果只有一行，align-content对内容没有影响</p>
<h3 id="弹性元素"><a href="#弹性元素" class="headerlink" title="弹性元素"></a>弹性元素</h3><p>float和clear对弹性元素不起作用</p>
<p>变成弹性元素后，只要没有绝对定位，就是块级的</p>
<p>没有被标签包裹的文本是匿名弹性元素，不能直接选择，只能从弹性容器上继承样式</p>
<p>绝对定位的弹性元素不再参与弹性布局，它们不在文档流中，但会受到弹性容器的样式影响，先确定在弹性容器中的位置再进行position</p>
<p>弹性元素的min-width默认为auto，如果不想溢出可以设置为0，元素会被压缩</p>
<h3 id="flex属性"><a href="#flex属性" class="headerlink" title="flex属性"></a>flex属性</h3><p>flex属性是flex-grow，flex-shrink和flex-basis的简写形式（弹性增长因子，弹性缩减因子和弹性基准）</p>
<p>默认值是0，1，auto</p>
<p>flex属性指定确定弹性长度的各要素，弹性元素所在的框体尺寸由flex决定</p>
<p>弹性基准指明如何应用弹性增长因子和弹性缩减因子</p>
<h4 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h4><p>定义有多余空间时是否允许弹性元素增大，以及有多余空间时，相对于同辈弹性元素会以什么比例增大</p>
<p><strong>不鼓励通过flex-grow定义增长因子，只建议在flex简写中指定增长因子</strong></p>
<p>flex-grow的值始终是正数，小于零无效</p>
<p>flex-grow的值用于计算比例，若只有一个元素设置了flex-grow，则剩余的所有空间都被它占有，若有多个元素设置了，则会通过设置值之间的比例确定各自所占剩余空间的比例</p>
<p>如果flex属性没有设定增长因子和缩减因子，flex-grow默认为1，如果flex和flex-grow都没有被声明出来，默认为0</p>
<p>使用flex声明flex-grow属性和单独使用flex-grow声明的区别：</p>
<p>flex声明将把所有空间按比例分配，而flex-grow声明只会将余下空间按比例分配</p>
<h4 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h4><p><strong>同样只建议在flex简写属性中声明</strong></p>
<p>弹性缩减因子定义空间不足以放下所有弹性元素时，当前元素相对于其他同辈弹性元素将缩小多少</p>
<p>缩减因子默认为1</p>
<p>计算方法与grow类似：</p>
<p>如果设置shrink为1，1，3，长度均为300，容纳器长度为750</p>
<p>那么元素将分别缩小：30，30，90</p>
<p>如果弹性元素中的内容将要超出容器大小，且不能换行和缩小，弹性元素将无法缩小</p>
<p>缩减因子为任何正数都会导致内容换行，换行次数和缩减因子比例差不多</p>
<h4 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h4><p>定义弹性元素的初始或默认尺寸，即根据增长因子或缩减因子分配空间前，弹性元素的大小</p>
<p>如果提前声明了width和height，值为width和height，如果没声明，值为content</p>
<h5 id="content"><a href="#content" class="headerlink" title="content"></a>content</h5><p>在支持的环境中，使用content的basis值为弹性元素中内容的尺寸，即最长一行内容或最宽的媒体对象在主轴上的长度</p>
<p>弹性基准会覆盖元素的width和height，但不会忽略mid-width和mid-height</p>
<h5 id="auto与0"><a href="#auto与0" class="headerlink" title="auto与0"></a>auto与0</h5><p>auto下会根据grow或shrink决定<strong>剩下</strong>的区域的划分</p>
<p>0决定<strong>所有</strong>区域的划分</p>
<h3 id="flex简写模式"><a href="#flex简写模式" class="headerlink" title="flex简写模式"></a>flex简写模式</h3><p>如果只给flex一个值(数字)，实际上声明的是flex-grow</p>
<p><code>flex: initial</code>&#x3D;<code>flex:0 1 auto</code></p>
<p><code>flex:auto</code>&#x3D;<code>flex:1 1 auto</code></p>
<p><code>flex:none</code>&#x3D;<code>flex:0 0 auto</code></p>
<p><code>flex:1</code>&#x3D;<code>flex:1,0,auto</code></p>
<h3 id="order属性"><a href="#order属性" class="headerlink" title="order属性"></a>order属性</h3><p>order属性可以改变元素的出现顺序，但读取代码的顺序是不变的</p>
<p>默认值是0，负数会先出现，正数会后出现</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>弹性盒布局的效果用float也可以实现，但比float方便得多。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>css中的grid</title>
    <url>/2022/08/04/%E6%A0%85%E6%A0%BC%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h1 id="栅格布局"><a href="#栅格布局" class="headerlink" title="栅格布局"></a>栅格布局</h1><h3 id="创建栅格容器"><a href="#创建栅格容器" class="headerlink" title="创建栅格容器"></a>创建栅格容器</h3><p><code>display:grid</code>:创建常规栅格</p>
<p><code>display:inline-grid</code>:创建行内栅格</p>
<p>常规栅格与块级元素仍有区别：</p>
<p>浮动元素不会打乱栅格容器，栅格不会移动到浮动元素下方</p>
<p>栅格容器的外边距不与其后代的外边距折叠</p>
<ul>
<li><p>栅格容器上所有column属性都被忽略</p>
</li>
<li><p>栅格容器没有::first-line和::first-letter伪元素</p>
</li>
<li><p>栅格元素的float和clear属性会被忽略</p>
</li>
<li><p>vertical-align属性对栅格元素不起作用</p>
</li>
<li><p>如果设置的是inline-grid，但目标元素是浮动的或者绝对定位的，inline-grid将变成grid</p>
</li>
</ul>
<h3 id="栅格术语"><a href="#栅格术语" class="headerlink" title="栅格术语"></a>栅格术语</h3><ul>
<li>栅格元素：通常是栅格容器的子元素或者其中的匿名文本，参与栅格布局</li>
<li>栅格轨道：两条相邻栅格线之间夹住的整个区域（栅格列，栅格行）</li>
<li>栅格单元：四条栅格线确定的区域，内部没有其他栅格线（最小单元格）</li>
<li>栅格区域：任意四条栅格线确定的区域，最小的栅格区域是栅格单元</li>
</ul>
<h3 id="放置栅格线"><a href="#放置栅格线" class="headerlink" title="放置栅格线"></a>放置栅格线</h3><p>使用<code>grid-template-rows</code>和<code>grid-template-columns</code>定义栅格模板中的栅格线</p>
<h4 id="宽度固定的栅格轨道"><a href="#宽度固定的栅格轨道" class="headerlink" title="宽度固定的栅格轨道"></a>宽度固定的栅格轨道</h4><p>宽度固定指栅格线之间的距离不随着栅格轨道中内容的变化而变化，百分数也算宽度固定</p>
<p>如<code>grid-template-columns:100px 50% 200px</code>;</p>
<p>为栅格线命名：使用中括号，如：</p>
<p><code>grid-template-columns:[start]100px[first] 50%[second] 200px[end]</code>为四条栅格线分别命名</p>
<p>名称可以重用</p>
<p>设置百分数时可能会使内容超出容器，可以使用设置极值的方式解决</p>
<p>设定极值<code>minmax(a,b)</code>指明行的高度不能小于一个值也不能大于一个值</p>
<p>如<code>grid-template-columns:[start]100px[first] minmax(3em,50%)[second] 200px[end]</code>规定列宽不能大于50%也不能小于3个字号</p>
<p>使用设定极值时浏览器会自动计算让其在范围内把剩余空间尽量铺满</p>
<p>除了使用minmax()还可以使用calc()计算</p>
<h4 id="弹性栅格轨道"><a href="#弹性栅格轨道" class="headerlink" title="弹性栅格轨道"></a>弹性栅格轨道</h4><p>弹性栅格轨道的尺寸基于整个轨道中的具体内容而定</p>
<p>份数单位：fr</p>
<p><code>grid-template-columns:1fr 1fr 1fr 1fr</code>&#x3D;<code>grid-template-columns:25% 25% 25% 25%</code></p>
<p>除了替代百分数外，fr还可以实现部分弹性伸缩</p>
<p>例如：<code>grid-template-columns:100px 1fr 100px</code></p>
<p>容器宽度大于200px时，剩余部分会全被分给1fr对应的部分</p>
<p>minmax()设定的最小值不允许以fr为单位，但最大值可以</p>
<h5 id="min-content和max-content"><a href="#min-content和max-content" class="headerlink" title="min-content和max-content"></a>min-content和max-content</h5><p>max-content:占据内容所需的最大空间&#x2F;内容尽量宽，以免换行</p>
<p>min-content:尽量少占据空间，能够显示出内容即可</p>
<p>这两个属性会应用到整个栅格轨道之上，如果把一列的尺寸设置成max-content,整列的宽度都与列中最宽的内容一样</p>
<p>如果在minmax中设置<code>minmax(0,max-content)</code>；那么将在确保不超出弹性容器的基础上尽量向max的值靠拢</p>
<p>如果将列和行都设置为max-content，浏览器先解析列再解析行，和只设置列是一样的</p>
<h5 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h5><p>auto用作最小值时，视作栅格元素的最小尺寸（由mid-width和mid-height定义）</p>
<p>作最大值时，作用等同于max-content</p>
<p>任何地方都可以使用auto，要么作最小值，要么作最大值，但<strong>尽量避免使用auto</strong></p>
<h5 id="fit-content"><a href="#fit-content" class="headerlink" title="fit-content"></a>fit-content</h5><p><code>fit-content(argument)=minmax(argument&gt;min-content?argument:min-content , argument&lt;max-content?arguement:max-content);</code></p>
<p>使用fit-content,内容不多时，轨道将缩小为最小内容尺寸，内容较多时，能为轨道尺寸设置一个上限</p>
<h4 id="重复栅格线"><a href="#重复栅格线" class="headerlink" title="重复栅格线"></a>重复栅格线</h4><p>使用repeat（）设置重复栅格线</p>
<p>例如：<code>grid-template-columns:repeat(10,5em)</code>将创建10个5字号轨道宽度的列轨道</p>
<p>也可以重复固定模式的列轨道</p>
<p>如：<code>grid-template-columns:repeat(10,5em 1fr 1fr)</code>将创建列结构为5em，1fr，1fr，然后重复10次，也就是创建了30个列轨道</p>
<p>如果想额外增加列，可以：<code>grid-template-columns:repeat(10,5em 1fr 1fr) 5em</code>在重复结束后加上一个列轨道</p>
<p>repeat（）中几乎可以使用任意值，但不能在重复中嵌套重复</p>
<h5 id="自动填充轨道"><a href="#自动填充轨道" class="headerlink" title="自动填充轨道"></a>自动填充轨道</h5><p>如果想让一直重复：<code>repeat(auto-fill,5em)</code>将会把5em的宽度一直重复到放不下为止</p>
<p>在一个模板里只能有一个自动重复的模式</p>
<p>固定数量的重复模式可以与自动填充的轨道结合到一起使用</p>
<p>使用auto-fill，没有元素的单元格会得到保留</p>
<p>但如果使用auto-fit，则会剔除</p>
<h4 id="栅格区域"><a href="#栅格区域" class="headerlink" title="栅格区域"></a>栅格区域</h4><p><code>grid-template-areas:none/String</code></p>
<p>使用字符串作为标识符，合并相同字符串</p>
<p>如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">grid-template-areas</span>:</span><br><span class="line"><span class="string">&quot;h h h h&quot;</span></span><br><span class="line"><span class="string">&quot;b c c c&quot;</span></span><br><span class="line"><span class="string">&quot;f f d d&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>第一行只有一列，第二行两列，宽度1：3，第三行同理</p>
<p>只能合并矩形区域，不能合并非矩形区域，形状太复杂会导致模板失效</p>
<p>通过area为区域标记名称，区域的栅格线实际上也已经隐式确定了名称</p>
<p>为了与内容匹配可以设置元素的grid-area</p>
<h3 id="在栅格中添加元素"><a href="#在栅格中添加元素" class="headerlink" title="在栅格中添加元素"></a>在栅格中添加元素</h3><p>可以引用栅格线，也可以引用栅格区域</p>
<h4 id="使用行线和列线"><a href="#使用行线和列线" class="headerlink" title="使用行线和列线"></a>使用行线和列线</h4><p><code>grid-row-start</code>:规定元素起始的行线（栅格线）</p>
<p><code>grid-row-end</code>:规定元素在那条行线结束</p>
<p><code>grid-column-start</code>和<code>grid-column-end</code>同理</p>
<p>如果省略的结束线，则自动使用起始线的下一条线结束，这等同于</p>
<p><code>grid-column-end:span 1 </code>或<code>grid-column-end: span</code></p>
<p>span后面的数字表示”跨越指定数目的栅格轨道“，只能用正整数</p>
<p>span既可以用于开始线也可以用于结束线。用于开始线时，意思是”从结束线开始，向开始方向计数“</p>
<p>通过显式定义的栅格线编号可以为负数，代表从后往前数第|n|个栅格线</p>
<p>栅格线编号除了通过数字引用也可以通过声明过的命名调用</p>
<p>还可以通过<code>grid-template-area</code>中定义的名称调用</p>
<h4 id="行和列的简写"><a href="#行和列的简写" class="headerlink" title="行和列的简写"></a>行和列的简写</h4><p>使用<code>grid-row</code>和<code>grid-column</code>可以简化声明开始和结束栅格线的过程</p>
<p>如：<code>grid-row:1/3</code></p>
<p>以斜线分割的两部分中，前半部分定义开始栅格线，后半部分定义结束栅格线</p>
<p>如果没有斜杆，定义的是开始栅格线，结束栅格线的位置却决于开始栅格线</p>
<ul>
<li>如果开始栅格线是名称，结束栅格线就是下一条同名栅格线</li>
<li>如果只提供一个数字，下一个栅格线是auto</li>
</ul>
<h4 id="隐式栅格"><a href="#隐式栅格" class="headerlink" title="隐式栅格"></a>隐式栅格</h4><p>如果行线只显示定义了三条，却进行了类似<code>grid-row:1/4</code>这样的声明，浏览器会再创建一条行线，这条栅格线和由此产生的栅格轨道是隐式栅格的一部分</p>
<p>span是从显示栅格内部开始计数的，但不一定在显示栅格内部结束</p>
<h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>如果开始线在结束线后面，会将两者对调</p>
<p>如果开始线和结束线都为跨度，忽略结束线并将值设置成auto</p>
<h4 id="使用区域"><a href="#使用区域" class="headerlink" title="使用区域"></a>使用区域</h4><p>将预先声明的<code>grid-template-areas</code>的标识符通过<code>grid-area</code>赋给元素</p>
<p>grid-area也可以直接使用</p>
<p><code>grid-area:row-start/column-start/row-end/column-end</code>根据这种规范来确定区域</p>
<h4 id="栅格元素重叠"><a href="#栅格元素重叠" class="headerlink" title="栅格元素重叠"></a>栅格元素重叠</h4><p>栅格元素是有可能重叠的</p>
<h3 id="栅格流"><a href="#栅格流" class="headerlink" title="栅格流"></a>栅格流</h3><p>栅格流主要分为两种模式：行优先和列优先，二者都可以通过密集流增强</p>
<p>通过grid-auto-flow设置栅格流</p>
<p><code>grid-auto-flow:row/column||dense</code>默认是row</p>
<p>栅格流放置的实际上是栅格区域，然后再把栅格元素放置到栅格区域中</p>
<p>行流和列流的工作方式是：如果下一个单元格可以放下对应的元素则放下，如果不能则跳过此单元格保证顺序。</p>
<p>如果想让元素尽量堆满单元格而不考虑顺序，可以在<code>grid-auto-flow</code>中加入dense</p>
<h3 id="自动增加栅格线"><a href="#自动增加栅格线" class="headerlink" title="自动增加栅格线"></a>自动增加栅格线</h3><p>如果有元素超出了声明的行&#x2F;列，系统会自动增加栅格线</p>
<p>一般来说，自动增加的栅格线对应的是最小尺寸，如果需要修改最小尺寸，可以使用</p>
<p><code>grid-auto-columns,grid-auto-rpws</code></p>
<p>可以为其添加一个属性值（极值）来为自动添加的行规范尺寸</p>
<h3 id="栏距"><a href="#栏距" class="headerlink" title="栏距"></a>栏距</h3><p>栏距由row-gap和column-gap设置，只能为非负数，不能为百分数或fr</p>
<p>简写是grid-gap</p>
<h3 id="栅格元素与盒模型"><a href="#栅格元素与盒模型" class="headerlink" title="栅格元素与盒模型"></a>栅格元素与盒模型</h3><p>当未为元素设置width和height时，设置正外边距会让元素向中心收缩，负外边距会向周围扩张</p>
<p>如果元素尺寸设置了，那么外边距将被覆盖</p>
<p>元素外边距不会影响栅格轨道尺寸的计算</p>
<p>如果栅格元素声明了绝对定位：对应的栅格区域充当容纳块和定位上下文</p>
<h3 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h3><p><code>justify-self</code>和<code>align-self</code>:控制元素在对应栅格区域内的横向&#x2F;纵向对齐方式</p>
<p><code>justify-item</code>和<code>align-item</code>:控制栅格容器内所有元素的横向&#x2F;纵向对齐方式</p>
<p><code>justify-content</code>和<code>align-content</code>:控制栅格的对齐属性，为栅格分配多余的空间事实上是调整栅格的栏距尺寸</p>
<h3 id="分层和排序"><a href="#分层和排序" class="headerlink" title="分层和排序"></a>分层和排序</h3><p>元素若重叠，分层可以使用z-index</p>
<p>若想控制元素出现的顺序，同样可以使用order，只改变视觉顺序不改变阅读源码顺序</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>栅格布局内容繁杂，引入了大量新特性，需要时常温故知新</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器的工作原理</title>
    <url>/2022/08/03/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%88%E7%AE%80%E6%98%93%E7%89%88%EF%BC%89/</url>
    <content><![CDATA[<h3 id="浏览器的工作原理（简易版）"><a href="#浏览器的工作原理（简易版）" class="headerlink" title="浏览器的工作原理（简易版）"></a>浏览器的工作原理（简易版）</h3><p>输入url后</p>
<ol>
<li><p>浏览器进行dns查找，把域名转换为ip地址，根据ip地址找到对应的服务器</p>
</li>
<li><p>浏览器通过TCP握手机制跟服务器建立连接，如果为https还有一步TLS握手</p>
</li>
<li><p>浏览器发起http&#x2F;https请求，获取响应。在浏览器接收响应时，受制于TCP连接的性质，浏览器先收到前14kb的数据，后续才会慢慢增加传输速度下载其他文件</p>
</li>
<li><p>收到html代码后，浏览器开始渲染网页</p>
<ol>
<li><p>解析html代码，构建DOM树（HTML文档在浏览器中的对象表示）</p>
<p>浏览器在解析HTML时顺序执行并且只有一个主线程负责，遇到script标签会先执行js代码，暂停解析html代码。对于图片，css文件，设置了defer&#x2F;async的script标签不会影响html解析，会异步加载</p>
<p>浏览器具有预扫描线程，扫描html代码，提前把css文件，字体，js文件下载下来，不影响主线程</p>
<p><img src="/image/image1.png" alt="dom树"></p>
</li>
<li><p>构建CSSOM树</p>
<p><img src="/image/image2.png" alt="CSSOM树"></p>
</li>
<li><p>合并DOM和CSSOM，形成渲染树</p>
<p><img src="/image/image3.png" alt="渲染树"></p>
</li>
<li><p>布局</p>
<p>对于图片这样的结点，如果没有指定宽高，会先忽略大小。图片下载完成后，浏览器根据图片的大小重新计算受影响的结点的宽高，这种方法被称为回流（reflow）</p>
</li>
<li><p>绘制</p>
<p>第一次布局之后，浏览器会把结点和结点的样式绘制在屏幕上，要求过程快速</p>
<p>如果布局发生回流，浏览器会发生重绘，把变化的布局重新绘制在屏幕上</p>
<p>绘制期间可能会有组合发生（产生了新的图层）,浏览器需要把图层组合起来，按正确的图层顺序渲染，发生了重绘也会导致重新组合</p>
<p>上述五步完成后，设置了defer&#x2F;async的script中的内容，网页加载完成</p>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>css中的滤镜，混合，遮罩，裁剪</title>
    <url>/2022/08/03/%E6%BB%A4%E9%95%9C%E3%80%81%E6%B7%B7%E5%90%88%E3%80%81%E8%A3%81%E5%89%AA%E5%92%8C%E9%81%AE%E7%BD%A9/</url>
    <content><![CDATA[<h1 id="滤镜、混合、裁剪和遮罩"><a href="#滤镜、混合、裁剪和遮罩" class="headerlink" title="滤镜、混合、裁剪和遮罩"></a>滤镜、混合、裁剪和遮罩</h1><h2 id="CSS滤镜"><a href="#CSS滤镜" class="headerlink" title="CSS滤镜"></a>CSS滤镜</h2><p><code>filter:none/blur()/brightness()/contrast()/drop-shadow()/grayscale()/</code></p>
<p><code>hue-rotate()/invert()/opacity()/sepia()/saturate()/url()</code></p>
<p>滤镜函数可以有多个，之间以空格分隔，各滤镜按列出的顺序应用</p>
<h3 id="基本滤镜"><a href="#基本滤镜" class="headerlink" title="基本滤镜"></a>基本滤镜</h3><p><code>blur(&lt;length&gt;)</code>使用高斯模糊对元素进行处理，标准偏差由length的值确定，设为0时不做模糊处理，不能为负值</p>
<p><code>opacity(&lt;number&gt;|&lt;percentage&gt;)</code>把透明度应用到元素上，与opacity属性十分相似，0表示完全透明，1或100%不做处理，不能使用负值</p>
<p><code>drop-shadow(&lt;length&gt;&#123;2,3&#125;&lt;color&gt;?)</code>长度和颜色的处理方式和box-shadow一样，如果不提供color，则使用元素的color属性决定阴影颜色</p>
<h3 id="颜色滤镜"><a href="#颜色滤镜" class="headerlink" title="颜色滤镜"></a>颜色滤镜</h3><p><code>grayscale([&lt;length&gt;|&lt;percentage&gt;])</code>把元素颜色变为指定的灰阶，当为0时不变，值为1或100%时完全变灰</p>
<p><code>sepia([&lt;number|&lt;percentage&gt;])</code>把元素由原色变为墨色调，当为0时不变，值为1或100%时完全变褐色</p>
<p><code>invert([&lt;number|&lt;percentage&gt;])</code>把元素作反相处理，0时不变，1时完全反相，0.5时得到均匀的灰色</p>
<p><code>hue-rotate(&lt;angle&gt;)</code>在色轮上旋转色相，而饱和度和透明度不变，0deg时无变化，360deg时也没变化，也可以为负数，表示逆时针转动</p>
<h3 id="亮度，对比度，饱和度"><a href="#亮度，对比度，饱和度" class="headerlink" title="亮度，对比度，饱和度"></a>亮度，对比度，饱和度</h3><p><code>brightness([&lt;number|&lt;percentage&gt;])</code>调整亮度，0时为黑色，1时正常，大于1时变亮，最终可能会变为白色</p>
<p><code>contrast([&lt;number|&lt;percentage&gt;])</code>调整对比度，0时变为纯灰色，1时正常，大于1时对比度加大</p>
<p><code>saturate([&lt;number|&lt;percentage&gt;])</code>调整饱和度,值越大颜色越鲜艳，越小颜色越暗淡</p>
<h3 id="SVG滤镜"><a href="#SVG滤镜" class="headerlink" title="SVG滤镜"></a>SVG滤镜</h3><p><code>url()</code>可以使用这个函数指定在SVG中定义的滤镜，实现从外部引用滤镜</p>
<h2 id="合成和混合"><a href="#合成和混合" class="headerlink" title="合成和混合"></a>合成和混合</h2><p>使用<code>mix-bend-mode</code>属性设定</p>
<p><code>mix-bend-mode: normal/multiply/screen/overlay/darken/lighten/color-dodge</code></p>
<p><code>/color-burn/hard-light/soft-light/difference/exclusion/hue/saturation/color/luminosity</code></p>
<ul>
<li>应用<code>mix-bend-mode</code>的元素是前景</li>
<li>位于元素背后的是背着物</li>
<li>像素分量是某个像素的颜色分量</li>
</ul>
<h3 id="变暗，变亮，差值和排除"><a href="#变暗，变亮，差值和排除" class="headerlink" title="变暗，变亮，差值和排除"></a>变暗，变亮，差值和排除</h3><p><code>darken</code>:前景中每个像素与背着物每个像素比较，取R,G,B中的较小值</p>
<p><code>lighten</code>:前景中每个像素与背着物每个像素比较，取R,G,B中的较大值</p>
<p><code>difference</code>:前景中每个像素与背着物每个像素比较，取R,G,B差的绝对值</p>
<p><code>exclusion</code>:<code>difference</code>的温和版本，所用公式是back+fore-|2 x back x fore|,back和fore是0到1之间的值</p>
<h3 id="正片叠底，滤色和叠加"><a href="#正片叠底，滤色和叠加" class="headerlink" title="正片叠底，滤色和叠加"></a>正片叠底，滤色和叠加</h3><p><code>multiply</code>:前景中每个像素分量与背着物中对应位置上的像素分量相乘。得到的结果与前景相比更暗</p>
<p><code>screen</code>:对前景和背着物中同一位置的像素分量作反相处理，相乘后再反相。得到的结果与前景相比更亮</p>
<p><code>overlay</code>:<code>multiply</code>和<code>screen</code>的综合运用，如果前景像素分量比50%暗，执行multiply，反之执行screen</p>
<h3 id="强光和柔光"><a href="#强光和柔光" class="headerlink" title="强光和柔光"></a>强光和柔光</h3><p><code>hard-light</code>: 与<code>overlay</code>相反，起决定作用的是背着物</p>
<p><code>soft-light</code>:<code>hard-light</code>的柔和版本，效果有所缓和</p>
<h3 id="颜色减淡和加深"><a href="#颜色减淡和加深" class="headerlink" title="颜色减淡和加深"></a>颜色减淡和加深</h3><p><code>color-dodge</code>:前景中各像素分量做反相处理，再拿背着物中对应的像素分量除以反相后的前景值。得到的结果是背着物变得更亮</p>
<p><code>color-bend</code>:与<code>color-dodge</code>的作用相反。背着物各像素分量做反相处理，反相后的背着物值除以没有修改的前景值，然后再反相。结果是背着物中越暗的像素，由前景中像素加深的程度越大</p>
<h3 id="色相，饱和度，明度和颜色"><a href="#色相，饱和度，明度和颜色" class="headerlink" title="色相，饱和度，明度和颜色"></a>色相，饱和度，明度和颜色</h3><p><code>hue</code>:把背着物中每一像素的明度和饱和度与前景中对应像素的色相角度合并</p>
<p><code>saturation</code>:把背着物中每一像素的色相角度和明度与前景中对应像素的饱和度合并</p>
<p><code>color</code>:把背着物中每一像素的明度与前景中对应像素的色相角度和饱和度合并</p>
<p><code>luminosity</code>:把背着物中每一像素的色相角度和饱和度与前景中的对应像素合并</p>
<h2 id="与背景混合"><a href="#与背景混合" class="headerlink" title="与背景混合"></a>与背景混合</h2><p><code>mix-blend-mode</code>只能将元素与背着物混合，当元素有多个背景图且背景图有重叠时，可以使用<code>background-blend-mode</code>属性</p>
<p>该属性的值与<code>mix-blend-mode</code>相同</p>
<h3 id="独立混合"><a href="#独立混合" class="headerlink" title="独立混合"></a>独立混合</h3><p>使用<code>isolation:isolate</code>将父元素独立出来从而影响子元素的混合方式</p>
<h2 id="裁剪和遮罩"><a href="#裁剪和遮罩" class="headerlink" title="裁剪和遮罩"></a>裁剪和遮罩</h2><p>如果只想把元素的一部分裁掉，可以使用<code>clip-path</code>属性</p>
<h3 id="裁剪形状"><a href="#裁剪形状" class="headerlink" title="裁剪形状"></a>裁剪形状</h3><p><code>inset()</code>:值为1到4个长度或百分数，定义距离范围框各边的偏移量,可以使用<code>round</code>关键字或另一组4个长度或百分比定义圆角</p>
<p><code>circle()</code>:只接受一个值定义圆的半径。在一或两个长度或百分数后使用at关键字定义圆心位置</p>
<p><code>ellispse()</code>值为两个长度或百分数或关键字定义椭圆在横轴或纵轴上的半径，在一或两个长度或百分数后使用at关键字定义圆心位置</p>
<p><code>polygon()</code>一系列以x和y坐标值（空格分开）定义多边形</p>
<h2 id="蒙版"><a href="#蒙版" class="headerlink" title="蒙版"></a>蒙版</h2><p>“蒙版的意思是”：位于形状内部的内容可见，而在形状外部的内容不可见</p>
<h3 id="定义蒙版"><a href="#定义蒙版" class="headerlink" title="定义蒙版"></a>定义蒙版</h3><p>指定用什么图像作为蒙版:<code>mask-image</code></p>
<h3 id="改变蒙版模式"><a href="#改变蒙版模式" class="headerlink" title="改变蒙版模式"></a>改变蒙版模式</h3><p>使用<code>mask-mode</code>改变蒙版模式</p>
<p><code>mask-mode:alpha/luminance/match-source</code></p>
<p><code>alpha</code>:通过alpha通道计算蒙版，<code>luminance</code>使用亮度计算蒙版</p>
<p><code>match-source</code>:是<code>alpha</code>和<code>luminance</code>的结合体</p>
<h3 id="调整蒙版尺寸和重复方式"><a href="#调整蒙版尺寸和重复方式" class="headerlink" title="调整蒙版尺寸和重复方式"></a>调整蒙版尺寸和重复方式</h3><p>使用<code>mask-size</code>调整蒙版尺寸</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>css中的过渡</title>
    <url>/2022/08/03/%E8%BF%87%E6%B8%A1/</url>
    <content><![CDATA[<h1 id="过渡"><a href="#过渡" class="headerlink" title="过渡"></a>过渡</h1><h2 id="定义过渡属性"><a href="#定义过渡属性" class="headerlink" title="定义过渡属性"></a>定义过渡属性</h2><p>CSS中使用四个属性定义过渡</p>
<p><code>transition-property</code></p>
<p><code>transition-duration</code></p>
<p><code>transition-timing-function</code></p>
<p><code>transition-delay</code></p>
<p>以及简写属性<code>transition</code></p>
<p>与过渡相关的属性加在非悬停状态上可以使开始和结束状态都实现过渡</p>
<p>而加在悬停状态上只会使开始时实现过渡，结束时瞬时切换</p>
<h3 id="设置使用过渡的属性transition-property"><a href="#设置使用过渡的属性transition-property" class="headerlink" title="设置使用过渡的属性transition-property"></a>设置使用过渡的属性<code>transition-property</code></h3><p>属性的值是以逗号分隔的属性列表，指使用过渡的属性</p>
<p>默认值为all，即所有支持动画的属性都采用过渡</p>
<p>不支持动画的属性会立即变为过渡后的值</p>
<p>如果需要对某些例外属性单独设置，应该把all设在首位，然后声明例外的属性如：</p>
<p><code>transition:all,color;  transition-duration:1s,2s;</code></p>
<p>值为none时禁用所有过渡，如果想禁用部分只能单独列出其他所有元素</p>
<h3 id="设置过渡持续时间transition-duration"><a href="#设置过渡持续时间transition-duration" class="headerlink" title="设置过渡持续时间transition-duration"></a>设置过渡持续时间<code>transition-duration</code></h3><p>值是以逗号分隔的长度列表，单位为s或ms，指定从一个状态过渡到另一个状态需要多久</p>
<p>如果在两个状态间来回切换但只设置了一个时间，则那么这个时间只在向那个状态过渡时起作用</p>
<p>即使值为零也要写成0s</p>
<p>如果设置的<code>transition-delay</code>时长不为正数，<code>transition-duration</code>又没有声明，不会触发<code>transitionend</code>事件，只要过渡总时间大于0s，就会触发<code>transitionend</code>事件</p>
<p>如果列表中有一个时间为负数，整个<code>transition-duration</code>属性都会失效</p>
<p>如果时间列表中时间数量与属性数量不一致，按照浏览器的规则处理</p>
<p>如果时间数多于属性数，忽略后面的属性</p>
<p>如果时间数少于属性数且恰好为2个，奇数属性使用第一个，偶数属性使用第二个</p>
<p>100ms到200ms的时间最佳</p>
<h3 id="调整过渡的内部时序transition-timing-function"><a href="#调整过渡的内部时序transition-timing-function" class="headerlink" title="调整过渡的内部时序transition-timing-function"></a>调整过渡的内部时序<code>transition-timing-function</code></h3><p>可以取的值有<code>ease,linear,ease-in,ease-out,ease-in-out,step-start,step-end,steps(n,start)(n是步进的次数),step(n,end),cubic-bezier(x1,y1,x2,y2)</code></p>
<h4 id="通过三次方贝塞尔函数定义"><a href="#通过三次方贝塞尔函数定义" class="headerlink" title="通过三次方贝塞尔函数定义"></a>通过三次方贝塞尔函数定义</h4><p><code>ease</code>慢速开始，中间很快，然后变慢，结尾特别慢</p>
<p><code>linear</code>整个过程匀速</p>
<p><code>ease-in</code>慢速开始，然后加速</p>
<p><code>ease-out</code>快速开始，然后慢速</p>
<p><code>ease-in-out</code>于ease类似，两端慢中间快，但两端不同速</p>
<p><code>cubic-bezier(x1,y1,x2,y2)</code>定义一个三次方贝塞尔函数</p>
<h4 id="通过步进时序函数定义"><a href="#通过步进时序函数定义" class="headerlink" title="通过步进时序函数定义"></a>通过步进时序函数定义</h4><p><code>step-start</code>整个过程都处于最终关键帧上，等同于<code>steps(1,start)</code></p>
<p><code>step-end</code>整个过渡都在初始关键帧上，等同于<code>steps(1,end)</code></p>
<p><code>steps(n,start)</code></p>
<p><code>step(n,end)</code></p>
<p>这两个函数可以显示固定的镜头数</p>
<p>使用<code>transition-timing-function</code>不改变过渡的持续时间，只控制过渡的行进节奏</p>
<h3 id="延时过渡transition-delay"><a href="#延时过渡transition-delay" class="headerlink" title="延时过渡transition-delay"></a>延时过渡<code>transition-delay</code></h3><p>该属性在元素上发生触发过渡的变化与开始过渡之间引入一定的延迟</p>
<p>默认是0s，即无延迟</p>
<p>值也可以为负数</p>
<p>设置延迟可以防止误操作</p>
<h5 id="值为负数"><a href="#值为负数" class="headerlink" title="值为负数"></a>值为负数</h5><p>如果值为负数，则会从中间某个位置立即过渡</p>
<p>如：让元素x移动200像素，<code>transition-duration</code>设置为200ms,<code>transition-delay</code>设置为-150ms，那么元素x将立即移动150px，再过渡运动到200px</p>
<p>从悬停状态回到初始状态时，默认还会使用相同的delay值，所以x会立即反向运动150px，再过渡回到原点</p>
<h3 id="transition简写"><a href="#transition简写" class="headerlink" title="transition简写"></a><code>transition</code>简写</h3><p>可以同时书写四个属性</p>
<p>如果没有声明<code>transition-timing-function</code>默认为ease</p>
<p>要注意<code>transition-duration</code>和<code>transition-delay</code>的顺序，前面的是<code>duration</code>,后面的是<code>delay</code></p>
<p>持续时间必须设置，否则过渡不可见</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>css中表格样式</title>
    <url>/2022/08/03/%E8%A1%A8%E6%A0%BC%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h1 id="表格布局"><a href="#表格布局" class="headerlink" title="表格布局"></a>表格布局</h1><h3 id="表格格式化"><a href="#表格格式化" class="headerlink" title="表格格式化"></a>表格格式化</h3>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>未完成（鸽）</tag>
      </tags>
  </entry>
</search>
