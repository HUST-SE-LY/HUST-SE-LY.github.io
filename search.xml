<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>css中的float</title>
    <url>/2022/08/04/CSS%E6%B5%AE%E5%8A%A8/</url>
    <content><![CDATA[<h1 id="CSS浮动"><a href="#CSS浮动" class="headerlink" title="CSS浮动"></a>CSS浮动</h1><h3 id="浮动规则"><a href="#浮动规则" class="headerlink" title="浮动规则"></a>浮动规则</h3><p>1.浮动元素不会超过容纳块的边界</p>
<p>2.排队浮动</p>
<p>3.浮动元素间不会重叠</p>
<p>4.浮动元素的顶边不能比父级元素的内顶边高</p>
<p>5.浮动元素的顶边不能比之前任何一个浮动元素或块元素的顶边高</p>
<p>6.浮动元素顶边不能高于源码中出现浮动元素之前的元素生成的框体所在行框的顶边</p>
<p>7.浮动元素必须放在尽可能高的位置</p>
<p>8.左浮动元素尽量向左移动，右浮动元素尽量向右移动</p>
<p>浮动元素的后代也会浮动</p>
<h3 id="浮动元素与内容重叠"><a href="#浮动元素与内容重叠" class="headerlink" title="浮动元素与内容重叠"></a>浮动元素与内容重叠</h3><p>与行内元素重叠时：行内元素边框背景内容都会在浮动元素”之上“渲染</p>
<p>与块元素重叠时：边框和背景在浮动元素”背后“渲染，内容在”之上“渲染</p>
<p>重叠方式与元素出现顺序无关</p>
<h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><p>禁止每个区域的第一个元素出现在浮动元素旁</p>
<p>如：禁止元素出现在左浮动元素的右侧：<code>clear：left</code></p>
<p>确保某个元素不与任何浮动元素共处一行：<code>clear both</code></p>
<p>实现方式：<strong>间距</strong></p>
<p><strong>间距</strong>：为了把元素向下移动，确保显示在浮动元素下方而在元素上外边距<strong>上方额外增加的空白</strong>，不影响上外边距</p>
<p>为确保清除浮动了的元素与浮动元素间的边距，可以为浮动元素设置下外边距</p>
<h3 id="形状浮动"><a href="#形状浮动" class="headerlink" title="形状浮动"></a>形状浮动</h3><p>可以让文字按照浮动<strong>透明</strong>图片的轮廓填充在旁边</p>
<p>先为浮动图片定义一个形状：</p>
<p><code>shape-outside:url(&quot;绝对路径&quot;);</code></p>
<p>若图片向左浮动则会填充在右边，若为向右浮动则填充左边</p>
<p><strong>必须是透明图片！！！！</strong></p>
<p>shape-outside还可以直接使用设置其他形状,分为basic-shape和shape-box两类</p>
<p>basic-shape:</p>
<p><code>inset() circle() ellipse() polygon()</code></p>
<p>shape-box:</p>
<p><code>margin-box border-box padding-box content-box</code>指形状最外边的界限</p>
<p>默认使用外边距框</p>
<p>如果设置的形状超过了浮动框，则不会按形状填充而是按浮动框进行填充</p>
<p>可以使用shape-margin为形状设置”外边距“</p>
<p>但设置时要注意设置之后有没有超过浮动框，有时候浮动框要设置的更大才能体现出效果</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>浮动是css的基础，虽然简单，但十分强大和有用。浮动不可或缺，有了浮动才能把内容放在某一边，让其他内容围绕它流动。引入浮动形状后，浮动框不再局限为方形</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP知识点总结</title>
    <url>/2022/08/03/HTTP/</url>
    <content><![CDATA[<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><hr>
<h2 id="第一章：了解web及网络基础"><a href="#第一章：了解web及网络基础" class="headerlink" title="第一章：了解web及网络基础"></a>第一章：了解web及网络基础</h2><h3 id="1-1-TCP-x2F-IP"><a href="#1-1-TCP-x2F-IP" class="headerlink" title="1.1 TCP&#x2F;IP"></a>1.1 TCP&#x2F;IP</h3><p>不同硬件，操作系统之间的通信都需要规则，这种规则成为<strong>协议</strong>。</p>
<p>把与互联网相关联的协议集合称为TCP&#x2F;IP</p>
<h3 id="1-2-TCP-x2F-IP分层管理"><a href="#1-2-TCP-x2F-IP分层管理" class="headerlink" title="1.2 TCP&#x2F;IP分层管理"></a>1.2 TCP&#x2F;IP分层管理</h3><p>TCP&#x2F;IP协议族分为四层：</p>
<ul>
<li>应用层：决定了向用户提供应用服务时通信的活动，如FTP,DNS,HTTP</li>
<li>传输层：提供处于网络连接中的两台计算机之间的数据传输，如TCP,UDP</li>
<li>网络层：用来处理在网络上流动的数据包</li>
<li>链路层：处理连接网络的硬件部分</li>
</ul>
<h3 id="1-3-IP-TCP-DNS"><a href="#1-3-IP-TCP-DNS" class="headerlink" title="1.3 IP,TCP,DNS"></a>1.3 IP,TCP,DNS</h3><h4 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h4><p>IP网络协议位于网络层，作用是把各种数据包传给对方。要想确保传输需要满足各种条件，最重要的是IP地址和MAC地址</p>
<p>IP地址是节点被分配的地址，MAC地址是网卡的固定地址，IP地址可变换，MAC地址一般不可变换</p>
<h5 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h5><p>IP间的通信依赖MAC地址，数据在网络上的传递需要经过多个中转站，通过MAC来搜索中转站，ARP协议可以通过IP地址反查出MAC地址</p>
<p>没有设备能够全面掌握数据的传输情况</p>
<h4 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h4><p>位于传输层，提供可靠的字节流服务</p>
<h5 id="确保数据能到达目标"><a href="#确保数据能到达目标" class="headerlink" title="确保数据能到达目标"></a>确保数据能到达目标</h5><p>采用三次握手策略。</p>
<p>握手过程中使用了TCP的标志：SYN和ACK</p>
<p>发送端发送带有SYN标志的数据包给对方，接收端返回带有SYN&#x2F;ACK标志的数据包以示传达确认信息，最后发送端回传带有ACK标志的数据包代表握手结束</p>
<p>若握手在某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包</p>
<h4 id="DNS服务"><a href="#DNS服务" class="headerlink" title="DNS服务"></a>DNS服务</h4><p>位于应用层，提供域名到IP的解析服务</p>
<h3 id="1-4-HTTP与其他协议的关系"><a href="#1-4-HTTP与其他协议的关系" class="headerlink" title="1.4 HTTP与其他协议的关系"></a>1.4 HTTP与其他协议的关系</h3><p>HTTP生成报文-&gt;TCP将报文分割处理-&gt;IP将报文段传输-&gt;TCP将报文段重组-&gt;HTTP对接受到的报文进行处理再回传</p>
<h3 id="1-5-URL和URI"><a href="#1-5-URL和URI" class="headerlink" title="1.5 URL和URI"></a>1.5 URL和URI</h3><p>URI用字符串标识某一互联网资源，URL表示资源的地点，URL是URI的子集</p>
<hr>
<h2 id="第二章：简单的HTTP协议"><a href="#第二章：简单的HTTP协议" class="headerlink" title="第二章：简单的HTTP协议"></a>第二章：简单的HTTP协议</h2><h3 id="2-1-HTTP协议用于客户端和服务器端之间的通信"><a href="#2-1-HTTP协议用于客户端和服务器端之间的通信" class="headerlink" title="2.1 HTTP协议用于客户端和服务器端之间的通信"></a>2.1 HTTP协议用于客户端和服务器端之间的通信</h3><p>请求访问文本等资源的一端成为客户端，提供资源做出响应的一端称为服务器端</p>
<h3 id="2-2-通过请求和响应的交换达成协议"><a href="#2-2-通过请求和响应的交换达成协议" class="headerlink" title="2.2 通过请求和响应的交换达成协议"></a>2.2 通过请求和响应的交换达成协议</h3><p>服务器在没有接收到请求时是不会响应的</p>
<p>一段请求报文：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/index.htm</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>hacker.jp</span><br></pre></td></tr></table></figure>

<ul>
<li>GET表示请求服务的类型，称为<strong>方法</strong></li>
<li><code>/index.htm</code>表示了请求访问的资源对象，也叫请求URI</li>
<li><code>HTTP/1.1</code>表示HTTP的版本号</li>
</ul>
<p>请求报文是由请求方法，请求URI，协议版本，可选的请求首部字段和内容实体构成的</p>
<p>请求首部字段和内容实体之后介绍</p>
<p>一段响应报文：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>TUe, 10 Jul 2012 6:50:15 GMT</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>362</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html</span><br><span class="line"></span><br><span class="line"><span class="language-lasso">&lt;html&gt;</span></span><br><span class="line"><span class="language-lasso"><span class="params">...</span><span class="params">...</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>HTTP/1.1</code>表示服务器对应的HTTP版本</p>
</li>
<li><p><code>200 OK</code>表示状态码和原因短语</p>
</li>
<li><p><code>Date Content</code>为首部字段内的属性</p>
</li>
<li><p>以一空行分隔，之后的内容为资源实体的主体</p>
</li>
</ul>
<p>响应报文由协议版本，状态码，解释状态码的原因短语，可选的响应首部字段以及实体主体构成</p>
<h3 id="2-3-HTTP是不保存状态的协议"><a href="#2-3-HTTP是不保存状态的协议" class="headerlink" title="2.3 HTTP是不保存状态的协议"></a>2.3 HTTP是不保存状态的协议</h3><p>HTTP协议自身不具备保存之前发送过的请求或响应的功能</p>
<p>为了实现保存状态，引入了Cookie技术</p>
<h3 id="2-4-请求URI定位资源"><a href="#2-4-请求URI定位资源" class="headerlink" title="2.4 请求URI定位资源"></a>2.4 请求URI定位资源</h3><p>HTTP协议使用URI定位互联网上的资源</p>
<p>指定请求URI的方式很多</p>
<p>如果不是访问资源而是对服务器本身发送请求，URI可以使用*代替</p>
<h3 id="2-5告知服务器意图的HTTP方法"><a href="#2-5告知服务器意图的HTTP方法" class="headerlink" title="2.5告知服务器意图的HTTP方法"></a>2.5告知服务器意图的HTTP方法</h3><h4 id="GET-获取资源"><a href="#GET-获取资源" class="headerlink" title="GET:获取资源"></a>GET:获取资源</h4><p>GET方法用来请求已被URI识别的资源</p>
<h4 id="POST：传输实体主体"><a href="#POST：传输实体主体" class="headerlink" title="POST：传输实体主体"></a>POST：传输实体主体</h4><p>POST方法用来传输实体的主体，虽说GET也能传输，但一般不用GET，POST的主要目的并不是获取响应的主体内容</p>
<h4 id="PUT：传输文件"><a href="#PUT：传输文件" class="headerlink" title="PUT：传输文件"></a>PUT：传输文件</h4><p>PUT方法用来传输文件。在报文的主体中包含文件内容，保存到请求URI的指定位置</p>
<p>由于不存在验证机制，任何人都可以上传，存在安全性问题，一般网站不使用PUT</p>
<h4 id="HEAD：获取报文首部"><a href="#HEAD：获取报文首部" class="headerlink" title="HEAD：获取报文首部"></a>HEAD：获取报文首部</h4><p>HEAD与GET一样，只是不返回报文的主体部分，用于确认URI的有效性以及资源更新的日期时间等</p>
<h4 id="DELETE-删除文件"><a href="#DELETE-删除文件" class="headerlink" title="DELETE:删除文件"></a>DELETE:删除文件</h4><p>与PUT相反的方法，一般不用</p>
<h4 id="OPTIONS：查询支持的方法"><a href="#OPTIONS：查询支持的方法" class="headerlink" title="OPTIONS：查询支持的方法"></a>OPTIONS：查询支持的方法</h4><p>查询针对URI指定的资源支持的方法</p>
<h4 id="TRACE：追踪路径"><a href="#TRACE：追踪路径" class="headerlink" title="TRACE：追踪路径"></a>TRACE：追踪路径</h4><p>不常用且可能引发XST攻击，通常不会用到</p>
<h4 id="CONNECT：要求用隧道协议连接代理"><a href="#CONNECT：要求用隧道协议连接代理" class="headerlink" title="CONNECT：要求用隧道协议连接代理"></a>CONNECT：要求用隧道协议连接代理</h4><p>主要使用SSL和TLS协议把通信加密后经网络隧道传输</p>
<h3 id="2-6-持久连接"><a href="#2-6-持久连接" class="headerlink" title="2.6 持久连接"></a>2.6 持久连接</h3><p>即在建立TCP连接后，如果一端没有明确要求断开链接，则保持TCP连接状态</p>
<h3 id="2-7-管线化"><a href="#2-7-管线化" class="headerlink" title="2.7 管线化"></a>2.7 管线化</h3><p>从前发送请求需要收到响应才能发送下一个请求，通过管线化技术不用等待即可发送下一个请求</p>
<h3 id="2-8-使用Cookie的状态管理"><a href="#2-8-使用Cookie的状态管理" class="headerlink" title="2.8 使用Cookie的状态管理"></a>2.8 使用Cookie的状态管理</h3><p>Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端状态</p>
<p>如果请求中没有cookie，则会在响应报文中添加cookie</p>
<p>如果请求中有cookie，服务器端会检查cookie识别状态做出响应</p>
<hr>
<h2 id="第三章：HTTP报文内的HTTP信息"><a href="#第三章：HTTP报文内的HTTP信息" class="headerlink" title="第三章：HTTP报文内的HTTP信息"></a>第三章：HTTP报文内的HTTP信息</h2><h3 id="3-1-HTTP报文"><a href="#3-1-HTTP报文" class="headerlink" title="3.1 HTTP报文"></a>3.1 HTTP报文</h3><p>用于HTTP协议交互的信息叫做HTTP报文，请求端的HTTP报文叫请求报文，相应端的叫响应报文</p>
<p>HTTP报文大致可分为报文首部和报文主体两部分，由空行划分，通常并不一定有报文主体</p>
<h3 id="3-2-请求报文和响应报文的结构"><a href="#3-2-请求报文和响应报文的结构" class="headerlink" title="3.2 请求报文和响应报文的结构"></a>3.2 请求报文和响应报文的结构</h3><ul>
<li>报文首部<ul>
<li>请求行：包含用于请求的方法，请求URI和HTTP版本</li>
<li>状态行：包含表明响应结果的状态码，原因短语和HTTP版本</li>
<li>首部字段：包含表示请求和响应的各种条件和属性的各类首部<ul>
<li>通用首部</li>
<li>请求首部</li>
<li>响应首部</li>
<li>实体首部</li>
</ul>
</li>
<li>其他（HTTP的RFC未规定的首部，如Cookie）</li>
</ul>
</li>
<li>空行</li>
<li>报文主体</li>
</ul>
<h3 id="3-3-编码提升传输速率"><a href="#3-3-编码提升传输速率" class="headerlink" title="3.3 编码提升传输速率"></a>3.3 编码提升传输速率</h3><h4 id="报文主体和实体主体"><a href="#报文主体和实体主体" class="headerlink" title="报文主体和实体主体"></a>报文主体和实体主体</h4><p>一般来说报文主体等于实体主体，当编码后实体主体发生变化，与报文主体不同</p>
<h4 id="压缩传输的内容编码"><a href="#压缩传输的内容编码" class="headerlink" title="压缩传输的内容编码"></a>压缩传输的内容编码</h4><p>内容编码指明应用在实体内容上的编码格式，并保持实体信息原样进行压缩，编码后的实体主体由客户端接收并负责解码</p>
<h4 id="分割发送的分块传输编码"><a href="#分割发送的分块传输编码" class="headerlink" title="分割发送的分块传输编码"></a>分割发送的分块传输编码</h4><p>把数据分割成多块，能够让浏览器逐步显示页面</p>
<p>这种把实体主体分块的功能称为分块传输编码，由客户端负责解码</p>
<h3 id="3-4-发送多种数据的多部分对象集合"><a href="#3-4-发送多种数据的多部分对象集合" class="headerlink" title="3.4 发送多种数据的多部分对象集合"></a>3.4 发送多种数据的多部分对象集合</h3><p>HTTP协议采用了多部分对象集合，发送的一份报文主体内可能含有多种类型的实体</p>
<p>多部分对象集合包含的对象如下：</p>
<ul>
<li><p><code>multipart/form-data</code>：在web表单文件上传时使用</p>
</li>
<li><p><code>multipart/byteranges</code>：在状态码206响应报文包含了多个范围的内容时使用</p>
</li>
</ul>
<p>详见p48</p>
<h3 id="3-5-获取部分内容的范围请求"><a href="#3-5-获取部分内容的范围请求" class="headerlink" title="3.5 获取部分内容的范围请求"></a>3.5 获取部分内容的范围请求</h3><p>为指定范围发送的请求称为范围请求</p>
<p>针对范围请求，响应会返回状态码为<code>206 Partial Content</code>的响应报文。对于多重范围的范围请求，响应会在首部字段Content-Type标明multipart&#x2F;byteranges后返回响应报文</p>
<p>如果服务器端无法响应范围请求，则会返回状态码200 OK和完整的实体内容</p>
<h3 id="3-6-内容协商返回最合适的内容"><a href="#3-6-内容协商返回最合适的内容" class="headerlink" title="3.6 内容协商返回最合适的内容"></a>3.6 内容协商返回最合适的内容</h3><p>内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，最终提供给客户端最合适的资源。内容协商会以语言，字符集，编码方式等作为基准判断响应的资源</p>
<p>包含在请求报文中的某些首部字段就是判断标准</p>
<ul>
<li><code>Accept</code></li>
<li><code>Accept-Charset</code></li>
<li><code>Accept-Encoding</code></li>
<li><code>Accept-Language</code></li>
<li><code>Content-Language</code></li>
</ul>
<p>内容协商技术分为以下三种类型</p>
<ul>
<li>服务器驱动协商：以请求的首部字段为参考，由服务器端自动进行内容协商，未必能选择出最优内容</li>
<li>客户端驱动协商：由客户端进行内容协商。用户可从浏览器的可选列表里手动选择，还可以利用JS脚本自动选择</li>
<li>透明协商：是服务器驱动和客户端驱动的结合体，是服务器端和客户端各自进行内容协商的一种方法</li>
</ul>
<hr>
<h2 id="第四章：返回结果状态的HTTP状态码"><a href="#第四章：返回结果状态的HTTP状态码" class="headerlink" title="第四章：返回结果状态的HTTP状态码"></a>第四章：返回结果状态的HTTP状态码</h2><h3 id="4-1-状态码告知服务器端返回的请求结果"><a href="#4-1-状态码告知服务器端返回的请求结果" class="headerlink" title="4.1 状态码告知服务器端返回的请求结果"></a>4.1 状态码告知服务器端返回的请求结果</h3><p>借助状态码，用户可以知道服务器端是正常处理了请求还是出现了错误</p>
<p>响应类别有如下5种</p>
<ul>
<li>1XX<ul>
<li>信息性状态码</li>
<li>表示接收的请求正在处理</li>
</ul>
</li>
<li>2XX<ul>
<li>成功状态码</li>
<li>表示请求正常处理完毕</li>
</ul>
</li>
<li>3XX<ul>
<li>重定向状态码</li>
<li>需要进行附加操作以完成请求</li>
</ul>
</li>
<li>4XX<ul>
<li>客户端错误状态码</li>
<li>服务器无法处理请求</li>
</ul>
</li>
<li>5XX<ul>
<li>服务器错误状态码</li>
<li>服务器处理请求出错</li>
</ul>
</li>
</ul>
<p>经常使用的状态码有14种</p>
<h3 id="4-2-2XX-成功"><a href="#4-2-2XX-成功" class="headerlink" title="4.2 2XX 成功"></a>4.2 2XX 成功</h3><h4 id="200-OK"><a href="#200-OK" class="headerlink" title="200 OK"></a>200 OK</h4><p>表示从客户端发来的请求在服务器端被正常处理了</p>
<p>随状态码返回的信息会因方法不同而发生改变</p>
<h4 id="204-No-Content"><a href="#204-No-Content" class="headerlink" title="204 No Content"></a>204 No Content</h4><p>表示接收的请求已被成功处理，但返回的响应报文中不含实体的主体部分，也不允许返回任何实体的主体</p>
<p>在客户端忘服务器端发送信息，而客户端不需要更新信息内容时使用</p>
<h4 id="206-Partial-Content"><a href="#206-Partial-Content" class="headerlink" title="206 Partial Content"></a>206 Partial Content</h4><p>表示客户端进行了范围请求，服务器成功执行了这部分的GET请求。响应报文中包含有Content-Range指定范围的实体内容</p>
<h3 id="4-3-3XX-重定向"><a href="#4-3-3XX-重定向" class="headerlink" title="4.3 3XX 重定向"></a>4.3 3XX 重定向</h3><h4 id="301-Moved-Permanently"><a href="#301-Moved-Permanently" class="headerlink" title="301 Moved Permanently"></a>301 Moved Permanently</h4><p>永久性重定向。表示请求的资源已经被分配了新的URI，以后应使用资源现在所指的URI</p>
<h4 id="302-Found"><a href="#302-Found" class="headerlink" title="302 Found"></a>302 Found</h4><p>临时重定向。表示请求的资源已经被分配了新的URI，本次应使用资源现在所指的URI</p>
<h4 id="303-See-Other"><a href="#303-See-Other" class="headerlink" title="303 See Other"></a>303 See Other</h4><p>表示请求的资源存在着另一个URI，应使用GET方法定向获取请求的资源</p>
<p>与302有着相同的功能，但明确表示客户端应该使用GET方法获取资源</p>
<h4 id="304-Not-Modified"><a href="#304-Not-Modified" class="headerlink" title="304 Not Modified"></a>304 Not Modified</h4><p>表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但因发生请求未满足条件的情况后直接返回304</p>
<p>和重定向没有关系</p>
<h4 id="307-Temporary-Redirect"><a href="#307-Temporary-Redirect" class="headerlink" title="307 Temporary Redirect"></a>307 Temporary Redirect</h4><p>临时重定向，与302有相同的含义</p>
<p>302标准禁止POST变为GET，但大家并不遵守</p>
<p>307会遵照浏览器标准，不会从POST变为GET。但是对于处理响应时的行为，不同浏览器有可能出现不同情况</p>
<h3 id="4-4-4XX-客户端错误"><a href="#4-4-4XX-客户端错误" class="headerlink" title="4.4 4XX 客户端错误"></a>4.4 4XX 客户端错误</h3><h4 id="400-Bad-Request"><a href="#400-Bad-Request" class="headerlink" title="400 Bad Request"></a>400 Bad Request</h4><p>表示请求报文中有语法错误，需要修改请求内容后再次发送请求</p>
<h4 id="401-Unauthorized"><a href="#401-Unauthorized" class="headerlink" title="401 Unauthorized"></a>401 Unauthorized</h4><p>表示发送的请求需要有通过HTTP认证（BASIC认证，DIGEST认证）的认证信息。若之前已经进行过一次请求，则表示用户认证失败</p>
<p>浏览器初次接收到401响应会弹出认证用的对话窗口</p>
<h4 id="403-Forbidden"><a href="#403-Forbidden" class="headerlink" title="403 Forbidden"></a>403 Forbidden</h4><p>表示对请求资源的访问被服务器拒绝了</p>
<h4 id="404-Not-Found"><a href="#404-Not-Found" class="headerlink" title="404 Not Found"></a>404 Not Found</h4><p>表明服务器上没有请求的资源</p>
<h3 id="4-5-5XX-服务器错误"><a href="#4-5-5XX-服务器错误" class="headerlink" title="4.5 5XX 服务器错误"></a>4.5 5XX 服务器错误</h3><h4 id="500-Internet-Server-Error"><a href="#500-Internet-Server-Error" class="headerlink" title="500 Internet Server Error"></a>500 Internet Server Error</h4><p>表明服务器端在执行请求时发生了错误，也许是web应用的bug所致</p>
<h4 id="503-Server-Unavailable"><a href="#503-Server-Unavailable" class="headerlink" title="503 Server Unavailable"></a>503 Server Unavailable</h4><p>表明服务器正处于超负载或停机维护，暂时无法处理请求</p>
<hr>
<h2 id="第五章-与HTTP协作的web服务器"><a href="#第五章-与HTTP协作的web服务器" class="headerlink" title="第五章 与HTTP协作的web服务器"></a>第五章 与HTTP协作的web服务器</h2><h3 id="5-1-用单台虚拟主机实现多个域名"><a href="#5-1-用单台虚拟主机实现多个域名" class="headerlink" title="5.1 用单台虚拟主机实现多个域名"></a>5.1 用单台虚拟主机实现多个域名</h3><p>即使物理层面只有一个服务器，但使用了虚拟主机的功能，则可以假想已经具有了多台服务器</p>
<p>当两个域名被部署在一个服务器上时，使用DNS服务解析域名后会得到相同的IP地址。</p>
<p>在相同的IP地址下，由于虚拟主机可以寄存多个不同主机名和域名的web网站，因此在发送HTTP请求时，必须在HOST主部中完整指定主机名和域名的URI</p>
<h3 id="5-2-代理，网关，隧道"><a href="#5-2-代理，网关，隧道" class="headerlink" title="5.2 代理，网关，隧道"></a>5.2 代理，网关，隧道</h3><h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><p>代理服务器的基本行为就是接收客户端发送的请求后转发给其他服务器。代理不改变请求URI</p>
<p>持有资源实体的服务器称为源服务器，源服务器返回的响应经过代理服务器传回客户端</p>
<p>可级联多台代理服务器。转发时需要用Via首部字段以标记经处的主机信息</p>
<p>代理有多种使用方法，按两种基准分类</p>
<ul>
<li>缓存代理：代理转发响应时，缓存代理会预先将资源副本（缓存）保存在代理服务器上，当代理再次接收到相同资源的请求时，将缓存的资源直接返回</li>
<li>透明代理：不对报文做任何类型加工的代理类型称为透明代理，反之称为非透明代理</li>
</ul>
<h3 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h3><p>网关的工作方式与代理相似，但网关能使通信链路上的服务器提供非HTTP协议服务</p>
<p>利用网关能提高通信的安全性，因为可以在客户端和网关之间的通信链路上加密以确保连接的安全</p>
<h4 id="隧道"><a href="#隧道" class="headerlink" title="隧道"></a>隧道</h4><p>隧道可按要求建立起一条与其他服务器的通信链路，使用SSL等加密手段进行通信。隧道的目的是确保服务器和客户端能安全通信</p>
<p>隧道本身不会解析HTTP请求，请求保持原样中转给之后的服务器</p>
<h3 id="5-3-缓存"><a href="#5-3-缓存" class="headerlink" title="5.3 缓存"></a>5.3 缓存</h3><p>缓存指代理服务器或客户端本地磁盘内保存的资源副本</p>
<p>利用缓存可减少对源服务器的访问，节省了通信流量和通信时间</p>
<p>缓存服务器是代理服务器的一种，归类在缓存代理类型中</p>
<p>缓存服务器的优势在于利用缓存可以避免多次从源服务器转发资源。</p>
<h4 id="缓存的有效期限"><a href="#缓存的有效期限" class="headerlink" title="缓存的有效期限"></a>缓存的有效期限</h4><p>即使缓存服务器内存在缓存，也会因为客户端的要求，缓存的有效期限等因素，向原服务器确认资源的有效性。若判断缓存失效，缓存服务器会再次从原服务器上获取”新”资源</p>
<h4 id="客户端的缓存"><a href="#客户端的缓存" class="headerlink" title="客户端的缓存"></a>客户端的缓存</h4><p>除了代理服务器中存在缓存，客户端浏览器中也能存在缓存。如果缓存有效，则不用向服务器发送请求，直接从本地磁盘中读取资源</p>
<p>和缓存服务器相同，当判定缓存过期后，会向源服务器确认资源的有效性，若判断缓存失效，浏览器会再次请求新资源</p>
<hr>
<h2 id="第六章-HTTP首部"><a href="#第六章-HTTP首部" class="headerlink" title="第六章 HTTP首部"></a>第六章 HTTP首部</h2><h3 id="6-1-HTTP报文首部"><a href="#6-1-HTTP报文首部" class="headerlink" title="6.1 HTTP报文首部"></a>6.1 HTTP报文首部</h3><p>HTTP请求和响应报文中必定包含报文首部，报文首部由几个字段组成</p>
<ul>
<li>HTTP请求报文：由方法，HTTP版本，HTTP首部字段等部分构成</li>
<li>HTTP响应报文：由HTTP版本，状态码（数字和原因短语），HTTP首部字段三部分构成</li>
</ul>
<h3 id="6-2-HTTP首部字段"><a href="#6-2-HTTP首部字段" class="headerlink" title="6.2 HTTP首部字段"></a>6.2 HTTP首部字段</h3><h4 id="6-2-1-首部字段传递重要信息"><a href="#6-2-1-首部字段传递重要信息" class="headerlink" title="6.2.1 首部字段传递重要信息"></a>6.2.1 首部字段传递重要信息</h4><p>使用首部字段是为了给浏览器和服务器提供报文主体大小，所使用的语言，认证信息等内容</p>
<h4 id="6-2-2-HTTP首部字段结构"><a href="#6-2-2-HTTP首部字段结构" class="headerlink" title="6.2.2 HTTP首部字段结构"></a>6.2.2 HTTP首部字段结构</h4><p>首部字段名： 字段值</p>
<p>可以有多个值，用逗号隔开</p>
<h4 id="6-2-3-4种HTTP首部字段类型"><a href="#6-2-3-4种HTTP首部字段类型" class="headerlink" title="6.2.3 4种HTTP首部字段类型"></a>6.2.3 4种HTTP首部字段类型</h4><ul>
<li>通用首部字段：请求和响应报文双方都会使用的首部</li>
<li>请求首部字段：从客户端向服务器端发送请求报文时使用的首部</li>
<li>响应首部字段：从服务器端向客户端发送响应报文时使用的首部</li>
<li>实体首部字段：针对请求报文和响应报文的实体部分使用的首部</li>
</ul>
<h4 id="6-2-4-HTTP-x2F-1-1首部字段一览"><a href="#6-2-4-HTTP-x2F-1-1首部字段一览" class="headerlink" title="6.2.4 HTTP&#x2F;1.1首部字段一览"></a>6.2.4 HTTP&#x2F;1.1首部字段一览</h4><ul>
<li>通用首部字段<ul>
<li><code>Cache-Control</code>:控制缓存行为</li>
<li><code>Connection</code>:逐跳首部、连接的管理</li>
<li><code>Date</code>:创建报文的日期时间</li>
<li><code>Pragma</code>:报文指令</li>
<li><code>Trailer</code>:报文末端的首部一览</li>
<li><code>Transfer-Encoding</code>:指定报文主体的传输编码方式</li>
<li><code>Upgrade</code>:升级为其他协议</li>
<li><code>Via</code>:代理服务器的相关信息</li>
<li><code>Warning</code>:错误通知</li>
</ul>
</li>
<li>请求首部字段<ul>
<li><code>Accept</code>:用户代理可处理的媒体类型</li>
<li><code>Accept-Charset</code>:优先的字符集</li>
<li><code>Accept-Encoding</code>:优先的内容编码</li>
<li><code>Accept-Language</code>:优先的语言（自然语言）</li>
<li><code>Authorized</code>:Web认证信息</li>
<li><code>Expect</code>:期待服务器的特定行为</li>
<li><code>From</code>:用户的电子邮箱地址</li>
<li><code>Host</code>:请求资源所在的服务器</li>
<li><code>If-Match</code>:比较实体标记（ETag）</li>
<li><code>If-Modified-Since</code>:比较资源的更新时间</li>
<li><code>If-None-Match</code>:比较实体标记（与If-Match相反）</li>
<li><code>If-Range</code>:资源未更新时发送实体Byte的范围请求</li>
<li><code>If-Unmodified-Since</code>:比较资源的更新时间（与If-Modified-Since相反）</li>
<li><code>Max-Forwards</code>:最大传输跳转数</li>
<li><code>Proxy-Authorization</code>:代理服务器要求客户端的认证信息</li>
<li><code>Range</code>:实体的字节范围请求</li>
<li><code>Referer</code>:对请求中URI的原始获取方</li>
<li><code>TE</code>:传输编码的优先级</li>
<li><code>User-Agent</code>:HTTP客户端程序的信息</li>
</ul>
</li>
<li>响应首部字段<ul>
<li><code>Accept-Ranges</code>:是否接收字节范围请求</li>
<li><code>Age</code>:推算资源创建经过时间</li>
<li><code>ETAG</code>:资源的匹配信息</li>
<li><code>Location</code>:令客户端重定向至指定URI</li>
<li><code>Proxy-Authenticate</code>:代理服务器对客户端的认证信息</li>
<li><code>Retry-After</code>:对再次发起请求的时间要求</li>
<li><code>Server</code>:HTTP服务器的安装信息</li>
<li><code>Vary</code>:代理服务器缓存的管理信息</li>
<li><code>WWW-Authenticate</code>:服务器对客户端的认证信息</li>
</ul>
</li>
<li>实体首部字段：<ul>
<li><code>Allow</code>:资源可支持的HTTP方法</li>
<li><code>Content-Encoding</code>:实体主体适用的编码方式</li>
<li><code>Content-Language</code>:实体主体的自然语言</li>
<li><code>Content-Length</code>:实体主体的大小</li>
<li><code>Content-Location</code>:替代对应资源的URI</li>
<li><code>Content-MD5</code>:实体主体的报文摘要</li>
<li><code>Content-Range</code>:实体主体的位置范围</li>
<li><code>Content-Type</code>:实体主体的媒体类型</li>
<li><code>Expires</code>:实体主体过期的日期时间</li>
<li><code>Last-Modified</code>:资源最后的修改日期</li>
</ul>
</li>
</ul>
<h4 id="6-2-5-非HTTP-x2F-1-1首部字段"><a href="#6-2-5-非HTTP-x2F-1-1首部字段" class="headerlink" title="6.2.5 非HTTP&#x2F;1.1首部字段"></a>6.2.5 非HTTP&#x2F;1.1首部字段</h4><p>除了RFC2616中定义的47种首部字段，还有Cookie，Set-Cookie和Content-Disposition等在其他RFC中定义的首部字段，它们的使用频率很高</p>
<h4 id="6-2-6-End-to-end首部和Hop-by-hop首部"><a href="#6-2-6-End-to-end首部和Hop-by-hop首部" class="headerlink" title="6.2.6 End-to-end首部和Hop-by-hop首部"></a>6.2.6 End-to-end首部和Hop-by-hop首部</h4><ul>
<li>端到端首部：分在此类的首部会转发给请求&#x2F;响应对应的最终接受目标，且必须保存在由缓存生成的响应中，另外规定它必须被转发</li>
<li>逐跳首部：分在此类别中的首部只对单次转发有效，会因通过缓存或代理而不再转发</li>
</ul>
<p>HTTP&#x2F;1.1及之后版本中，使用逐跳首部需要提供Connection首部字段</p>
<h3 id="6-3-HTTP通用首部字段"><a href="#6-3-HTTP通用首部字段" class="headerlink" title="6.3 HTTP通用首部字段"></a>6.3 HTTP通用首部字段</h3><p>看书！</p>
<hr>
<h2 id="第七章-确保Web安全的HTTPS"><a href="#第七章-确保Web安全的HTTPS" class="headerlink" title="第七章 确保Web安全的HTTPS"></a>第七章 确保Web安全的HTTPS</h2><h3 id="7-1-HTTP的缺点"><a href="#7-1-HTTP的缺点" class="headerlink" title="7.1 HTTP的缺点"></a>7.1 HTTP的缺点</h3><h4 id="7-1-1-通信使用明文可能被窃听"><a href="#7-1-1-通信使用明文可能被窃听" class="headerlink" title="7.1.1 通信使用明文可能被窃听"></a>7.1.1 通信使用明文可能被窃听</h4><p>HTTP使用未经加密的报文发送。</p>
<p>按TCP&#x2F;IP协议族的工作机制，通信内容在所有的通信链路上都可能遭到窥视</p>
<p>加密后的报文也会被人看到，但是不容易破解而得到其中的含义</p>
<p>可以通过加密处理防止被窃听，加密对象可以如下：</p>
<ul>
<li>通信的加密</li>
</ul>
<p>通过SSL（安全套接层）和TLS（安全传输层协议）组合使用，加密HTTP的通信内容</p>
<p>用SSL建立安全通信链路后，就可以在这条链路上进行HTTP通信，与SSL组合使用的HTTP称为HTTPS（超文本传输安全协议）.</p>
<ul>
<li>内容的加密</li>
</ul>
<p>即把HTTP报文里所含的内容进行加密，前提是客户端和服务器端同时具有加密和解密的功能</p>
<p>这种方式所传输的内容仍有被篡改的风险</p>
<h4 id="7-1-2-不验证通信方的身份就可能遭遇伪装"><a href="#7-1-2-不验证通信方的身份就可能遭遇伪装" class="headerlink" title="7.1.2 不验证通信方的身份就可能遭遇伪装"></a>7.1.2 不验证通信方的身份就可能遭遇伪装</h4><p>HTTP协议中的请求和响应不会对通信方进行确认</p>
<p><strong>任何人可发起请求</strong></p>
<ul>
<li>无法确定目标web服务器是否是伪装服务器</li>
<li>无法确认收到响应的客户端是否是伪装客户端</li>
<li>无法确定正在通信的对方是否具备访问权限</li>
<li>无法判断请求来自何方</li>
<li>无意义的请求也会照单全收，无法阻止Dos攻击</li>
</ul>
<p><strong>查明对手的证书</strong></p>
<p>单单使用HTTP协议无法确定通信方，但使用SSL则可以</p>
<p>SSL不仅提供加密处理，还提供了一种名为证书的手段，用于确定通信方</p>
<p>证书由值得信任的第三方机构提供，用以证明服务器和客户端是实际存在的，伪造证书在技术上异常困难，因此只要能确认证书，就能判断通信方的真实意图</p>
<p>通过使用证书证明通信方就是意料中的服务器，减少了个人信息泄露的可能</p>
<p>客户端持有证书可以用于完成个人身份的确认，也可以用于web网站的认证环节</p>
<h4 id="7-1-3-无法证明报文完整性，可能已遭篡改"><a href="#7-1-3-无法证明报文完整性，可能已遭篡改" class="headerlink" title="7.1.3 无法证明报文完整性，可能已遭篡改"></a>7.1.3 无法证明报文完整性，可能已遭篡改</h4><p><strong>接收到的内容可能有误</strong></p>
<p>HTTP协议无法证明通信报文的完整性，也就是说，没有任何办法确认发送的报文和通信方接收到的报文是相同的</p>
<p><strong>如何防止篡改</strong></p>
<p>常用的方法是用MD5和SHA-1等散列值校验的方法，以及用来确认文件数字签名的方法（PGP）</p>
<p>用户需要自己查看下载的文件是否是原来服务器上的文件，浏览器无法帮助查看</p>
<p>但一旦MD5和PGP本身被改写，用户是无法察觉到的，因此无法确认结果一定正确</p>
<p>因此有必要使用HTTPS</p>
<h3 id="7-2-HTTP-加密-认证-完整性保护-x3D-HTTPS"><a href="#7-2-HTTP-加密-认证-完整性保护-x3D-HTTPS" class="headerlink" title="7.2 HTTP+加密+认证+完整性保护&#x3D;HTTPS"></a>7.2 HTTP+加密+认证+完整性保护&#x3D;HTTPS</h3><h4 id="7-2-1-HTTP加上加密处理和认证及完整性保护后就是HTTPS"><a href="#7-2-1-HTTP加上加密处理和认证及完整性保护后就是HTTPS" class="headerlink" title="7.2.1 HTTP加上加密处理和认证及完整性保护后就是HTTPS"></a>7.2.1 HTTP加上加密处理和认证及完整性保护后就是HTTPS</h4><p>使用HTTPS通信时，使用<code>https://</code>，访问HTTPS通信有效的web网站时，地址栏会出现一个锁。对HTTPS的显示方式会因浏览器不同有所改变</p>
<h4 id="7-2-2-HTTPS是身披SSL外壳的HTTP"><a href="#7-2-2-HTTPS是身披SSL外壳的HTTP" class="headerlink" title="7.2.2 HTTPS是身披SSL外壳的HTTP"></a>7.2.2 HTTPS是身披SSL外壳的HTTP</h4><p>HTTPS并不是全新的协议，只是HTTP通信接口部分用SSL和TLS协议代替</p>
<p>通常HTTP直接和TCP通信，使用SSL时，先和SSL通信，再由SSL和TCP通信</p>
<p>SSL是独立于HTTP的协议，不光HTTP，其他应用层协议也可配合SSL使用</p>
<h4 id="7-2-3-相互交换密钥的公开密钥交换技术"><a href="#7-2-3-相互交换密钥的公开密钥交换技术" class="headerlink" title="7.2.3 相互交换密钥的公开密钥交换技术"></a>7.2.3 相互交换密钥的公开密钥交换技术</h4><p><strong>共享加密密钥的困境</strong></p>
<p>加密和解密公用一个密钥的方式称为共享密钥加密（对称密钥加密）</p>
<p>但发送密钥有被窃听的风险，不发送通信方就无法解密，而且若密钥能安全发送，直接发送数据也能安全到达</p>
<p><strong>使用两种密钥的公开密钥加密</strong></p>
<p>公开密钥加密使用非对称的密钥。一把叫私钥，一把叫公钥。私钥不能让其他任何人知道，公钥可以发送给任何人</p>
<p>发送数据一方使用对方的公钥对数据进行加密，对方收到加密后的数据后使用私钥解密</p>
<p>只有公钥对密文还原是非常困难的</p>
<p><strong>HTTPS使用混合加密机制</strong></p>
<p>HTTPS使用共享密钥加密和公开密钥加密两者并用的混合加密机制。但公开密钥加密比共享密钥加密速度慢</p>
<p>因此充分利用二者优势，在交换密钥环节使用公开密钥加密，之后建立通信交换报文阶段使用共享密钥加密方式</p>
<p>即用公开密钥加密之后会在共享密钥加密过程中使用的密钥。</p>
<h4 id="7-2-4-证明公开密钥正确的证书"><a href="#7-2-4-证明公开密钥正确的证书" class="headerlink" title="7.2.4 证明公开密钥正确的证书"></a>7.2.4 证明公开密钥正确的证书</h4><p>公开密钥加密还是存在一些问题的，那就是无法证明公钥本身是否货真价实</p>
<p>为解决这个问题，可以由数字证书认证机构和其相关机关颁布的公开密钥证书</p>
<p>数字证书认证机构会将服务器运营人员发来的公开密钥添加进入数字证书并标记上数字签名，服务器取得了数字证书后将其发给客户端，客户端可使用数字证书机构的公开密钥对证书上的数字签名进行验证。一旦验证通过，客户端即可确定：1.认证服务器的公开密钥的是真实有效的数字机构 2.服务器的公开密钥值得信赖</p>
<p>认证机构的公共密钥也必须安全的转交给客户端，因此多数浏览器开发商都会事先在浏览器内部植入常用认证机关的公钥</p>
<p><strong>EV SSL证书</strong></p>
<p>此证书可以确认服务器背后运营的企业真实存在</p>
<p>持有该证书的网站的浏览器地址栏处的背景颜色是绿色的</p>
<p>愿意图是防止用户被钓鱼攻击，但实际效果不佳，因为大部分用户不了解该证书相关知识，并不会注意</p>
<p><strong>客户端证书</strong></p>
<p>客户端也可以申请客户端证书，发挥服务器证书相同的作用</p>
<p>但每申请一张证书都要相应的费用，安装证书也需要用户自身的知识水平，客户端证书只在少数情况下使用</p>
<p>如银行的网上银行采用客户端证书，登录网银时不仅要确认id和密码，还需要客户端证书来确认是否从特定终端上访问</p>
<p>客户端证书只能证明客户端实际存在，却无法证明客户端用户身份，若用户控制了计算机的使用权，也就拥有了客户端证书的使用权</p>
<p><strong>自签名证书</strong></p>
<p>由个体自己给自己的服务器颁布的证书称为自签名证书。独立构建的认证机构被称为自认证机构。自签名证书在互联网上无法被当作证书使用</p>
<p>当访问使用自签名证书的网站时，会提示”该网站的证书存在问题“等提示</p>
<h4 id="7-2-5-HTTPS的安全通信机制"><a href="#7-2-5-HTTPS的安全通信机制" class="headerlink" title="7.2.5 HTTPS的安全通信机制"></a>7.2.5 HTTPS的安全通信机制</h4><p>以TLS握手为例</p>
<ul>
<li>客户端发送clienthello消息，包含TLS版本，加密算法集，随机数</li>
<li>服务器端接收消息后发送serverHello消息，包含TLS版本，加密算法集，随机数</li>
<li>服务器端发送包含公钥的证书</li>
<li>服务器端发送serverHelloDone消息</li>
<li>客户端接收服务器端消息后验证证书机构是否权威和服务器是否为值得信赖的服务器，获取公钥</li>
<li>客户端发送由公钥加密的premaster secret</li>
<li>服务器端用私钥解密premaster secret</li>
<li>客户端和服务端使用之前生成的两个随机数＋premaster secret生成master secret用于对之后通信的所有数据加密</li>
<li>客户端发送ChangeCipherSpec消息和用master secret加密的finish消息</li>
<li>服务器端接收并验证，发送ChangeCipherSpec消息和用master secret加密的finish消息</li>
<li>客户端接收并认证，握手结束</li>
</ul>
<hr>
<h2 id="第八章-确认访问用户身份的认证"><a href="#第八章-确认访问用户身份的认证" class="headerlink" title="第八章 确认访问用户身份的认证"></a>第八章 确认访问用户身份的认证</h2><h3 id="8-1-何为认证"><a href="#8-1-何为认证" class="headerlink" title="8.1 何为认证"></a>8.1 何为认证</h3><p>认证用于核实客户端使用者的身份</p>
<p>HTTP&#x2F;1.1的认证方式如下</p>
<ul>
<li><p>BASIC认证（基本认证）</p>
</li>
<li><p>DIGEST认证（摘要认证）</p>
</li>
<li><p>SSL客户端认证</p>
</li>
<li><p>FormBase认证（基于表单认证）</p>
</li>
</ul>
<h3 id="8-2-BASIC认证"><a href="#8-2-BASIC认证" class="headerlink" title="8.2 BASIC认证"></a>8.2 BASIC认证</h3><ul>
<li>用户发送请求后，服务器返回401状态码，返回带WWW-Authenticate首部字段的响应，字段内含有认证方式和Request-URI安全域字符串（realm）</li>
<li>接到401状态码的客户端为了通过认证需要将用户id和密码发送给服务器，发送内容由“ID：密码”组成，经Base64编码处理后写入Authorization字段发送。若用户代理为浏览器，输入ID和密码即可，浏览器自动进行Base64编码</li>
<li>接到含首部字段Authorization请求的服务器对其进行验证，若通过则返回包含Request-URI资源的响应</li>
</ul>
<p>BASIC认证的Base编码并不是加密，可以直接解码为明文，因此在非加密通信的链路上进行认证时有可能被窃听</p>
<p>一般的浏览器无法实现认证注销</p>
<h3 id="8-3-DIGEST认证"><a href="#8-3-DIGEST认证" class="headerlink" title="8.3 DIGEST认证"></a>8.3 DIGEST认证</h3><p>DIGEST认证不会像BASIC认证那样直接发送明文密码</p>
<p>但同样安全系数有限，不被常用</p>
<h3 id="8-4-SSL客户端认证"><a href="#8-4-SSL客户端认证" class="headerlink" title="8.4 SSL客户端认证"></a>8.4 SSL客户端认证</h3><p>服务器端发送报文要求客户端发送客户端证书内容，客户端发送含公钥的客户端证书，服务器端收到证书后开启HTTPS连接</p>
<p><strong>双因素认证</strong></p>
<p>通过客户端认证确认终端，通过表单认证确认是用户本人操作，这种认证方式称为双因素认证</p>
<h3 id="8-5-基于表单认证"><a href="#8-5-基于表单认证" class="headerlink" title="8.5 基于表单认证"></a>8.5 基于表单认证</h3><p>并不是在HTTP中定义。客户端会向服务器的web应用发送登录信息，按登录信息的验证结果进行认证</p>
<p>现实中大多为基于表单的认证</p>
<p><strong>session管理和cookie应用</strong></p>
<p>客户端向服务器发送账号密码，服务器端验证后返回包含session-id的cookie，客户端再次登录时直接发送含session的cookie，服务器通过验证session信息验证是否为以登录的用户</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP/IP知识点总结</title>
    <url>/2022/08/04/TCP_IP/</url>
    <content><![CDATA[<h1 id="TCP-x2F-IP"><a href="#TCP-x2F-IP" class="headerlink" title="TCP&#x2F;IP"></a>TCP&#x2F;IP</h1><h2 id="第一章-网络基础知识"><a href="#第一章-网络基础知识" class="headerlink" title="第一章 网络基础知识"></a>第一章 网络基础知识</h2><h3 id="1-1-计算机网络出现的背景"><a href="#1-1-计算机网络出现的背景" class="headerlink" title="1.1 计算机网络出现的背景"></a>1.1 计算机网络出现的背景</h3><h4 id="1-1-1-计算机的普及及多样化"><a href="#1-1-1-计算机的普及及多样化" class="headerlink" title="1.1.1 计算机的普及及多样化"></a>1.1.1 计算机的普及及多样化</h4><p>如题</p>
<h4 id="1-1-2-从独立模式到网络互连模式"><a href="#1-1-2-从独立模式到网络互连模式" class="headerlink" title="1.1.2 从独立模式到网络互连模式"></a>1.1.2 从独立模式到网络互连模式</h4><ul>
<li>独立模式（单机模式）：计算机未接入网络，各自独立使用的模式</li>
<li>网络互联模式：<ul>
<li>WAN: 广域网</li>
<li>MAN: 城域网</li>
<li>LAN: 局域网</li>
</ul>
</li>
</ul>
<h3 id="1-2-计算机与网络发展的七个阶段"><a href="#1-2-计算机与网络发展的七个阶段" class="headerlink" title="1.2 计算机与网络发展的七个阶段"></a>1.2 计算机与网络发展的七个阶段</h3><h4 id="1-2-1-批处理"><a href="#1-2-1-批处理" class="headerlink" title="1.2.1 批处理"></a>1.2.1 批处理</h4><p>事先将用户程序和数据装入卡带或磁带，并由计算机按照一定的顺序读取，使程序和数据能够批量得到处理的方式</p>
<p>此时计算机还不是普通人使用的工具</p>
<h4 id="1-2-2-分时系统"><a href="#1-2-2-分时系统" class="headerlink" title="1.2.2 分时系统"></a>1.2.2 分时系统</h4><p>分时系统（TSS）指多台终端与同一个计算机相连，允许多个用户同时使用一台计算机系统</p>
<h4 id="1-2-3-计算机间的通信"><a href="#1-2-3-计算机间的通信" class="headerlink" title="1.2.3 计算机间的通信"></a>1.2.3 计算机间的通信</h4><p>分时系统中，一台计算机与多个终端相连，但计算机之间是不能相连的，这时候如果需要转移数据，需要将数据保存在软盘，磁带等介质中，再将介质送到目的计算机，相当繁琐</p>
<p>计算机间的通信技术（计算机与计算机之间由通信链路相连）使人们能很轻松的读取另一台计算机中的数据，极大的缩短了传送数据的时间</p>
<h3 id="1-3-协议"><a href="#1-3-协议" class="headerlink" title="1.3 协议"></a>1.3 协议</h3><p>在计算机通信中，实现达成一个详细的约定，并遵循这一约定进行处理。这种约定就是”协议“</p>
<h4 id="1-3-5-分组交换协议"><a href="#1-3-5-分组交换协议" class="headerlink" title="1.3.5 分组交换协议"></a>1.3.5 分组交换协议</h4><p>分组交换是指将大数据分割成一个个交包（packet）的较小单位进行传输的方法。</p>
<h3 id="1-5-协议分层与OSI参考模型"><a href="#1-5-协议分层与OSI参考模型" class="headerlink" title="1.5 协议分层与OSI参考模型"></a>1.5 协议分层与OSI参考模型</h3><h4 id="1-5-1-协议的分层"><a href="#1-5-1-协议的分层" class="headerlink" title="1.5.1 协议的分层"></a>1.5.1 协议的分层</h4><p>ISO制定标准化OSI之前，提出了作为通信协议设计指标的OSI参考模型,这一模型将通信协议中必要的功能分为了七层</p>
<p>每一分层接收由它下一分层提供的特定服务，并为自己的上一层提供特定服务。上下层之间交互时遵循的约定叫”接口“，同一层之间交互所遵循的约定叫”协议“</p>
<h4 id="1-5-3-OSI参考模型"><a href="#1-5-3-OSI参考模型" class="headerlink" title="1.5.3 OSI参考模型"></a>1.5.3 OSI参考模型</h4><p>OSI参考模型将分组通信协议整理并分为了易于理解的七个分层</p>
<ul>
<li>7.应用层：针对特定应用的协议</li>
<li>6.表示层：设备固有数据格式和网络标准数据格式的转换</li>
<li>5.会话层：通信管理。负责建立和断开通信连接。管理传输层以下的分层</li>
<li>4.传输层：管理两个节点之间的数据传输，负责可靠传输</li>
<li>3.网络层：地址管理和路由选择</li>
<li>2.数据链路层：互连设备之间传送和识别数据帧</li>
<li>1.物理层：以”0“，”1“代表电压的高低，灯光的闪灭。界定连接器和网线的规格</li>
</ul>
<h3 id="1-7-传输方式的分类"><a href="#1-7-传输方式的分类" class="headerlink" title="1.7 传输方式的分类"></a>1.7 传输方式的分类</h3><h4 id="1-7-1-面向有连接型和无连接型"><a href="#1-7-1-面向有连接型和无连接型" class="headerlink" title="1.7.1 面向有连接型和无连接型"></a>1.7.1 面向有连接型和无连接型</h4><ul>
<li>面向有连接型：在发送数据前，需要在收发主机之间连接一条通信链路</li>
<li>面向无连接型：不要求建立和断开连接，发送端可于任何时候自由发送数据。接收端不知道会在何时从哪里收到数据</li>
</ul>
<h4 id="1-7-2-电路交换和分组交换"><a href="#1-7-2-电路交换和分组交换" class="headerlink" title="1.7.2 电路交换和分组交换"></a>1.7.2 电路交换和分组交换</h4><ul>
<li>电路交换：两个计算机独占一条电路，其他计算机无法使用</li>
<li>分组交换：将数据分为一个个分组，多台计算机可以同时通信</li>
</ul>
<h4 id="1-7-3-根据接收端数量分类"><a href="#1-7-3-根据接收端数量分类" class="headerlink" title="1.7.3 根据接收端数量分类"></a>1.7.3 根据接收端数量分类</h4><ul>
<li>单播：一对一通信</li>
<li>广播：一台主机发送到与之相连的所有其他主机</li>
<li>多播：一台主机发送到与之相连的特定一组主机</li>
<li>任播：从特定的多台主机中选出一台进行通信</li>
</ul>
<h3 id="1-8-地址"><a href="#1-8-地址" class="headerlink" title="1.8 地址"></a>1.8 地址</h3><h4 id="1-8-1-地址的唯一性"><a href="#1-8-1-地址的唯一性" class="headerlink" title="1.8.1 地址的唯一性"></a>1.8.1 地址的唯一性</h4><p>同一个通信网络中不允许有两个相同地址的通信主体存在</p>
<h4 id="1-8-2-地址的层次性"><a href="#1-8-2-地址的层次性" class="headerlink" title="1.8.2 地址的层次性"></a>1.8.2 地址的层次性</h4><p>将地址分层从而实现更快速的定位</p>
<p>IP地址是分层的，MAC地址不分层</p>
<h3 id="1-9-网络构成要素"><a href="#1-9-网络构成要素" class="headerlink" title="1.9 网络构成要素"></a>1.9 网络构成要素</h3><h4 id="1-9-1-通信媒介与数据链路"><a href="#1-9-1-通信媒介与数据链路" class="headerlink" title="1.9.1 通信媒介与数据链路"></a>1.9.1 通信媒介与数据链路</h4><p>计算机之间通过电缆相互连接</p>
<p>根据数据链路（相互直连的设备之间进行通信所涉及的协议及网络）不同而选用的电缆类型也不尽相同</p>
<h4 id="1-9-2-网卡"><a href="#1-9-2-网卡" class="headerlink" title="1.9.2 网卡"></a>1.9.2 网卡</h4><p>任何一台计算机连接网络都必须使用网卡</p>
<h4 id="1-9-3-中继器"><a href="#1-9-3-中继器" class="headerlink" title="1.9.3 中继器"></a>1.9.3 中继器</h4><p>中继器是在OSI模型的第一层——物理层面延长网络的设备</p>
<p>由电缆传来的电信号或光信号通过中继器的波形调整和放大传给另一个电缆</p>
<p>中继器不能改变传输速率，是对减弱的信号进行放大的设备</p>
<p>中继器进行的网络延长并不能无限放大</p>
<p>有的中继器提供多个端口服务，也被成为集线器。集线器每个端口都可以看作一个中继器</p>
<h4 id="1-9-4-网桥-x2F-2层交换机"><a href="#1-9-4-网桥-x2F-2层交换机" class="headerlink" title="1.9.4 网桥&#x2F;2层交换机"></a>1.9.4 网桥&#x2F;2层交换机</h4><p>网桥是在OSI模型第二层——数据链路层面连接两个网络的设备</p>
<h4 id="1-9-5-路由器-x2F-3层交换机"><a href="#1-9-5-路由器-x2F-3层交换机" class="headerlink" title="1.9.5 路由器&#x2F;3层交换机"></a>1.9.5 路由器&#x2F;3层交换机</h4><p>路由器是在OSI模型的第三层——网络层面上连接两个网络，并对分组报文进行转发的设备</p>
<p>网桥根据MAC地址处理，而路由器根据IP地址处理</p>
<p>路由器还具有分担网络负荷的作用，有些路由器具有一定的网络安全功能</p>
<h4 id="1-9-6-4-7层交换机"><a href="#1-9-6-4-7层交换机" class="headerlink" title="1.9.6 4-7层交换机"></a>1.9.6 4-7层交换机</h4><p>4-7层交换机负责处理OSI模型中从传输层到应用层的数据</p>
<h4 id="1-9-7-网关"><a href="#1-9-7-网关" class="headerlink" title="1.9.7 网关"></a>1.9.7 网关</h4><p>网关是OSI参考模型中负责将传输层到应用层的协议的转换和数据的转发的设备</p>
<p>只转发数据的网关被成为应用网关。代理服务器就是应用网关</p>
<h3 id="1-10-现代网络实态"><a href="#1-10-现代网络实态" class="headerlink" title="1.10 现代网络实态"></a>1.10 现代网络实态</h3><p>由骨干网和边缘网络组成</p>
<h4 id="1-10-2-互联网通信"><a href="#1-10-2-互联网通信" class="headerlink" title="1.10.2 互联网通信"></a>1.10.2 互联网通信</h4><p>联网之后，汇集到无线局域网路由器和最近交换机的通信再次被连接到“接入层”。甚至通过“边缘网络”或“主干网”实现与目标地址之间的通信</p>
<h4 id="1-10-3-移动通信"><a href="#1-10-3-移动通信" class="headerlink" title="1.10.3 移动通信"></a>1.10.3 移动通信</h4><p>手机一开机就会自动与最近的基站进行无线通信。基站本身相当于网络中的“接入层”</p>
<p>手机终端之间的通信通过基站通信</p>
<hr>
<h2 id="第二章-TCP-x2F-IP基础知识"><a href="#第二章-TCP-x2F-IP基础知识" class="headerlink" title="第二章 TCP&#x2F;IP基础知识"></a>第二章 TCP&#x2F;IP基础知识</h2><h3 id="2-1-TCP-x2F-IP出现的背景及历史"><a href="#2-1-TCP-x2F-IP出现的背景及历史" class="headerlink" title="2.1 TCP&#x2F;IP出现的背景及历史"></a>2.1 TCP&#x2F;IP出现的背景及历史</h3><p>略</p>
<h3 id="2-2-TCP-x2F-IP的标准化"><a href="#2-2-TCP-x2F-IP的标准化" class="headerlink" title="2.2 TCP&#x2F;IP的标准化"></a>2.2 TCP&#x2F;IP的标准化</h3><h4 id="2-2-1-TCP-x2F-IP的具体含义"><a href="#2-2-1-TCP-x2F-IP的具体含义" class="headerlink" title="2.2.1 TCP&#x2F;IP的具体含义"></a>2.2.1 TCP&#x2F;IP的具体含义</h4><p>很多情况下，TCP&#x2F;IP协议指的是利用IP通信时所必须用到的协议群的统称</p>
<h4 id="2-2-2-TCP-x2F-IP标准化精髓"><a href="#2-2-2-TCP-x2F-IP标准化精髓" class="headerlink" title="2.2.2 TCP&#x2F;IP标准化精髓"></a>2.2.2 TCP&#x2F;IP标准化精髓</h4><ul>
<li>具有开放性</li>
<li>注重实用性</li>
</ul>
<h4 id="2-2-3-TCP-x2F-IP规范——RFC"><a href="#2-2-3-TCP-x2F-IP规范——RFC" class="headerlink" title="2.2.3 TCP&#x2F;IP规范——RFC"></a>2.2.3 TCP&#x2F;IP规范——RFC</h4><h3 id="2-3-互联网基础知识"><a href="#2-3-互联网基础知识" class="headerlink" title="2.3 互联网基础知识"></a>2.3 互联网基础知识</h3><h4 id="2-3-1-互联网定义"><a href="#2-3-1-互联网定义" class="headerlink" title="2.3.1 互联网定义"></a>2.3.1 互联网定义</h4><p>从字面上来看internet是将多个网络连接形成一个更大的网络，意为“国际网”</p>
<p>互联网是指由阿帕网发展而来，互联全世界的计算机网络</p>
<h4 id="2-3-2-互联网与TCP-x2F-IP的关系"><a href="#2-3-2-互联网与TCP-x2F-IP的关系" class="headerlink" title="2.3.2 互联网与TCP&#x2F;IP的关系"></a>2.3.2 互联网与TCP&#x2F;IP的关系</h4><p>互联网的协议就是TCP&#x2F;IP，TCP&#x2F;IP就是互联网的协议</p>
<h4 id="2-3-3-互联网的结构"><a href="#2-3-3-互联网的结构" class="headerlink" title="2.3.3 互联网的结构"></a>2.3.3 互联网的结构</h4><p>互联网中的每个网络都是由骨干网和末端网组成的。每个网络之间通过NOC（网络操作中心）相连。如果网络的运营商不同，网络连接方式和使用方法也有不同，连接这种异构网络需要IX（网络交换中心）的支持</p>
<p>互联网就是众多异构网络通过IX互连的巨型网络</p>
<h4 id="2-3-4-ISP和区域网"><a href="#2-3-4-ISP和区域网" class="headerlink" title="2.3.4 ISP和区域网"></a>2.3.4 ISP和区域网</h4><p>连接互联网需要向ISP或区域网提出申请</p>
<h3 id="2-4-TCP-x2F-IP协议分层模型"><a href="#2-4-TCP-x2F-IP协议分层模型" class="headerlink" title="2.4 TCP&#x2F;IP协议分层模型"></a>2.4 TCP&#x2F;IP协议分层模型</h3><h4 id="2-4-1-TCP-x2F-IP与OSI参考模型"><a href="#2-4-1-TCP-x2F-IP与OSI参考模型" class="headerlink" title="2.4.1 TCP&#x2F;IP与OSI参考模型"></a>2.4.1 TCP&#x2F;IP与OSI参考模型</h4><ul>
<li>应用层：对应OSI应用层，表示层，会话层</li>
<li>传输层：对应OSI传输层</li>
<li>互联网层：对应OSI网络层</li>
<li>网卡层：对应OSI数据链路层</li>
<li>硬件（物理层）：对应OSI物理层</li>
</ul>
<h4 id="2-4-2-硬件（物理层）"><a href="#2-4-2-硬件（物理层）" class="headerlink" title="2.4.2 硬件（物理层）"></a>2.4.2 硬件（物理层）</h4><p>TCP&#x2F;IP底层是负责数据传输的硬件（相当于电话线路等物理设备）</p>
<h4 id="2-4-3-网络接口层"><a href="#2-4-3-网络接口层" class="headerlink" title="2.4.3 网络接口层"></a>2.4.3 网络接口层</h4><p>网络接口层利用以太网中的数据链路进行通信，属于接口层。它可以被当作让网卡起作用的“驱动程序”（驱动程序是在操作系统与硬件之间起桥梁作用的软件）</p>
<h4 id="2-4-4-互联网层（网络层）"><a href="#2-4-4-互联网层（网络层）" class="headerlink" title="2.4.4 互联网层（网络层）"></a>2.4.4 互联网层（网络层）</h4><p>互联网层使用IP协议。IP协议基于IP地址转发分包数据</p>
<ul>
<li><p>IP</p>
<p>IP是跨越网络传送数据包，使整个互联网都能收到数据的协议。这期间它使用IP地址作为主机的标识</p>
<p>IP还隐含着数据链路层的功能。通过IP，互相通信的主机无论经过怎样的底层数据链路都能实现通信</p>
<p>IP不具有重发机制，属于非可靠传输协议</p>
</li>
<li><p>ICMP</p>
<p>IP数据包在发送途中一旦发生异常导致无法到达目标地址时，需要给发送端发送一个异常通知。ICMP就是为实现这一功能制定的</p>
</li>
<li><p>ARP</p>
<p>从分组数据包的IP地址中解析出MAC地址的一种协议</p>
</li>
</ul>
<h4 id="2-4-5-传输层"><a href="#2-4-5-传输层" class="headerlink" title="2.4.5 传输层"></a>2.4.5 传输层</h4><p>传输层的主要功能是让应用程序间实现通信</p>
<ul>
<li>TCP：面向有连接的传输层协议。保证两端通信主机之间的通信可达。为了建立和断开连接，有时会造成网络流量的浪费。不利于视频会议等场合使用</li>
<li>UDP：面向无连接的传输层协议。不会关注对端是否真收到了传送过去的数据，多用于分组较少或多播，广播通信以及视频通信等多媒体领域</li>
</ul>
<h4 id="2-4-6-应用层"><a href="#2-4-6-应用层" class="headerlink" title="2.4.6 应用层"></a>2.4.6 应用层</h4><p>TCP&#x2F;IP的应用的架构绝大多数属于客户端&#x2F;服务端模型</p>
<ul>
<li><p>WWW</p>
<p>中文叫万维网，是一种互联网上数据读取的规范，也叫Web，W3。用户在一种叫做Web浏览器的软件上借助鼠标和键盘进行网络冲浪</p>
<p>浏览器与服务器端之间的通信使用的协议是HTTP，传输协议的主要格式是HTML</p>
</li>
<li><p>电子邮件</p>
<p>发送电子邮件使用的协议叫做SMTP</p>
<p>经MIME协议拓展后，可以发送声音，图像等各种各样的信息</p>
</li>
<li><p>文件传输（FTP）</p>
<p>在FTP中进行文件传播时会创建两个TCP连接，分别是发送请求时用到的控制连接和实际传输时用到的数据连接</p>
</li>
<li><p>远程登陆</p>
<p>使用TELNET和SSH两种协议</p>
</li>
<li><p>网络管理</p>
<p>使用SNMP协议。被管理的路由器，网桥等被称作SNMP代理，进行管理的叫做管理器。SNMP是管理器和代理需要用到的协议</p>
</li>
</ul>
<h3 id="2-5-TCP-x2F-IP-分层模型和通讯示例"><a href="#2-5-TCP-x2F-IP-分层模型和通讯示例" class="headerlink" title="2.5 TCP&#x2F;IP 分层模型和通讯示例"></a>2.5 TCP&#x2F;IP 分层模型和通讯示例</h3>]]></content>
      <categories>
        <category>技术</category>
        <category>更新中</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>自学Vue第一章笔记</title>
    <url>/2022/08/03/VUE-chapter3/</url>
    <content><![CDATA[<h1 id="VUE"><a href="#VUE" class="headerlink" title="VUE"></a>VUE</h1><p>创建Vue应用:<code>Vue.createApp().mount(&quot;&quot;)</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app=<span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">        <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">name</span>:<span class="string">&quot;世界&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="使用data-绑定html元素"><a href="#使用data-绑定html元素" class="headerlink" title="使用data()绑定html元素"></a>使用data()绑定html元素</h4><ul>
<li>要渲染的元素用<code>&#123;&#123;&#125;&#125;</code>括起来，如<code>&#123;&#123;name&#125;&#125;</code></li>
<li>data是一个函数，返回一个类，类中声明需要渲染的元素和对应的值，如上述代码</li>
</ul>
<h4 id="使用v-bind绑定属性元素"><a href="#使用v-bind绑定属性元素" class="headerlink" title="使用v-bind绑定属性元素"></a>使用v-bind绑定属性元素</h4><p>对于html标签中的属性，不能通过直接用<code>&#123;&#123;&#125;&#125;</code>绑定，这时候需要使用v-bind</p>
<p>在html中使用v-bind</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;link&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>也可以省略v-bind只保留：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">&quot;link&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后在data中添加</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app=<span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">        <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">link</span>:<span class="string">&quot;https://website.com&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="使用v-for绑定列表元素"><a href="#使用v-for绑定列表元素" class="headerlink" title="使用v-for绑定列表元素"></a>使用v-for绑定列表元素</h4><p>对于多个列表元素可以用数组控制</p>
<p>在JavaScript中添加</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app=<span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">        <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">todos</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                  	<span class="attr">content</span>:<span class="string">&quot;goal1&quot;</span>,</span><br><span class="line">                    <span class="attr">complete</span>:<span class="literal">true</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                  	<span class="attr">content</span>:<span class="string">&quot;goal2&quot;</span>,</span><br><span class="line">                    <span class="attr">complete</span>:<span class="literal">true</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                  	<span class="attr">content</span>:<span class="string">&quot;goal3&quot;</span>,</span><br><span class="line">                    <span class="attr">complete</span>:<span class="literal">false</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">                </span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>使用v-for遍历数组只需要在html中加入一行li</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(todo,index) in todos&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">:checked</span>=<span class="string">&quot;todo.complete&quot;</span>&gt;</span>&#123;&#123;index+1&#125;&#125;:&#123;&#123;todo.content&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>v-for采用类似js中for-in的遍历方式，（）中第一个值是访问的数组元素，第二个是数组元素对应下标</p>
<p>采用js访问对象属性相同的方法访问数组中对象元素中的属性</p>
<h4 id="v-if和v-show"><a href="#v-if和v-show" class="headerlink" title="v-if和v-show"></a>v-if和v-show</h4><p>v-if可以通过js判断语句返回的值条件渲染html，使用<code>v-if,v-else-if,v-else</code>是要紧挨着</p>
<p>v-show则通过给元素设置display：none来实现显示与否</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app=<span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">        <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">books</span>:[<span class="string">&quot;js权威指南&quot;</span>,<span class="string">&quot;css权威指南&quot;</span>,<span class="string">&quot;js高级编程&quot;</span>],</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-show</span>=<span class="string">&quot;books.length===0&quot;</span>&gt;</span>没有图书<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">v-show</span>=<span class="string">&quot;books.length&gt;0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;book in books&quot;</span>&gt;</span>&#123;&#123;book&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="使用-注册事件"><a href="#使用-注册事件" class="headerlink" title="使用@注册事件"></a>使用@注册事件</h4><p>在html中使用@来注册事件及其响应</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;showAnswer=!showAnswer&quot;</span>&gt;</span>&#123;&#123;showAnswer?&quot;隐藏答案&quot;:&quot;显示答案&quot;&#125;&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="使用computed计算方法"><a href="#使用computed计算方法" class="headerlink" title="使用computed计算方法"></a>使用computed计算方法</h4><p>使用computed计算方法把一些需要重复执行的内容写入函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app=<span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;val=<span class="literal">false</span>&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">computed</span>:&#123;</span><br><span class="line">        <span class="title function_">label</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">val</span>=!<span class="variable language_">this</span>.<span class="property">val</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">val</span>?<span class="string">&quot;1&quot;</span>:<span class="string">&quot;2&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&quot;#div&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在html加入计算函数</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">app</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        &#123;&#123;label&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="使用methods方法"><a href="#使用methods方法" class="headerlink" title="使用methods方法"></a>使用methods方法</h4><p>使用methods方法处理事件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app=<span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">judgement</span>:<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>:&#123;</span><br><span class="line">        <span class="title function_">change</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">judgement</span>=!<span class="variable language_">this</span>.<span class="property">judgement</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>html中使用</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;change&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123;judgement&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="使用watch注册监听器"><a href="#使用watch注册监听器" class="headerlink" title="使用watch注册监听器"></a>使用watch注册监听器</h4><p>使用watch可以监听变量值的变化</p>
<p>watch中的函数名必须为需要监听的变量名,它有两个参数，分别是新值和旧值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app=<span class="title class_">Vue</span>.<span class="title function_">ccreateApp</span>(&#123;</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">judgement</span>:<span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>:&#123;</span><br><span class="line">        <span class="title function_">change</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">judgement</span>=!<span class="variable language_">this</span>.<span class="property">judgement</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attr">watch</span>:&#123;</span><br><span class="line">        <span class="title function_">judgement</span>(<span class="params">newVal,oldVal</span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(newVal)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;change&quot;</span>&gt;</span>judgement<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>点击按钮时会控制台输出改变后的值</p>
<h4 id="computed和methods的区别"><a href="#computed和methods的区别" class="headerlink" title="computed和methods的区别"></a>computed和methods的区别</h4><ul>
<li>计算属性缓存结果，多次使用计算属性或组件刷新时，如果计算属性使用的data属性无变化，computed会直接从缓存中读取</li>
<li>methods不缓存结果，任何属性变化都会导致methods重新执行，执行大量运算时比较慢。方法也可以作为普通的js函数被computed调用</li>
</ul>
<h4 id="computed-和-watch的区别"><a href="#computed-和-watch的区别" class="headerlink" title="computed 和 watch的区别"></a>computed 和 watch的区别</h4><ul>
<li>computed一般不直接修改data中属性，而是经过计算返回一个新值，使用时能像data中属性一样使用，data中的属性被修改后，计算属性也立即更新</li>
<li>watch监听到属性变化时直接修改data中数据值，不会返回计算结果，不能直接使用，需要在data中额外维护一个属性供watch使用</li>
</ul>
<p><img src="/image/img.png" alt="computed和watch的区别"></p>
<h4 id="methods和watch的区别"><a href="#methods和watch的区别" class="headerlink" title="methods和watch的区别"></a>methods和watch的区别</h4><ul>
<li>methods定义的方法可以在watch中调用，适合做一些更复杂的计算</li>
</ul>
<h4 id="使用事件监听处理表单输入数据"><a href="#使用事件监听处理表单输入数据" class="headerlink" title="使用事件监听处理表单输入数据"></a>使用事件监听处理表单输入数据</h4><p>使用methods方法定义事件处理函数，@input监听事件</p>
<h4 id="使用双向绑定，v-model处理表单输入数据"><a href="#使用双向绑定，v-model处理表单输入数据" class="headerlink" title="使用双向绑定，v-model处理表单输入数据"></a>使用双向绑定，v-model处理表单输入数据</h4><p><img src="/image/img_1.png" alt="双向绑定是什么"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app=<span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">        <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">username</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">methods</span>: &#123;</span><br><span class="line">            <span class="title function_">calculate</span>(<span class="params">e</span>) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">username</span>=e.<span class="property">target</span>.<span class="property">value</span>;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="title function_">clear</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">username</span>=<span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>html部分：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;username&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;calculate&quot;</span>&gt;</span>&#123;&#123;username&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;clear&quot;</span>&gt;</span>清空<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="其他表单控件的处理"><a href="#其他表单控件的处理" class="headerlink" title="其他表单控件的处理"></a>其他表单控件的处理</h4><p>其他表单控件的双向绑定绑定的为其value值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app=<span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">       <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> &#123;</span><br><span class="line">               <span class="attr">username</span>:<span class="string">&quot;&quot;</span>,</span><br><span class="line">               <span class="attr">gender</span>:<span class="string">&quot;&quot;</span>,</span><br><span class="line">               <span class="attr">checkbox</span>:[],</span><br><span class="line">               <span class="attr">introduction</span>:<span class="string">&quot;&quot;</span></span><br><span class="line">           &#125;;</span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="attr">methods</span>: &#123;</span><br><span class="line">           <span class="title function_">clear</span>(<span class="params"></span>) &#123;</span><br><span class="line">               <span class="variable language_">this</span>.<span class="property">username</span>=<span class="string">&quot;&quot;</span>;</span><br><span class="line">               <span class="variable language_">this</span>.<span class="property">gender</span>=<span class="string">&quot;&quot;</span>;</span><br><span class="line">               <span class="variable language_">this</span>.<span class="property">checkbox</span>=[];</span><br><span class="line">               <span class="variable language_">this</span>.<span class="property">introduction</span>=<span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">   app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;username&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;姓名&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;clear&quot;</span>&gt;</span>清除<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;male&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;gender&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>男<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;female&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;gender&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>女<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;interest&quot;</span> <span class="attr">value</span>=<span class="string">&quot;answer1&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>选项一<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;interest&quot;</span> <span class="attr">value</span>=<span class="string">&quot;answer2&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>选项二<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;interest&quot;</span> <span class="attr">value</span>=<span class="string">&quot;answer3&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>选项三<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">rows</span>=<span class="string">&quot;10&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;introduction&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;自我介绍&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;username&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;gender&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;checkbox&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;introduction&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="表单事件提交处理和事件修饰符"><a href="#表单事件提交处理和事件修饰符" class="headerlink" title="表单事件提交处理和事件修饰符"></a>表单事件提交处理和事件修饰符</h4><p>表单事件处理函数使用@submit绑定，使用.绑定事件修饰符，如<code>@submit.prevent</code>绑定禁止默认行为（e.preventDefault）</p>
<h4 id="根据条件控制class"><a href="#根据条件控制class" class="headerlink" title="根据条件控制class"></a>根据条件控制class</h4><p>使用v-bind:绑定class属性，在data中定义要使用的样式，使用数组设置多个class，使用对象形式完成根据条件修改样式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app=<span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">        <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">blue</span>: <span class="string">&quot;blue&quot;</span>,</span><br><span class="line">                <span class="attr">red</span>: <span class="string">&quot;red&quot;</span>,</span><br><span class="line">                <span class="attr">isHidden</span>:<span class="literal">false</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">methods</span>: &#123;</span><br><span class="line">            <span class="title function_">clear</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">isHidden</span>=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">:class</span>=<span class="string">&quot;[blue,red,&#123;hide: isHidden&#125;]&quot;</span>&gt;</span>A paragraph<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;clear&quot;</span>&gt;</span>清除<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>自学Vue第二章笔记</title>
    <url>/2022/08/03/VUE-chapter4/</url>
    <content><![CDATA[<h4 id="v-html在模板中输出html"><a href="#v-html在模板中输出html" class="headerlink" title="v-html在模板中输出html"></a>v-html在模板中输出html</h4><p>使用v-html在标签内输出html，为防止恶意代码，最好使用自己定义的html，对于用户输入要做过滤处理</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app=<span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">        <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">content</span>:<span class="string">&quot;&lt;p&gt;用v-html输出html&lt;/p&gt;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-html</span>=<span class="string">&quot;content&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="v-once只渲染一次模板"><a href="#v-once只渲染一次模板" class="headerlink" title="v-once只渲染一次模板"></a>v-once只渲染一次模板</h4><p>如果只需要显示原始数据，当数据发生改变时不重新渲染，可以使用v-once</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app=<span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">       <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> &#123;</span><br><span class="line">               <span class="attr">list</span>:[],</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">   app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-once</span>&gt;</span>原始长度:&#123;&#123;list.length&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>当前长度:&#123;&#123;list.length&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;this.list.push(this.list.length)&quot;</span>&gt;</span>添加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="v-bind和v-on绑定动态参数"><a href="#v-bind和v-on绑定动态参数" class="headerlink" title="v-bind和v-on绑定动态参数"></a>v-bind和v-on绑定动态参数</h4><p>在：或@后加上中括号[]，在中括号中加入js代码，就可以为v-bind和v-on绑定动态参数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app=<span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">        <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">attr</span>:<span class="string">&quot;placeholder&quot;</span>,</span><br><span class="line">                <span class="attr">event</span>:<span class="string">&quot;change&quot;</span>,</span><br><span class="line">                <span class="attr">value</span>:<span class="string">&quot;请输入内容&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">methods</span>:&#123;</span><br><span class="line">            <span class="title function_">handleInput</span>(<span class="params"></span>)&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;changed!&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">:</span>[<span class="attr">attr</span>]=<span class="string">&quot;value&quot;</span> @[<span class="attr">event</span>]=<span class="string">&quot;handleInput&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="v-for高级用法"><a href="#v-for高级用法" class="headerlink" title="v-for高级用法"></a>v-for高级用法</h4><ul>
<li>v-for循环除了可以遍历数组外还可以遍历对象，形式与遍历数组基本一致</li>
<li>v-for循环中可以为循环变量增添一个key值，当数组或对象中的元素顺序改变时，vue也会做出顺序的改变而不是直接修改值</li>
<li>v-for还可以直接指定一个数，如n in 5,结果输出12345</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app=<span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">        <span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">todo_list</span>:&#123;</span><br><span class="line">                    <span class="attr">todo1</span>:&#123;</span><br><span class="line">                        <span class="attr">id</span>:<span class="number">1</span>,</span><br><span class="line">                        <span class="attr">content</span>:<span class="string">&quot;代办1&quot;</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="attr">todo2</span>:&#123;</span><br><span class="line">                        <span class="attr">id</span>:<span class="number">2</span>,</span><br><span class="line">                        <span class="attr">content</span>:<span class="string">&quot;代办2&quot;</span>,</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="attr">todo3</span>:&#123;</span><br><span class="line">                        <span class="attr">id</span>:<span class="number">3</span>,</span><br><span class="line">                        <span class="attr">content</span>:<span class="string">&quot;代办3&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;todo in todo_list&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;todo.id&quot;</span>&gt;</span>&#123;&#123;todo.content&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;n in 5&quot;</span>&gt;</span>&#123;&#123;n&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="template标签"><a href="#template标签" class="headerlink" title="template标签"></a>template标签</h4><p>使用<code>&lt;template&gt;</code>标签可以只渲染里面的内容而不渲染外层的template标签</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app=<span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">        <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="number">10</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">&quot;value&gt;0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>不会渲染出外层template标签<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="事件传参和多事件处理"><a href="#事件传参和多事件处理" class="headerlink" title="事件传参和多事件处理"></a>事件传参和多事件处理</h4><p>可以在@绑定的事件函数中直接调用函数并传入参数，事件参数固定为$event，想绑定多个事件函数可以用<code>,</code>，事件函数会依次执行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app=<span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">        <span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">todos</span>:[&#123;</span><br><span class="line">                    <span class="attr">content</span>:<span class="string">&quot;代办1&quot;</span>,</span><br><span class="line">                    <span class="attr">id</span>:<span class="number">1</span>,</span><br><span class="line">                &#125;,&#123;</span><br><span class="line">                    <span class="attr">content</span>:<span class="string">&quot;代办2&quot;</span>,</span><br><span class="line">                    <span class="attr">id</span>:<span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">                &#125;,&#123;</span><br><span class="line">                    <span class="attr">content</span>:<span class="string">&quot;代办3&quot;</span>,</span><br><span class="line">                    <span class="attr">id</span>:<span class="number">3</span>,</span><br><span class="line">                &#125;]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">methods</span>:&#123;</span><br><span class="line">            <span class="title function_">calculate</span>(<span class="params">msg,e</span>)&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(msg);</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">clientX</span>+<span class="string">&quot; &quot;</span>+e.<span class="property">clientY</span>);</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="title function_">output</span>(<span class="params">msg</span>)&#123;</span><br><span class="line">                <span class="title function_">alert</span>(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;todo in todos&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;todo.id&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;calculate(todo.content,$event), output(todo.id)&quot;</span>&gt;</span>&#123;&#123;todo.content&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="事件相关修饰符"><a href="#事件相关修饰符" class="headerlink" title="事件相关修饰符"></a>事件相关修饰符</h4><ul>
<li>.prevent:阻止浏览器默认行为</li>
<li>.stop：阻止事件冒泡</li>
<li>.capture:捕获触发，从父元素触发至子元素</li>
<li>.self:当元素自身触发事件时才执行函数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app=<span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">        <span class="attr">methods</span>:&#123;</span><br><span class="line">            <span class="title function_">handleFather</span>(<span class="params"></span>)&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;触发父事件&#x27;</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="title function_">handleChild</span>(<span class="params"></span>)&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;触发子事件&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> @<span class="attr">click</span>=<span class="string">&quot;handleFather&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> @<span class="attr">click.prevent</span>&gt;</span>.prevent阻止默认行为，点击链接不会跳转<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> @<span class="attr">click.stop</span>=<span class="string">&quot;handleChild&quot;</span>&gt;</span>.stop阻止事件冒泡<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> @<span class="attr">click</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> @<span class="attr">click.capture</span>=<span class="string">&quot;handleFather&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> @<span class="attr">click</span>=<span class="string">&quot;handleChild&quot;</span>&gt;</span>capture会让事件的触发变为捕获触发，即会先捕获父元素，再触发子元素<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> @<span class="attr">click.self</span>=<span class="string">&quot;handleFather&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> @<span class="attr">click</span>=<span class="string">&quot;handleChild&quot;</span>&gt;</span>self使只有当元素自身触发事件时才会执行函数<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="处理键盘和鼠标事件"><a href="#处理键盘和鼠标事件" class="headerlink" title="处理键盘和鼠标事件"></a>处理键盘和鼠标事件</h4><p>使用.+按键名来绑定特定键位</p>
<p>使用.exact使只有特定按键被按下且其他按键没有被按下时才触发事件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app=<span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">list</span>:[<span class="string">&quot;好&quot;</span>,<span class="string">&quot;非常好&quot;</span>,<span class="string">&quot;很好&quot;</span>],</span><br><span class="line">            <span class="attr">content</span>:<span class="string">&quot;&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>:&#123;</span><br><span class="line">        <span class="title function_">submitlist</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">list</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">content</span>);</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">content</span>=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;comment in list&quot;</span>&gt;</span>&#123;&#123;comment&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;content&quot;</span> @<span class="attr">keyup.ctrl.enter.exact</span>=<span class="string">&quot;submitlist&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>查询按键的网址：</p>
<h4 id="与表单相关的修饰符"><a href="#与表单相关的修饰符" class="headerlink" title="与表单相关的修饰符"></a>与表单相关的修饰符</h4><ul>
<li>.lazy：当用户输入完，取消聚焦之后才触发双向绑定</li>
<li>.number：把用户输入的字段转换成num类型</li>
<li>.trim：去除用户输入的前后空格</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app=<span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">        <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">username</span>:<span class="string">&quot;&quot;</span>,</span><br><span class="line">                <span class="attr">year</span>:<span class="number">2000</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model.lazy.trim</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model.number</span>=<span class="string">&quot;year&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    &#123;&#123;username&#125;&#125;</span><br><span class="line">    &#123;&#123;year&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="通过vue实例访问和修改应用配置"><a href="#通过vue实例访问和修改应用配置" class="headerlink" title="通过vue实例访问和修改应用配置"></a>通过vue实例访问和修改应用配置</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vm=app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>然后可以访问vm的属性值或者做修改，是得可以使用外部js修改vue内部的值</p>
<h4 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h4><p>生命周期钩子是一个函数，会在合适的时期自动调用</p>
<ul>
<li><p><img src="/image/img_2.png" alt="image-20220709171124439"></p>
</li>
<li><p><img src="/image/img_3.png" alt="image-20220709171145368"></p>
</li>
<li><p><img src="/image/img_4.png" alt="image-20220709171208373"></p>
</li>
<li><p><img src="/image/img_5.png" alt="image-20220709171232027"></p>
</li>
<li><p><img src="/image/img_6.png" alt="image-20220709171335571"></p>
</li>
<li><p><img src="/image/img_7.png" alt="image-20220709171349173"></p>
</li>
<li><p><img src="/image/img_8.png" alt="image-20220709171400830"></p>
</li>
<li><p><img src="/image/img_9.png" alt="image-20220709171417499"></p>
</li>
</ul>
<p>常用的为created和mounted钩子</p>
<p><img src="/image/img_10.png" alt="image-20220709171500826"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app=<span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">        <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">posts</span>: [],</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">methods</span>:&#123;</span><br><span class="line">            <span class="keyword">async</span> <span class="title function_">getPosts</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> res=<span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&quot;./posts.json&quot;</span>);</span><br><span class="line">                <span class="keyword">const</span> data=<span class="keyword">await</span> res.<span class="title function_">json</span>();</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">posts</span>=data;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">getPosts</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">const</span> vm=app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;post in posts&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;post.id&quot;</span>&gt;</span>&#123;&#123;post.content&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>自学Vue第三章笔记</title>
    <url>/2022/08/07/VUE-chapter5/</url>
    <content><![CDATA[<h4 id="如何创建VUE组件"><a href="#如何创建VUE组件" class="headerlink" title="如何创建VUE组件"></a>如何创建VUE组件</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app=<span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;&#125;);</span><br><span class="line">    app.<span class="title function_">component</span>(<span class="string">&quot;word-counter&quot;</span>,&#123;</span><br><span class="line">        <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;input v-model=&quot;word&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;p&gt;一共有&#123;&#123;dataCounter&#125;&#125;个字符&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">        `</span>,</span><br><span class="line">        <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">word</span>:<span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">computed</span>: &#123;</span><br><span class="line">            <span class="title function_">dataCounter</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">word</span>.<span class="property">length</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">const</span> vm=app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">word-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">word-counter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>html代码配置在template配置项中</p>
<p>这种注册方式为全局注册</p>
<h4 id="脚手架"><a href="#脚手架" class="headerlink" title="脚手架"></a>脚手架</h4><p>脚手架是一组封装好的工具箱，用于快速生成一个项目，预置了常用的插件和依赖，能快速上手开发</p>
<p>大部分脚手架基于node开发</p>
<h4 id="使用vite创建vue项目"><a href="#使用vite创建vue项目" class="headerlink" title="使用vite创建vue项目"></a>使用vite创建vue项目</h4><p><code>yarn create vite</code>创建vite</p>
<p>随后设置项目名称，选择vue项目，选择vue</p>
<p>创建好项目后，在项目根目录下运行<code>npm install</code>安装依赖</p>
<p>安装好依赖后，运行<code>npm run dev</code>运行项目</p>
<h4 id="创建和使用单一文件组件"><a href="#创建和使用单一文件组件" class="headerlink" title="创建和使用单一文件组件"></a>创建和使用单一文件组件</h4><p>创建vue项目之后，修改components中vue文件的名字（默认为HelloWorld.vue）</p>
<p>如：<img src="/image/img_13.png" alt="image-20220807163007414"></p>
<p>这里面的wordCounter.vue就是我们的组件了</p>
<p>随后编辑wordCounter.vue：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;content&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>一共输入了&#123;&#123;count&#125;&#125;个字符<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">content</span>: <span class="string">&quot;&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">computed</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">count</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">content</span>.<span class="property">length</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="language-css"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"> <span class="selector-tag">input</span> &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">   <span class="attribute">border</span>: <span class="number">#535bf2</span> <span class="number">1px</span> solid;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"> &#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>组件由三部分构成</p>
<p><code>template</code>标签编写组件的html模板</p>
<p><code>script</code>标签编写脚本代码</p>
<p><code>style</code>标签编写css样式</p>
<p>编写后需要修改App.vue文件，App.vue文件是整个项目的入口组件，index.html中直接引入的是App.vue，所以我们需要在App.vue中引入wordCounter组件</p>
<p>代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> wordCounter <span class="keyword">from</span> <span class="string">&#x27;./components/wordCounter.vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">components</span>:&#123; wordCounter &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>字符串统计应用<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">word-counter</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>在<code>script</code>标签中通过<code>import</code>引入wordCounter，再在export default中添加，就可以在template中使用wordCounter组件了！</p>
<p>完成修改后，运行项目，如下图</p>
<p><img src="/image/img_14.png" alt="image-20220807163749603"></p>
<h4 id="props自定义组件内容"><a href="#props自定义组件内容" class="headerlink" title="props自定义组件内容"></a>props自定义组件内容</h4><p>给组件里添加props属性可以自定义组件中的内容</p>
<p>props的形式是一个数组，里面的元素均为字符串，如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">props</span>:[<span class="string">&#x27;username&#x27;</span>,<span class="string">&#x27;time&#x27;</span>,<span class="string">&#x27;content&#x27;</span>],</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>然后在template模板中就可以直接使用props中的内容了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;username&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;time&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;content&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>在App.vue中使用组件时可以对其传值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">message-item</span> <span class="attr">username</span>=<span class="string">&quot;demo&quot;</span> <span class="attr">time</span>=<span class="string">&quot;19:48&quot;</span> <span class="attr">content</span>=<span class="string">&quot;测试数据&quot;</span>/&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="/image/img_15.png" alt="image-20220807171234078"></p>
<h4 id="组件动态属性值绑定"><a href="#组件动态属性值绑定" class="headerlink" title="组件动态属性值绑定"></a>组件动态属性值绑定</h4><p>除了直接将要传入的值写死外，还可以通过script动态绑定</p>
<p>仍以上述为例，想要动态绑定，首先在data中声明一个数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">messageList</span>:[&#123;<span class="attr">id</span>:<span class="number">1</span>,<span class="attr">username</span>:<span class="string">&quot;demo1&quot;</span>,<span class="attr">time</span>:<span class="string">&quot;19:48&quot;</span>,<span class="attr">content</span>:<span class="string">&quot;测试数据1&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">id</span>:<span class="number">2</span>,<span class="attr">username</span>:<span class="string">&quot;demo2&quot;</span>,<span class="attr">time</span>:<span class="string">&quot;19:28&quot;</span>,<span class="attr">content</span>:<span class="string">&quot;测试数据2&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">id</span>:<span class="number">3</span>,<span class="attr">username</span>:<span class="string">&quot;demo3&quot;</span>,<span class="attr">time</span>:<span class="string">&quot;19:38&quot;</span>,<span class="attr">content</span>:<span class="string">&quot;测试数据3&quot;</span>&#125;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>然后在使用组件时通过v-for引入</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;message-item v-<span class="keyword">for</span>=<span class="string">&quot;message in messageList&quot;</span> v-bind=<span class="string">&quot;message&quot;</span> :key=<span class="string">&quot;message.id&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>

<p>这里的v-bind会自动识别message中和组件props中相同的属性并忽略掉无关属性，也可以使用下面的方法绑定</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;message-item v-<span class="keyword">for</span>=<span class="string">&quot;message in messageList&quot;</span> :username=<span class="string">&quot;message.username&quot;</span> :time=<span class="string">&quot;message.name&quot;</span> :content=<span class="string">&quot;message.content&quot;</span> :key=<span class="string">&quot;message.id&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p><img src="/image/img_16.png" alt="image-20220807173105491"></p>
<h4 id="组件属性验证和默认值"><a href="#组件属性验证和默认值" class="headerlink" title="组件属性验证和默认值"></a>组件属性验证和默认值</h4><p>在为组件传入值时，如果不使用v-bind,传入的都为字符串，使用v-bind传入的为js表达式，可以有多个类型</p>
<p>组件props的声明除了可以用数组外，还可以用对象，用来指定类型，如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="title class_">String</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="title class_">Number</span>,</span><br><span class="line">    <span class="attr">isStudent</span>: <span class="title class_">Boolean</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个属性有多个类型，可以用数组，如<code>name:[Number,String]</code></p>
<p>对于自定义类型，可以用构造函数定义，vue会通过instanceof判断如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="title class_">String</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="title class_">Number</span>,</span><br><span class="line">    <span class="attr">isStudent</span>: <span class="title class_">Boolean</span>,</span><br><span class="line">    <span class="attr">address</span>: <span class="title class_">Address</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Address</span>(<span class="params">province,city</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">province</span>=province;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">city</span>=city;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>vue还可以进行值验证，如判断属性是否为必传项，因此在定义类型时可以声明一个对象，如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>:<span class="title class_">String</span>,</span><br><span class="line">        <span class="attr">required</span>:<span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">age</span>: <span class="title class_">Number</span>,</span><br><span class="line">    <span class="attr">isStudent</span>: <span class="title class_">Boolean</span>,</span><br><span class="line">    <span class="attr">address</span>: <span class="title class_">Address</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还可以声明自定义的验证器,返回true则验证成功，返回false则验证失败</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">name</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>:<span class="title class_">String</span>,</span><br><span class="line">        <span class="title function_">validator</span>(<span class="params">value</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> value&gt;<span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<p>vue对验证失败的值并不会阻止其显示，而是会采用警告的形式提示</p>
<p>vue还可以为属性设置一个默认值，如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">name</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>:<span class="title class_">String</span>,</span><br><span class="line">        <span class="attr">default</span>: <span class="string">&#x27;text&#x27;</span>,</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<p>当未传入值时，将默认传入default中的内容</p>
<p>如果类型是对象或者数组，那么default要为一个函数，返回对象或数组</p>
<p>如果类型是函数，default也要为函数，但default本身作为用来判断的函数</p>
<h4 id="传递未定义属性"><a href="#传递未定义属性" class="headerlink" title="传递未定义属性"></a>传递未定义属性</h4><p>一般来说传递未定义属性传递的是class或者style，这时候会默认传给template最外层元素，传递未定义属性也可以做到穿透传递，即App中引入组件A，组件A引入组件B，B中声明了一个属性，这时候从App中向组件A传递这个属性和对应值，会直接在组件B中应用</p>
<h4 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h4><p>如果需要向组件传递HTML代码，使用props是不行的，这个时候可以使用slot标签。</p>
<p>在组件的template标签中加入solt：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123;title&#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span>默认内容<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>在App.vue中使用组件时在组件标签里添加slot的内容</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">hello-world</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是slot中的内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>如果没有则显示slot中默认内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">hello-world</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果没有内容，则会显示slot标签中默认的内容</p>
<p>效果如图：</p>
<p><img src="/image/img_17.png" alt="image-20220808092722798"></p>
<h4 id="使用多个插槽占位"><a href="#使用多个插槽占位" class="headerlink" title="使用多个插槽占位"></a>使用多个插槽占位</h4><p>当在组件中使用多个slot时，需要给slot指定一个名字来加以区分</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;slot name=&quot;title&quot;&gt;默认标题&lt;/slot&gt;</span><br><span class="line">    &lt;slot name=&quot;content&quot;&gt;默认内容&lt;/slot&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>在App.vue中通过<code>v-slot</code>引入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;hello-world&gt;</span><br><span class="line">    &lt;template v-slot:title&gt;</span><br><span class="line">      &lt;h2&gt;这是标题&lt;/h2&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">    &lt;template v-slot:content&gt;</span><br><span class="line">      &lt;p&gt;这是内容&lt;/p&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">  &lt;/hello-world&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>效果如图：</p>
<p><img src="/image/img_18.png" alt="image-20220808093716726"></p>
<p>如果没有为slot指定名字，默认名字为default</p>
<h4 id="通过子组件事件向父组件传递数据"><a href="#通过子组件事件向父组件传递数据" class="headerlink" title="通过子组件事件向父组件传递数据"></a>通过子组件事件向父组件传递数据</h4><p>​	一般来说我们只能从父组件向子组件传递数据，那么如何让子组件向父组件传递数据呢？可以使用vue提供的emit属性，通过子组件事件向父组件传递数据</p>
<p>首先在子组件中定义emit</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">    props:[&#x27;id&#x27;,&quot;content&quot;],</span><br><span class="line">    emits:[&#x27;deleteContent&#x27;],</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里的emit和props一样为一个数组，接收自定义事件名作为参数</p>
<p>然后我们需要在子组件中触发事件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123;content&#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;button @click=&quot;$emit(&#x27;deleteContent&#x27;,id)&quot;&gt;删除&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>通过绑定click事件触发emit函数，emit函数接收一个或多个参数，第一个参数就是在emit数组中的事件名，后面的可选参数是要传递的值</p>
<p>然后就可以在App.vue中进行监听了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;hello-world v-for=&quot;post in list&quot; v-bind=&quot;post&quot; @deleteContent=&quot;deleteContent&quot;&gt;&lt;/hello-world&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>监听在emit中定义的事件并触发事件函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">    deleteContent(id)&#123;</span><br><span class="line">      this.list=this.list.filter((post)=&gt;&#123;</span><br><span class="line">        return post.id!==id;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>事件处理函数可以接收到子组件中监听的id</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>自学VUE第四章笔记</title>
    <url>/2022/08/08/VUE-chapter6/</url>
    <content><![CDATA[<h4 id="props响应式传递"><a href="#props响应式传递" class="headerlink" title="props响应式传递"></a>props响应式传递</h4><p>根据vue中的数据流通，子组件是不能修改父组件传进的props值的，因此，如果想从子组件修改传入的值，需要用到子组件的data，将props的值赋给data，修改data的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div v-for=&quot;n in pages&quot; @click=&quot;changePage(n)&quot;&gt;&#123;&#123;n&#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;p&gt;当前页：&#123;&#123;currentPage&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        currentPage:this.currentPageDefault,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    props:[&#x27;pages&#x27;,&#x27;currentPageDefault&#x27;],</span><br><span class="line">    methods:&#123;</span><br><span class="line">      changePage(n) &#123;</span><br><span class="line">        this.currentPage=n;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    watch:&#123;</span><br><span class="line">      pages(newVal,oldVal) &#123;</span><br><span class="line">        console.log(newVal)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>父组件传入<code>currentPageDefault</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;HelloWorld :pages=&quot;num&quot; :current-page-default=&quot;5&quot;&gt;&lt;/HelloWorld&gt;</span><br><span class="line">  &lt;button @click=&quot;num++&quot;&gt;增加页数&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>可以使用watch监听属性的变化，用法和watch监听data的变化一致</p>
<h4 id="组件数据的流向设计"><a href="#组件数据的流向设计" class="headerlink" title="组件数据的流向设计"></a>组件数据的流向设计</h4><p>vue中的组件数据流向设计是：父组件通过props向子组件传递数据，子组件通过emit事件向父组件传递数据</p>
<p>如，现在有两个组件<code>emitMode</code>和<code>propsMode</code></p>
<p><code>emitMode</code>通过emit向父组件传递事件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button @click=&quot;$emit(&#x27;handleEvents&#x27;,&#x27;点击了按钮&#x27;)&quot;&gt;点击按钮&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"> export default &#123;</span><br><span class="line">   emits:[&#x27;handleEvents&#x27;]</span><br><span class="line"> &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><code>propsMode</code>通过父组件传递的props触发事件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button @click=&quot;click(&#x27;点击了按钮&#x27;)&quot;&gt;点击按钮&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    props:[&#x27;click&#x27;],</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>在父组件中引入子组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">import emitMode from &#x27;./components/emitMode.vue&#x27;</span><br><span class="line">import propsMode from &quot;./components/propsMode.vue&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  components:&#123;emitMode,propsMode&#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    printMessage(mes) &#123;</span><br><span class="line">      console.log(mes)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;emit-mode @handleEvents=&quot;printMessage&quot;&gt;&lt;/emit-mode&gt;</span><br><span class="line">  &lt;props-mode :click=&quot;printMessage&quot;&gt;&lt;/props-mode&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>两种方法都能达到一样的效果，但区别是，当父组件没有向子组件传递props时，<code>propsMode</code>会提示异常但<code>emitMode</code>不会依赖父组件，因此当子组件需要用到父组件传入的事件处理函数时，使用emit向上传递事件，不要让父组件向下传递props</p>
<h4 id="组件生命周期"><a href="#组件生命周期" class="headerlink" title="组件生命周期"></a>组件生命周期</h4><p>组件的生命周期和之前的生命周期钩子是一样的，不过多介绍</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>组件</tag>
      </tags>
  </entry>
  <entry>
    <title>Welcome to my BLOG!</title>
    <url>/2022/08/03/hello-world/</url>
    <content><![CDATA[<p>欢迎来到我的博客<br>我会在这里记录自己的学习，生活<br>谢谢你的到来！！</p>
]]></content>
      <categories>
        <category>欢迎</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title>关于内向和外向</title>
    <url>/2022/08/08/%E5%86%85%E5%90%91%E4%B8%8E%E5%A4%96%E5%90%91/</url>
    <content><![CDATA[<h3 id="内向与外向"><a href="#内向与外向" class="headerlink" title="内向与外向"></a>内向与外向</h3><p>​	内向的人可能表现出来是外向的，因为这里的内向是人内心深处的东西，更贴近于本质，而表现出来的外向是社会学上的宏观表现。一个内向的人甚至可能觉得自己非常非常外向，因为他们自己在社交上不怎么怯场，与很多人都能有话可说，但他们内心里是内向的，因为外在的表现可以认为是一种技能的习得，虽然能表现的外向，但背后可能是抗拒，疲惫的。一个外向的人用内向者的放松方式要求自己（如把自己关在房间里读书），或是一个内向的人用外向者的放松方式要求自己（如出门旅游），都会使自己的生活更加疲惫</p>
<p>​	区分内向者与外向者，要看他们与世界的联系。内向的人能接受世界的能力更弱，面对不断变化的世界，他们往往需要与世界保持一定的距离。而外向者正好相反，外向者擅长与世界融为一体，能积极接纳新事物。内向的人会在内心中建立一个世界，从而做到与真实的世界保持一定距离。理论上讲内心世界应该与真实世界是1：1的但事实并非如此，因此内向的人会在观察自己内心世界的基础上尽可能少的从外部世界获取新东西扩充自己。所以内向的人在心里为了获得安全感会更想去认识认识这个世界，而事实上他却尽可能少的认识，因此内向的人更需要安全感。外向的人则需要不断地从世界获取新事物，因为他总觉得自己还不够，他会认为世界与自己是一体的。</p>
<p>​	在此基础上，通过审查自己看待世界的方式，就可以知道自己是内向还是外向。比如内向者被亲密的人伤害之后，会因为这件事影响自己内心的世界，很可能会认为这个世界对自己太残忍了，既然亲密者对我都这样那么世界也不会对我温柔了等等想法。而外向者不同，外向者往往表现出我讨厌这个世界，我厌恶这个人。这两者有什么区别呢，区别在于内向者把自己与世界做了一个割舍，认为世界是危险的，完全融入进去就会被吞噬。而外向者则在最开始就是和世界站在一起的，他思考的前提就是自己处在世界之中。</p>
<p>​	内向者放松的方式，是要更加切断自己与世界探索性的联系，要做的是修补自己的内心世界。因此，他们更需要独处。</p>
]]></content>
      <categories>
        <category>生活</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>心理</tag>
      </tags>
  </entry>
  <entry>
    <title>我的ppt制作经验</title>
    <url>/2022/08/04/ppt%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[<h2 id="我的PPT设计思路"><a href="#我的PPT设计思路" class="headerlink" title="我的PPT设计思路"></a>我的PPT设计思路</h2><h3 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h3><ol>
<li><p>尽量别用WPS！！！！WPS的使用体验较差，与PowerPoint相比卡顿明显，广告多，许多重要功能都被阉割或收费，现在购买的Windows系统笔记本电脑大多数都带有PowerPoint的较高版本，使用起来轻便自然，即使没有，也可以拼车购买365版本，因此建议不要使用WPS！优秀的ppt模板可以自己设计</p>
</li>
<li><p>可能需要的网站：</p>
<ul>
<li><a href="https://www.iconfont.cn/">iconfont-阿里巴巴矢量图标库</a>阿里巴巴矢量图标库里面提供了大量的免费图标，比PowerPoint提供的图标更多更广，可以选择颜色下载方便使用，当然若PowerPoint中的图标能满足需求也可以使用自带图标</li>
<li><a href="https://huaban.com/">花瓣网</a>花瓣网中有不少ppt精致模板，平面设计素材，当你不知道如何构思ppt排版，主题配色时可以参考然后实现</li>
<li>一个能够持续得到学习的（视频）网站。<a href="https://www.bilibili.com/">哔哩哔哩 (゜-゜)つロ 干杯~-bilibili</a>b站上有足够多的ppt制作up主，无论是通过主动学习还是被动被推送都可以获取到制作ppt的技巧视频，足够在同辈面前炫技了。视频资源能够以直观的形式看到制作的效果，你能够选择自己看中的特效进行学习</li>
<li>一个清晰的图片网，必应图片的筛选功能还可以使用，也可以去一些壁纸网站找背景图，如<a href="https://wallhaven.cc/">Awesome Wallpapers - wallhaven.cc</a></li>
<li>推荐几个B站up<ul>
<li><a href="https://space.bilibili.com/395619513/?spm_id_from=333.999.0.0">旁门左道PPT的个人空间_哔哩哔哩_bilibili</a>视频内容偏向实用化，模板化</li>
<li><a href="https://space.bilibili.com/76949949/?spm_id_from=333.999.0.0">黑白间设计的个人空间_哔哩哔哩_bilibili</a>视频内容有很多好看的特效</li>
<li><a href="https://space.bilibili.com/282229936/?spm_id_from=333.999.0.0">早晨PPT的个人空间_哔哩哔哩_bilibili</a>视频内容与黑白间设计较为相似</li>
<li>还有很多up，根据自己观看判断视频质量做出选择</li>
</ul>
</li>
</ul>
</li>
<li><p>入门PPT</p>
<p>你需要学习PPT的基础操作，直接去b站搜索ppt教程即可，有很多入门视频，学习一下基本操作</p>
</li>
<li><p>一些设计思路</p>
<p>了解一些设计风格，如拟物（skeuomorphism），扁平（flat design），物料（material design），新拟态（neumorphism），玻璃态（glassmorphism），泥陶态（claymorphism）</p>
</li>
</ol>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><ol>
<li>学习了ppt的基础操作之后，当你需要制作一个ppt时，区分一下使用场景</li>
</ol>
<ul>
<li><p>介绍，宣传类</p>
<p>介绍类往往可以把ppt制作的比较华丽，特效什么的可以尽量往里面加，但不能显得过于紊乱，最好挑选一个主题配色，在一个主体配色下对细节进行刻画</p>
</li>
<li><p>正式场景（如答辩）</p>
<p>学校答辩往往比较注重内容，在特效制作方面可以放弃一些，重点在于内容的排版，有时候白底黑字，配上合适图片即可，在静态视觉上做足功夫，动态视觉不能占主动。一般学校答辩选择一个模板就行</p>
</li>
<li><p>教师用</p>
<p>教师用ppt比较随意，毕竟大家从小到大看的教师ppt都是白板黑字，大量文字堆积，和word无异，没有美感，但能达到教学目的，便于学生课后学习，能服务于目的就是好ppt</p>
</li>
<li><p>一般来说，注意一些通用技巧就可以做出让人眼前一亮的ppt了！</p>
</li>
</ul>
<ol start="2">
<li>在制作ppt之前，还要特别注意一下演示时使用的版本，如PowerPoint2019加入了平滑切换功能，但如果在演示时要求的设备上使用的是2016版本，就无法运用了。因此使用自己的电脑投屏演示是最好的！</li>
</ol>
<h4 id="通用思路"><a href="#通用思路" class="headerlink" title="通用思路"></a>通用思路</h4><p>无论你需要做什么ppt，下面的思路基本上是通用的</p>
<ul>
<li><p>空白模板：如果你决定不使用模板，就新建一个空白模板</p>
<p><img src="/image/img_11.png" alt="image-20220804204614805"></p>
</li>
<li><p>文字占比不能过大：ppt的主要观感应该是图片，特效等迎合视觉的元素，过多的文字起不到效果</p>
</li>
<li><p>文字的位置：文字不能太靠边，文字太靠边会让人产生ppt页面过于拥挤等不良感受，下图的文字位置就很好(蓝框内写文字)</p>
<p><img src="/image/img_12.png" alt="image-20220804205116600"></p>
</li>
<li><p>动效时间不要太长！动效（页面动画，切换动画等）的时间一般不能太长（除非你是纯ppt动画），过长的时间不仅会导致观看者等待，感到视觉疲劳，也会使演示者在演示过程中陷入等待，尴尬。</p>
</li>
<li><p>选择的动画要贴合实际使用场景，比如两个页面之间的关系是递进的，则不能使用”破坏“相关的切换特效</p>
</li>
<li><p>平滑切换很强大很方便很有用！因此我极力推荐使用2019以上的ppt版本</p>
</li>
<li><p>ppt中也可以参考一些网页特效进行复刻，网页中使用的css特效在ppt中部分也有直接的使用按钮，如鼠标悬停，鼠标点击，结合平滑可以做到类似网页特效</p>
</li>
<li><p>图片选择也要合适，不能单纯凭借个人喜好而选择不符合主题的图片，如背景图要简单，颜色不能过多，如果必须要使用得加遮罩</p>
</li>
</ul>
<h3 id="具体思路"><a href="#具体思路" class="headerlink" title="具体思路"></a>具体思路</h3><ul>
<li><p>有关文字内容：面对大量的描述文字，需要先提取主干，如关键词。然后将关键词作为标题或小标题，小标题下面就是一句话长度的描述内容，不能太多，观众能明白大意即可。几个小标题之间通过图形进行联系（如箭头表示推进），每个标题可以配一个相关的图片暗示内容。文字占比不多但必不可少，如</p>
<p><img src="/image/img_12.png" alt="image-20220804205116600"></p>
<p>左边是图片提示主要内容，右边加粗黑字是标题，下面的是主要内容，讲述者根据主要内容的提示就可以进行讲解，观看者也能知道具体在讲什么，整个ppt观感体验也不错</p>
</li>
<li><p>利用平滑切换进行过渡</p>
<p>想要做出好看的过渡效果，平滑切换是必不可少的。学习过前端相关知识的同学可以很容易理解，平滑切换的原理就和css中的<code>transition</code>类似，只不过是在页面之间运用。想要制作令人眼前一亮的平滑切换效果，必要时还得修改元素名。平滑切换做出来的效果千奇百怪，视差动画这样很强的操作更是离不开平滑切换。下面展示几个平滑切换的应用实例</p>
<p><a href="https://www.bilibili.com/video/BV1mA41137Bo?spm_id_from=333.999.0.0&vd_source=ea0b821b0c66dd7f6257ac303626c797">这一波操作瞬间让PPT逼格提升数倍！【推荐必看】_哔哩哔哩_bilibili</a></p>
<p><a href="https://www.bilibili.com/video/BV1WV411x7v9?spm_id_from=333.999.0.0&vd_source=ea0b821b0c66dd7f6257ac303626c797">PPT过渡，竟能如此创意！_哔哩哔哩_bilibili</a></p>
<p><a href="https://www.bilibili.com/video/BV1cr4y1173r?spm_id_from=333.999.0.0&vd_source=ea0b821b0c66dd7f6257ac303626c797">不敢相信！外网这个PPT视差动画，让图片变3D版了【旁门左道】_哔哩哔哩_bilibili</a></p>
<p><a href="https://www.bilibili.com/video/BV1ub4y1U7EP?spm_id_from=333.999.0.0">余承东排面儿！华为发布会上用的平滑切换PPT，逼格…【旁门左道】_哔哩哔哩_bilibili</a></p>
<p>利用平滑切换也可以代替一些动画，但注意平滑时间不能太长，切换仅仅是一个让人眼前一亮的功能，占比不能大</p>
</li>
<li><p>如果你觉得自己的ppt背景过于单调，也可以选择使用视频作为背景</p>
</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>ppt</tag>
      </tags>
  </entry>
  <entry>
    <title>css中list列表相关</title>
    <url>/2022/08/03/%E5%88%97%E8%A1%A8%E5%92%8C%E7%94%9F%E6%88%90%E7%9A%84%E5%86%85%E5%AE%B9/</url>
    <content><![CDATA[<h1 id="列表和生成的内容"><a href="#列表和生成的内容" class="headerlink" title="列表和生成的内容"></a>列表和生成的内容</h1><h3 id="改变记号类型"><a href="#改变记号类型" class="headerlink" title="改变记号类型"></a>改变记号类型</h3><p>使用<code>list-style-type</code>属性</p>
<p>与列表相关的属性只能应用到display属性为list-item的元素上，css并不区分有序列表和无序列表的项目。可以让有序列表使用圆点</p>
<p>如果不想要记号，可以设置none值，但none值只是让记号不显示，并没有阻断计数</p>
<p><code>list-style-type</code>的值是继承的，因此如果嵌套的列表需要使用不同的记号需要分别定义</p>
<p>除了默认提供的<code>list-style-type</code>值外，还可以使用字符串值作为记号</p>
<p>使用<code>list-style-image</code>属性</p>
<p>使用该属性可以将列表记号设置为图片</p>
<p>可以在声明图片记号之后再声明一个<code>list-style-type</code>作为后备记号类型</p>
<p>嵌套的列表同样会继承image属性</p>
<p>为嵌套的列表的image设置none阻止继承</p>
<p>但实际情况中用户代理可能会为列表设置一个list-style-type值，因此继承的list-style-type值可能不能生效</p>
<p>使用<code>list-style-position</code></p>
<p>该属性会改变列表记号的位置，设置为outside（默认值）时，记号显示在外部，设置为inside时，显示在内容内部</p>
<p>使用<code>list-style</code>简写属性</p>
<p><code>list-style:list-style-type list-style-image list-style-position</code></p>
<p>可以按任意顺序列出</p>
<p>列表项目本身是类似块级的元素，放在列表内容外部的记号对其他元素的布局没有影响，记号相对于列表内容类似于绝对定位</p>
<h3 id="生成的内容"><a href="#生成的内容" class="headerlink" title="生成的内容"></a>生成的内容</h3><p>生成的内容使用::before和::after伪元素插入文档。通过设置伪元素的content属性将指定的内容插入文档内容之前或之后</p>
<p>如果::before或::after选择符的目标是块级元素，那么display的值只能为none，inline，block，和marker，其他值都为block</p>
<p>如果是行内元素，那么display的值只能为none或inline，其他值都为inline</p>
<h5 id="content"><a href="#content" class="headerlink" title="content"></a>content</h5><p>content的值为字符串时，显示为字面当量，即使有特殊标签也直接显示出来</p>
<p>如果需要换行需要添加\A,如果需要将较长的字符串分多行书写需要\</p>
<p>content值为URI时，会将引入的资源插入合适的位置，如果是用户代理不支持的资源会完全忽略</p>
<p>如果想把属性值显示出来，可以使用<code>attr()</code>,如<code>content:attr(href)</code></p>
<p>如果属性不存在，将显示空字符串</p>
<h5 id="生成引号"><a href="#生成引号" class="headerlink" title="生成引号"></a>生成引号</h5><p>引号使用quote或open-quote等值生成</p>
<p><code>quote:&lt;string&gt; &lt;string&gt;</code></p>
<p>第一个字符定义开始引号，第二个字符定义结束引号</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>不常用</tag>
      </tags>
  </entry>
  <entry>
    <title>js数据结构：前置知识</title>
    <url>/2022/08/29/%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h2 id="学习数据结构与算法JS版本的前置知识（JS基础）"><a href="#学习数据结构与算法JS版本的前置知识（JS基础）" class="headerlink" title="学习数据结构与算法JS版本的前置知识（JS基础）"></a>学习数据结构与算法JS版本的前置知识（JS基础）</h2><h3 id="数组解析"><a href="#数组解析" class="headerlink" title="数组解析"></a>数组解析</h3><p><code>let [x,y]=[&quot;a&quot;,&quot;b&quot;]</code>,直接对x，y两个变量声明</p>
<p><code>[x,y]=[y,x]</code>直接对x，y交换</p>
<h3 id="属性简写"><a href="#属性简写" class="headerlink" title="属性简写"></a>属性简写</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, y] = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]; </span><br><span class="line"><span class="keyword">let</span> obj = &#123; x, y &#125;; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj); <span class="comment">// &#123; x: &quot;a&quot;, y: &quot;b&quot; &#125; </span></span><br></pre></td></tr></table></figure>

<p>可以直接声明对象属性</p>
<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><h4 id="声明类"><a href="#声明类" class="headerlink" title="声明类"></a>声明类</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">title,pages,isbn</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">title</span>=title;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">pages</span>=pages;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">isbn</span>=isbn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">printIsbn</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">isbn</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ITBook</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Book</span> &#123; <span class="comment">// &#123;1&#125; </span></span><br><span class="line"> <span class="title function_">constructor</span> (title, pages, isbn, technology) &#123; </span><br><span class="line"> <span class="variable language_">super</span>(title, pages, isbn); <span class="comment">// &#123;2&#125; </span></span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">technology</span> = technology; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="title function_">printTechnology</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">technology</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>extends</code>继承一个父类</li>
<li>使用<code>super</code>引入父类构造器</li>
</ul>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><ul>
<li><p>导出模块：<code>export &#123; circleArea, squareArea &#125;;</code></p>
</li>
<li><p>导入模块：<code>import &#123; circleArea, squareArea &#125; from &#39;./17-CalcArea&#39;;</code></p>
</li>
<li><p>导出模块时命名：<code>export &#123; circleArea as circle, squareArea as square &#125;;</code></p>
</li>
<li><p>导入模块时命名：<code>import &#123; circleArea as circle &#125; from &#39;./17-CalcArea&#39;; </code></p>
</li>
</ul>
<h3 id="数组常用方法"><a href="#数组常用方法" class="headerlink" title="数组常用方法"></a>数组常用方法</h3><p><code>push</code>:在数组末尾添加元素</p>
<p><code>unshift</code>:在数组开头添加元素</p>
<p><code>pop</code>:在数组末尾删除元素</p>
<p><code>shift</code>:在数组开头删除元素</p>
<p><code>splice</code>:在数组给定位置删除元素。如<code>splice(5,3)</code>在数组从索引5开始删除3个元素，即Array[5],Array[6],Array[7]。<code>splice(5,3,2,4)</code>是在删除三个元素后从索引5开始添加2和4两个数</p>
<p><code>concat</code>:连接 2 个或更多数组，并返回结果</p>
<p><code>every</code>:会迭代每一个元素直到返回false，传入一个函数</p>
<p><code>some</code>:与<code>every</code>相反，返回true结束</p>
<p><code>foeEach</code>:迭代整个数组，和for循环作用相同</p>
<p><code>map</code>:迭代整个数组，将每个数组元素带入函数得到的返回值构成一个新数组返回</p>
<p><code>filter</code>:和<code>map</code>类似，但返回的新数组由使函数返回 true 的元素组成</p>
<p><code>reduce</code>:返回一个将被叠加到累加器的值，reduce 方法停止执行后会返回 这个累加器.reduce 方法接收一个有如下四个参数的函数：previousValue、 currentValue、index 和 array。因为 index 和 array 是可选的参数，所以如果用不到它们 的话，可以不传。如：<code>numbers.reduce((previous, current) =&gt; previous + current);</code>是对数组求和</p>
<h3 id="ES6数组新语法"><a href="#ES6数组新语法" class="headerlink" title="ES6数组新语法"></a>ES6数组新语法</h3><ul>
<li><p><code>for...of</code>：更简化的循环迭代</p>
</li>
<li><p><code>@@iterator</code>:这是一个对象，通过<code>Symbol.iterator</code>访问。</p>
<p>如：<code>let iterator = numbers[Symbol.iterator]();</code></p>
<p>然后，不断调用迭代器的 next 方法，就能依次得到数组中的值</p>
<p>如：<code>console.log(iterator.next().value); // 1 </code></p>
<p>数组中的所有值都迭代完之后，<code>iterator.next().value</code> 会返回 undefined。</p>
</li>
<li><p><code>entries</code>:方法返回包含键值对的<code>@@iterator</code>,如<code>let aEntries = numbers.entries();</code></p>
<p><code>console.log(aEntries.next().value); // [0, 1] - 位置 0 的值为 1</code></p>
</li>
<li><p><code>keys</code>:返回包含数组索引的<code>@@iterator</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> aKeys = numbers.<span class="title function_">keys</span>(); <span class="comment">// 得到数组索引的迭代器</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(aKeys.<span class="title function_">next</span>()); <span class="comment">// &#123;value: 0, done: false &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(aKeys.<span class="title function_">next</span>()); <span class="comment">// &#123;value: 1, done: false &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(aKeys.<span class="title function_">next</span>()); <span class="comment">// &#123;value: 2, done: false &#125;</span></span><br></pre></td></tr></table></figure>

<p><code>done</code>的值为false意味着还有可迭代的值</p>
</li>
<li><p><code>values</code>:法返回的<code>@@iterator</code> 则包含数组的值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> aValues = numbers.<span class="title function_">values</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(aValues.<span class="title function_">next</span>()); <span class="comment">// &#123;value: 1, done: false &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(aValues.<span class="title function_">next</span>()); <span class="comment">// &#123;value: 2, done: false &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(aValues.<span class="title function_">next</span>()); <span class="comment">// &#123;value: 3, done: false &#125; </span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>from</code>:据已有的数组创建一个新数组</p>
<p><code>let numbers2 = Array.from(numbers);</code>复制了numbers数组</p>
<p>还可以传入一个用来过滤值的函数</p>
<p><code>let evens = Array.from(numbers, x =&gt; (x % 2 == 0));</code></p>
<p>上面的代码会创建一个 evens 数组，以及值 true（如果在原数组中为偶数）或 false（如 果在原数组中为奇数）。</p>
</li>
<li><p><code>fill</code>:填充元素</p>
</li>
<li><p><code>find</code>:查找第一个符合条件的元素</p>
</li>
<li><p><code>findindex</code>:查找第一个符合条件的元素的索引</p>
</li>
<li><p><code>includes</code>:如果数组里存在某个元素，includes 方法会返回 true，否则返回 false。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>数据结构</tag>
        <tag>数组</tag>
        <tag>对象</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>css中transform</title>
    <url>/2022/08/03/%E5%8F%98%E5%BD%A2/</url>
    <content><![CDATA[<h1 id="变形"><a href="#变形" class="headerlink" title="变形"></a>变形</h1><h2 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h2><p>笛卡尔坐标系：即xyz坐标系，x向右，y向下，z和z-index相同</p>
<p>球坐标系：显示3D效果所用的坐标系</p>
<h2 id="变形-1"><a href="#变形-1" class="headerlink" title="变形"></a>变形</h2><p>使用<code>transform:&lt;transform-list&gt;</code></p>
<p>变形的元素在视觉上可能会缩小或放大，但在页面中所占的空间是不变的</p>
<p>变形函数一次只处理一个，从左向右。如果顺序变了结果可能大变</p>
<p>有多个变形函数时，一旦有一个设置不正确导致失效，整个transform都会失效</p>
<p>变形通常不叠加</p>
<h3 id="平移函数"><a href="#平移函数" class="headerlink" title="平移函数"></a>平移函数</h3><p>平移函数是指沿一个轴或多个轴移动</p>
<p><code>translateX()和translateY()</code>通常称为2D平移函数</p>
<p>如果先进行旋转变形，那么xy轴也会对应旋转变换从而影响平移效果</p>
<p>如果值是百分数，那么移动距离相对于元素自身的尺寸计算</p>
<p>只移动XY轴方向时，可以使用<code>translate()</code>简写，第一个值是x轴移动量，第二个是y轴移动量，如果只有一个值，空缺的值视为0</p>
<p>使用<code>translateZ</code>沿z轴平移</p>
<p><code>translateZ()</code>只接受长度值</p>
<p><code>translate3d()</code>可以同时设置XYZ轴方向的平移量，如果赋值小于3个，视作无效</p>
<h3 id="缩放函数"><a href="#缩放函数" class="headerlink" title="缩放函数"></a>缩放函数</h3><p>缩放函数把元素放大或缩小，值始终为没有单位的正数</p>
<p><code>scaleX() scaleY() scaleZ()</code></p>
<p>赋值当作乘数，但缩放值不能为百分数</p>
<p>如果想在两个轴上同时缩放，可以使用<code>scale()</code>，第一个值是x，第二个值是y，如果只提供一个值，视作两个值相等</p>
<p><code>scaleZ()</code>仅在z轴上缩放，需要元素具有一定的深度，如沿x，y轴旋转</p>
<p><code>scale3d()</code>可以在三个轴方向缩放，不足三个值同样视为无效</p>
<h3 id="旋转函数"><a href="#旋转函数" class="headerlink" title="旋转函数"></a>旋转函数</h3><p><code>rotate() rotateX() rotateY() rotateZ()</code></p>
<p>只接受一种值，即角度（deg grad rad turn）,当不使用动画时，如果角度超过了常规范围，将转换为常规范围内的值</p>
<p><code>rotate</code>使用的是2d旋转，和<code>rotateZ()</code>功能相同</p>
<p><code>rotateX()</code>沿x轴旋转，<code>rotateY()</code>沿y轴旋转，使元素倾斜</p>
<p><code>rotate3d()</code>可以在3d空间内旋转元素，前三个值是xyz轴分量，第四个值是旋转角度</p>
<p>绕两个轴旋转和在绕3d空间中的向量旋转是有区别的</p>
<h3 id="倾斜函数"><a href="#倾斜函数" class="headerlink" title="倾斜函数"></a>倾斜函数</h3><p><code>skewX() skewY()</code>值为角度，z轴方向不允许倾斜</p>
<p><code>skew(a,b)</code>通过矩阵运算[ax,ay]实施2d倾斜，与分别设置的效果有所不同</p>
<h3 id="视域函数"><a href="#视域函数" class="headerlink" title="视域函数"></a>视域函数</h3><p>视域为元素赋予先后深度</p>
<p>使用<code>perspective(&lt;length&gt;)</code>设置</p>
<p>小于200px的值特别失真，2000px以上的值失真“特别温和”，500px-100px值产生“适中的视域”</p>
<p><code>perspective</code>函数在变形函数列表中的位置十分重要，一般将其放在首位</p>
<h3 id="矩阵函数"><a href="#矩阵函数" class="headerlink" title="矩阵函数"></a>矩阵函数</h3><p><code>martrix()</code>函数通过6个值确定的变换矩阵指定2d空间内的变形</p>
<p><code>martrix3d()</code>指定3d变形</p>
<p>可以使用多个变形函数达到matrix函数的最终状态</p>
<h2 id="其他变形属性"><a href="#其他变形属性" class="headerlink" title="其他变形属性"></a>其他变形属性</h2><h3 id="移动原点"><a href="#移动原点" class="headerlink" title="移动原点"></a>移动原点</h3><p>不设置移动原点，默认的移动原点是元素的绝对中心</p>
<p>可以使用<code>transform-origin</code>修改</p>
<p><code>transform-origin</code>的值为2个或三个关键字，用于指定相对于哪个点变形，第一个值指定横向，第二个值指定纵向，可选的第三个值是z轴长度。前两个值可以使用top和right，也可以使用百分数等，z轴只能使用长度</p>
<p>长度值设置的是距元素左上角的距离</p>
<p>百分数根据元素尺寸计算</p>
<h3 id="选择3D变形方式"><a href="#选择3D变形方式" class="headerlink" title="选择3D变形方式"></a>选择3D变形方式</h3><p>通过<code>transform-style:preserve-3d</code>修改3D变形方式</p>
<p>然而这样设定的3D变形方式可能被其他属性覆盖，因为那些属性必须要元素扁平才能发挥作用</p>
<p>如果修改CSS属性时发现3d元素被拍扁了，可能是</p>
<ul>
<li>overflow</li>
<li>filter</li>
<li>clip</li>
<li>clip-path</li>
<li>mask-image</li>
<li>mask-border-source</li>
<li>mix-blend-mode</li>
</ul>
<p>中的某些值发生了改变</p>
<h3 id="修改视域"><a href="#修改视域" class="headerlink" title="修改视域"></a>修改视域</h3><h4 id="定义视距"><a href="#定义视距" class="headerlink" title="定义视距"></a>定义视距</h4><p>使用perspective修改视域</p>
<p><code>perspective</code>与<code>perspective()</code>的区别：</p>
<p><code>perspective</code>运用到当前元素的所有子元素中，而<code>perspective()</code>只运用到当前元素上</p>
<p>多数时候应该使用perspective</p>
<h4 id="移动视距原点"><a href="#移动视距原点" class="headerlink" title="移动视距原点"></a>移动视距原点</h4><p>使用<code>perspective-origin</code>修改</p>
<p>初始值：50% 50%</p>
<p>和<code>transform-origin</code>用法类似</p>
<p><code>transform-origin</code>定义在哪点变形，<code>perspective-origin</code>定义视线汇聚于哪一点</p>
<h3 id="处理背面"><a href="#处理背面" class="headerlink" title="处理背面"></a>处理背面</h3><p>由<code>backface-visibility</code>属性决定</p>
<p>值：visible&#x2F;hidden</p>
<p>该属性仅仅决定当背面朝向我们时是否渲染背面</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>变形在二维和三维空间中改变元素形态，可以制作出很多引人注目的效果，利用3d变形还可以创造出交互界面，为设计开辟了新天地</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>css动画</title>
    <url>/2022/08/03/%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<h1 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h1><h2 id="定义关键帧"><a href="#定义关键帧" class="headerlink" title="定义关键帧"></a>定义关键帧</h2><p>一个<code>@keyframes</code>规则有一个动画标识符（动画名称），以及一到多个关键帧块。</p>
<p>每个关键帧块有一到多个关键帧选择符（百分数或from&#x2F;to），声明属性及其值</p>
<p>关键帧没有指明动画的持续时间，在选择符中使用时间会使动画失效</p>
<p>0必须写成0%</p>
<p>选择符无需按照升序排序，但为了方便辨识建议从0%到100%</p>
<p>如果没有定义0%和100%的状态，默认到初始状态</p>
<p>如果定义了重复的关键帧选择符，那么会进行层叠（覆盖）</p>
<h2 id="把动画应用到元素上"><a href="#把动画应用到元素上" class="headerlink" title="把动画应用到元素上"></a>把动画应用到元素上</h2><p><code>animation-name</code>属性的值为一个逗号分隔的列表，指定想应用的关键帧动画的名称</p>
<p>如果列表中有标识符不存在，则会单个失效而不会全体失效</p>
<h3 id="定义时长"><a href="#定义时长" class="headerlink" title="定义时长"></a>定义时长</h3><p><code>animation-duration</code>用于定义动画时长，单位为秒或毫秒</p>
<p>必须带单位，且可以用逗号分隔来定义不同动画</p>
<p>如果时间比动画数少，那么缺少的值将成组复制</p>
<p>如果时间比动画数多或定义不存在的动画，动画和对应的时间都会被忽略</p>
<h3 id="声明迭代次数"><a href="#声明迭代次数" class="headerlink" title="声明迭代次数"></a>声明迭代次数</h3><p><code>animation-iteration-count</code>声明迭代次数</p>
<p>初始值为1，即动画只播放一次</p>
<p>如果值不是整数，动画会在最后一次迭代的中途停止</p>
<p>不允许设置负值，无效值会变成1</p>
<p>0是有效值，但动画迭代0次，仍会触发开始和结束事件</p>
<p>多出的值忽略，缺少的值根据现有的值重复</p>
<p>无效的值会使整个声明失效，受影响的动画只会播放一次</p>
<p>值为infinite无限次迭代播放</p>
<h3 id="设置播放方向"><a href="#设置播放方向" class="headerlink" title="设置播放方向"></a>设置播放方向</h3><p><code>animation-direction</code>属性可以控制动画播放的方向（从0%到100%还是从100%到0%）</p>
<p><code>animation-direction:normal/reverse/alternate/alternate-reverse</code></p>
<p>初始值：normal:动画每次都从0%到100%播放</p>
<p><code>reverse</code>:每次迭代都从100%到0%播放</p>
<p><code>alternate</code>:奇数次迭代从0%到100%，偶数次迭代从100%到0%</p>
<p><code>alternate-reverse</code>:奇数次迭代从100%到0%，偶数次迭代从0%到100%</p>
<h3 id="延迟播放"><a href="#延迟播放" class="headerlink" title="延迟播放"></a>延迟播放</h3><p><code>animation-delay</code>属性定义元素等待多久开始第一次迭代</p>
<p>单位为秒或毫秒</p>
<p>如果设置为负值，元素将立即开始播放，但是是从动画中途开始的</p>
<h3 id="动画事件"><a href="#动画事件" class="headerlink" title="动画事件"></a>动画事件</h3><p>与动画有关的事件有三个：<code>animationstart  animationiteration  animationend</code></p>
<p>每个事件都有三个只读属性：<code>animationName elapsedTime pseudoElement</code></p>
<p><code>animation-start</code>事件在动画开始时触发，如果delay为负值，则立即触发</p>
<p><code>animation-end</code>事件在动画结束时出啊发，如果迭代次数为infinite且duration值为正数，将永远不会触发animation-end事件，如果duration为0，<code>animationstart</code>和<code>animationend</code>将同时触发，而且按此顺序</p>
<p><code>animationiteration</code>事件在两次迭代之间触发，只要一次迭代后又发生迭代（不管是否完整），该事件都会触发</p>
<h3 id="改变动画的内部时序"><a href="#改变动画的内部时序" class="headerlink" title="改变动画的内部时序"></a>改变动画的内部时序</h3><p><code>animation-timing-function</code>指明动画在一次循环（或迭代）中如何演进</p>
<p>内容与<code>transition-timing-function</code>相同</p>
<p>如果将其应用到关键帧上，只对当前关键帧块上的元素有影响，且只有播放到包含那些属性的关键帧时时序函数才会生效</p>
<h3 id="设置动画的播放状态"><a href="#设置动画的播放状态" class="headerlink" title="设置动画的播放状态"></a>设置动画的播放状态</h3><p>使用<code>animation-play-state</code>属性定义动画的播放状态</p>
<p>值为running时动画播放，值为pause时动画暂停，在delay时pause也会使delay时钟暂停</p>
<h3 id="动画的填充模式"><a href="#动画的填充模式" class="headerlink" title="动画的填充模式"></a>动画的填充模式</h3><p><code>animation-fill-mode</code>属性定义动画播放结束后是否应用原来的属性值</p>
<p><code>animation-fill-mode:none/forwards/backwards/both</code></p>
<p><code>none</code>:动画不播放就没有效果，在delay结束前0%的效果不会应用到元素上</p>
<p><code>backwards</code>:0%定义的属性立即生效，而不用等待animation-delay属性结束</p>
<p><code>forwards</code>:动画触发<code>animationend</code>时的属性继续应用到元素上</p>
<p><code>both</code>:同时包含<code>backwards</code>和<code>forwards</code>两个值的作用</p>
<h2 id="写为一个属性"><a href="#写为一个属性" class="headerlink" title="写为一个属性"></a>写为一个属性</h2><p><code>animation</code></p>
<p>前面的时间是duration,后面的是delay</p>
<p>如果动画标识符的值和某个动画属性的值相同，<code>animation-name</code>应该放在最后</p>
<p>如果有多个动画为同一个属性指定了不同的值，最后一个应用的动画覆盖之前动画中声明的值</p>
<p>先把后声明的先走完，如果有多余时间再播放前面声明的动画</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>css中position</title>
    <url>/2022/08/03/%E5%AE%9A%E4%BD%8D/</url>
    <content><![CDATA[<h1 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h1><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>static:正常生成元素框</p>
<p>relative：元素框偏移一定距离，所占空间不变</p>
<p>absolute：元素框完全从文档流中移除，相对容纳块定位</p>
<p>fixed：行为类似absolute，容纳块是视区自身</p>
<p>sticky：触发粘滞条件时，相当于相对容纳块绝对定位；触发粘滞的条件失效后，回到最初位置</p>
<h3 id="容纳块"><a href="#容纳块" class="headerlink" title="容纳块"></a>容纳块</h3><p>一般来说，容纳块指包含另一个元素的框体</p>
<p>对定位元素：</p>
<p>relative或static：容纳块由最近的祖辈元素框体的内容边界划定</p>
<p>absolute：容纳块是最近的不是static的祖辈元素</p>
<ul>
<li>块级元素：内边距边界</li>
<li>行内元素：内容边界</li>
<li>没有：初始容纳块</li>
</ul>
<p>定位元素可能位于容纳块之外</p>
<h3 id="偏移属性"><a href="#偏移属性" class="headerlink" title="偏移属性"></a>偏移属性</h3><p>top</p>
<p>bottom</p>
<p>left</p>
<p>right</p>
<h3 id="限制宽高"><a href="#限制宽高" class="headerlink" title="限制宽高"></a>限制宽高</h3><p>min-height,min-width:限制最小</p>
<p>max-width,max-height:限制最大</p>
<h3 id="内容溢出"><a href="#内容溢出" class="headerlink" title="内容溢出"></a>内容溢出</h3><p>某个元素在内容里放不下：设置overflow属性</p>
<p>visible：超出内容的部分可见</p>
<p>hidden：超出部分不可见</p>
<p>scroll：超出部分会隐藏，但可以通过滚动条查看</p>
<p>auto：让用户代理自己决定使用哪种方式，在必要时使用滚动条</p>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p><code>visibility:visible/hidden/collapse</code></p>
<p><code>visible</code>:可见</p>
<p><code>hidden</code>:隐藏（仍会占据空间，但不显示，相当于完全透明）</p>
<p><code>collapse</code>:用于渲染表格，在渲染非表格元素时和hidden一致</p>
<h3 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h3><p>如果文档能滚动，绝对定位元素也会随之滚动</p>
<h5 id="自动确定边界"><a href="#自动确定边界" class="headerlink" title="自动确定边界"></a>自动确定边界</h5><p>将绝对定位元素除bottom外的某个偏移属性值设置为auto将得到一种特殊的行为</p>
<p>即元素的位置会成为静态状态时的位置（即在常规文档流中的位置）</p>
<p>将left和right同时设成auto会让绝对定位元素水平居中</p>
<p>当元素各种属性值加起来不足容纳块的长度时（过约束），会对auto的值重新计算，当无auto时，会重新计算left或right的值</p>
<p>如果属性的值导致过约束，top将永远<strong>不被</strong>忽略</p>
<h3 id="Z-index"><a href="#Z-index" class="headerlink" title="Z-index"></a>Z-index</h3><p>z-index值越大，元素离读者越近</p>
<p>设立z-index的父元素的子元素的位置是相对于父元素的，无论子元素设置多小的z-index值都会显示在父元素上方</p>
<p>z-index：auto可视为z-index：0</p>
<h3 id="固定定位"><a href="#固定定位" class="headerlink" title="固定定位"></a>固定定位</h3><p>与绝对定位类似，但容纳块是整个视区</p>
<h3 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h3><p>相对定位使用偏移属性移动元素</p>
<p>如<code>bottom:20px</code>将把元素向上平移20px</p>
<p>在相对定位中，元素从常规的位置移开了，但其占据的空间没有消失</p>
<p>相对定位的元素同样可能会重叠</p>
<h3 id="粘滞定位"><a href="#粘滞定位" class="headerlink" title="粘滞定位"></a>粘滞定位</h3><p>粘滞定位元素通过设置偏移属性确定相对容纳块的粘滞定位矩形</p>
<p>如<code>.h2 &#123;position:stick;top:2em;bottom:auto;left:auto;right:auto&#125;</code></p>
<p>就设置了一个到达顶部就被粘滞的举行，想要让矩形在某个方向被粘滞，只需要将那个方向不设成auto即可</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>借助定位可以随意移动元素，这是常规文档流难以企及的。通过z轴确定叠放次序，加上各种溢出模式，定位依旧有用武之力</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>css中的flex布局</title>
    <url>/2022/08/03/%E5%BC%B9%E6%80%A7%E7%9B%92%E5%B8%83%E5%B1%80%EF%BC%9Aflex/</url>
    <content><![CDATA[<h1 id="弹性盒布局：flex"><a href="#弹性盒布局：flex" class="headerlink" title="弹性盒布局：flex"></a>弹性盒布局：flex</h1><h3 id="弹性盒基础"><a href="#弹性盒基础" class="headerlink" title="弹性盒基础"></a>弹性盒基础</h3><p>使用弹性盒后内容呈现顺序不再受到源码顺序的限制</p>
<p>声明<code>display:flex</code>或<code>display:inline-flex</code>即可激活弹性盒布局，然后该元素被称为弹性容器，其子元素被成为弹性元素</p>
<p>两种的区别是前者生成一个块级框，子元素在其中布局</p>
<p>后者生成一个行内级框，子元素在其中布局</p>
<p>把一个元素设为弹性容器后，只有直接子元素使用弹性盒布局</p>
<h3 id="flex-direction属性"><a href="#flex-direction属性" class="headerlink" title="flex-direction属性"></a>flex-direction属性</h3><p>设置布局的方向，指定在弹性容器中如何摆放弹性元素</p>
<p>可使用：</p>
<p><code>row</code>:横向</p>
<p><code>row-reverse</code>:横向相反</p>
<p><code>column</code>:竖向</p>
<p><code>column-reverse</code>:竖向相反</p>
<p>如果改变了书写模式，例如规定书写模式是竖向书写（如从上向下），则row表示从上到下</p>
<p>column表示从右向左</p>
<h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><p>默认情况下元素不会换行，有可能从容器框的边界溢出</p>
<p>设置flex-wrap属性允许弹性元素换行</p>
<p><code>flex-wrap:nowrap/wrap/wrap-reverse</code>(默认<code>nowrap</code>)</p>
<p>默认情况下：无论多少元素都在一行显示</p>
<p>warp：超出的部分换行到之后</p>
<p>wrap-reverse:超出部分换行到之前</p>
<h3 id="定义弹性流"><a href="#定义弹性流" class="headerlink" title="定义弹性流"></a>定义弹性流</h3><p>flex-flow：确定主轴和垂轴方向，以及元素是否换行</p>
<p><code>flex-flow:&lt;flex-direction&gt; &lt;flex-wrap&gt;</code></p>
<p>弹性元素沿主轴排列，沿垂轴添加（如果换行的话）</p>
<p>主轴一定和垂轴垂直</p>
<h3 id="调整内容"><a href="#调整内容" class="headerlink" title="调整内容"></a>调整内容</h3><p><code>justify-content</code>属性指明在弹性容器的主轴上如何分布各行里的弹性元素</p>
<p>应用于弹性容器上而不是弹性元素上</p>
<p><code>justify-content:flex-start/flex-end/center/space-between/space-around/space-evenly</code></p>
<p>默认flex-start</p>
<p><code>flex-start</code>:元素沿主轴起边排列</p>
<p><code>flex-end</code>:元素沿主轴终边排列</p>
<p><code>center</code>:元素视为一个整体排列在主轴中央</p>
<p><code>space-between</code>:把第一个元素放在主轴起边，最后一个元素放在主轴终边，中间的元素等间距排列</p>
<p><code>space-around</code>:让元素左边和右边分出等同的距离（第一个元素距离主轴起边的距离会是每两个元素之间距离的一半）</p>
<p><code>space-evenly</code>:与space-around类似但第一个元素距离主轴起边的距离与每两个元素之间距离相等</p>
<p>justify-content还会影响元素的溢出方式</p>
<h3 id="对齐元素"><a href="#对齐元素" class="headerlink" title="对齐元素"></a>对齐元素</h3><p>justify-content定义主轴方向的对齐方式，而align-items定义垂轴方向的对齐方式</p>
<p>align-items同样应用于容器上</p>
<p><code>align-items:flex-start/flex-end/center/baseline/stretch</code></p>
<p>初始值：stretch</p>
<p>stretch:可拉伸：即所有可拉伸的弹性元素将与所在行最高或最宽的弹性元素一样高或一样宽</p>
<p>如果显示设置了元素的垂轴方向尺寸，元素将不可拉伸</p>
<p>拉伸后的元素尺寸包含外边距的长度</p>
<p>弹性元素行的高或宽是正好能够放下弹性元素的尺寸</p>
<p>baseline：基线对齐，基线是文本第一行文字的底部，受到字号影响</p>
<h3 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h3><p>align-self设置的值会覆盖align-items的值</p>
<p>取值与align-item相同</p>
<h3 id="对齐内容"><a href="#对齐内容" class="headerlink" title="对齐内容"></a>对齐内容</h3><p>align-content属性指定弹性容器中垂轴方向上的额外空间如何分配到弹性元素行之间和周围</p>
<p>取值与align-items相同</p>
<p>如果只有一行，align-content对内容没有影响</p>
<h3 id="弹性元素"><a href="#弹性元素" class="headerlink" title="弹性元素"></a>弹性元素</h3><p>float和clear对弹性元素不起作用</p>
<p>变成弹性元素后，只要没有绝对定位，就是块级的</p>
<p>没有被标签包裹的文本是匿名弹性元素，不能直接选择，只能从弹性容器上继承样式</p>
<p>绝对定位的弹性元素不再参与弹性布局，它们不在文档流中，但会受到弹性容器的样式影响，先确定在弹性容器中的位置再进行position</p>
<p>弹性元素的min-width默认为auto，如果不想溢出可以设置为0，元素会被压缩</p>
<h3 id="flex属性"><a href="#flex属性" class="headerlink" title="flex属性"></a>flex属性</h3><p>flex属性是flex-grow，flex-shrink和flex-basis的简写形式（弹性增长因子，弹性缩减因子和弹性基准）</p>
<p>默认值是0，1，auto</p>
<p>flex属性指定确定弹性长度的各要素，弹性元素所在的框体尺寸由flex决定</p>
<p>弹性基准指明如何应用弹性增长因子和弹性缩减因子</p>
<h4 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h4><p>定义有多余空间时是否允许弹性元素增大，以及有多余空间时，相对于同辈弹性元素会以什么比例增大</p>
<p><strong>不鼓励通过flex-grow定义增长因子，只建议在flex简写中指定增长因子</strong></p>
<p>flex-grow的值始终是正数，小于零无效</p>
<p>flex-grow的值用于计算比例，若只有一个元素设置了flex-grow，则剩余的所有空间都被它占有，若有多个元素设置了，则会通过设置值之间的比例确定各自所占剩余空间的比例</p>
<p>如果flex属性没有设定增长因子和缩减因子，flex-grow默认为1，如果flex和flex-grow都没有被声明出来，默认为0</p>
<p>使用flex声明flex-grow属性和单独使用flex-grow声明的区别：</p>
<p>flex声明将把所有空间按比例分配，而flex-grow声明只会将余下空间按比例分配</p>
<h4 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h4><p><strong>同样只建议在flex简写属性中声明</strong></p>
<p>弹性缩减因子定义空间不足以放下所有弹性元素时，当前元素相对于其他同辈弹性元素将缩小多少</p>
<p>缩减因子默认为1</p>
<p>计算方法与grow类似：</p>
<p>如果设置shrink为1，1，3，长度均为300，容纳器长度为750</p>
<p>那么元素将分别缩小：30，30，90</p>
<p>如果弹性元素中的内容将要超出容器大小，且不能换行和缩小，弹性元素将无法缩小</p>
<p>缩减因子为任何正数都会导致内容换行，换行次数和缩减因子比例差不多</p>
<h4 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h4><p>定义弹性元素的初始或默认尺寸，即根据增长因子或缩减因子分配空间前，弹性元素的大小</p>
<p>如果提前声明了width和height，值为width和height，如果没声明，值为content</p>
<h5 id="content"><a href="#content" class="headerlink" title="content"></a>content</h5><p>在支持的环境中，使用content的basis值为弹性元素中内容的尺寸，即最长一行内容或最宽的媒体对象在主轴上的长度</p>
<p>弹性基准会覆盖元素的width和height，但不会忽略mid-width和mid-height</p>
<h5 id="auto与0"><a href="#auto与0" class="headerlink" title="auto与0"></a>auto与0</h5><p>auto下会根据grow或shrink决定<strong>剩下</strong>的区域的划分</p>
<p>0决定<strong>所有</strong>区域的划分</p>
<h3 id="flex简写模式"><a href="#flex简写模式" class="headerlink" title="flex简写模式"></a>flex简写模式</h3><p>如果只给flex一个值(数字)，实际上声明的是flex-grow</p>
<p><code>flex: initial</code>&#x3D;<code>flex:0 1 auto</code></p>
<p><code>flex:auto</code>&#x3D;<code>flex:1 1 auto</code></p>
<p><code>flex:none</code>&#x3D;<code>flex:0 0 auto</code></p>
<p><code>flex:1</code>&#x3D;<code>flex:1,0,auto</code></p>
<h3 id="order属性"><a href="#order属性" class="headerlink" title="order属性"></a>order属性</h3><p>order属性可以改变元素的出现顺序，但读取代码的顺序是不变的</p>
<p>默认值是0，负数会先出现，正数会后出现</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>弹性盒布局的效果用float也可以实现，但比float方便得多。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>一年的总结（更新中）</title>
    <url>/2022/08/06/%E6%84%9F%E6%82%9F/</url>
    <content><![CDATA[<h3 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h3><p>​	最近学习动力异常低（可能是高温学车debuff），还是写一下自己的生活感悟，简单记录下自己的大学生活。</p>
<h4 id="大学"><a href="#大学" class="headerlink" title="大学"></a>大学</h4><p>​	高考前看过b站up主阿健一个有关大学的视频，有句话记得很清楚：”我热爱学习，但我讨厌大学“。经过了一年的生活，我对这句话感悟颇深。</p>
<p>​	首先我并不讨厌大学，大学里我认识了形形色色的人，大学为我提供了更大的社交平台，五湖四海的同学在大学里得以相遇，有趣的灵魂，各异的思想在这里交流，碰撞。大学还有着学习的氛围，即使一整天都呆在寝室里，也会有很多有效学习时间，而在家里可能翻书都困难。大学里的自习室，图书馆更是学习的好去处。总的来说，大学给了我很好的平台。</p>
<p>​	但也仅仅是一个平台。大学里很多东西就我而言并不合理。</p>
<p>​	首先是课程的设置，就我所在的软件学院来说，课程的设置就有很多不合理处。举个例子，一些重要的计算机基础课程被设置在了大三，大四里面，然而这个时间段里会有很多学生已经开始在校外找实习，为了找实习这些课程他们不得不提前准备。而就如大学物理这样的通识课，在软件专业根本不会在后续学习中使用，却占据了足足两个学期。</p>
<p>​	然后是畸形的学习氛围。我所在的软件学院这方面还好，卷分数的和学技术的互不干扰相互尊重。但之前所在的网安学院不是这样。有些学院有着畸形的学习大环境。整个院自上而下的宣传保研，考研的思想。刚入校的学生往往怀有满腔热忱，更愿意在学习上下功夫，学院再加以宣传，整个学院的分数竞争便异常激烈，内卷十分严重。学生把自己卷入其中，首先是会失去或者减少自己对大学的思考，盲目的跟从课程进行学习，日复一日的刷题，内耗。也许高中的意义是进入大学，但大学的意义不应该是研究生。读研是一条清晰的路，只需要跟随课程安排，或保或考。但读研不是唯一的路，或者说读研并不是适合所有人的路。就计算机而言，找到一个适合自己的方向，不断钻研下去，大学毕业时也能进入社会找到工作。我的很多学长都是本科生就业。所以在决心读研之前，先想想自己读研是为了什么。目前社会还没到工作只招研究生的地步</p>
<p>​	还有随处可见的形式主义，学校很多地方办事效率低下（尤其是教务）等等，不再赘述</p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>​	我的过去</p>
]]></content>
      <categories>
        <category>生活</category>
        <category>感悟</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>总结</tag>
        <tag>反思</tag>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title>js数据结构：栈</title>
    <url>/2022/08/29/%E6%A0%88/</url>
    <content><![CDATA[<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈是一种后入先出的数据结构</p>
<h4 id="用JavaScript对象来创建栈"><a href="#用JavaScript对象来创建栈" class="headerlink" title="用JavaScript对象来创建栈"></a>用JavaScript对象来创建栈</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span>=<span class="number">0</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span>=&#123;&#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="title function_">push</span>(<span class="params">element</span>) &#123;<span class="comment">//向栈中添加元素</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">count</span>]=element;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span>++;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="title function_">pop</span>(<span class="params"></span>) &#123;<span class="comment">//从栈中弹出元素</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">count</span>===<span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span>--;</span><br><span class="line">    <span class="keyword">const</span> result=<span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">count</span>];</span><br><span class="line">    <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">count</span>];</span><br><span class="line">    <span class="keyword">return</span> result;<span class="comment">//返回被删除的元素</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="title function_">peek</span>(<span class="params"></span>) &#123;<span class="comment">//返回栈顶元素</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">count</span>===<span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">count</span>-<span class="number">1</span>]</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="title function_">clear</span>(<span class="params"></span>) &#123;<span class="comment">//清空栈</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span>=&#123;&#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span>=<span class="number">0</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;<span class="comment">//判断栈是否清空</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">count</span>===<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;<span class="comment">//字符串化</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> objString=<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.items[<span class="number">0</span>]&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>;i &lt; <span class="variable language_">this</span>.<span class="property">count</span>;i++) &#123;</span><br><span class="line">      objString=<span class="string">`<span class="subst">$&#123;objString&#125;</span>,<span class="subst">$&#123;<span class="variable language_">this</span>.items[i]&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> objString;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="栈的安全性"><a href="#栈的安全性" class="headerlink" title="栈的安全性"></a>栈的安全性</h4><p>我们使用栈只希望元素添加到栈顶而不是其他位置，因此要保护栈的内部元素，然而我们创建的Stack类并没有这样的功能</p>
<ul>
<li><p>用 ES2015 的 WeakMap 实现类</p>
<p>如果用 WeakMap 来存储 items 属性（数组版本），Stack 类就是这样的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> items = <span class="keyword">new</span> <span class="title class_">WeakMap</span>(); <span class="comment">// &#123;1&#125; </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123; </span><br><span class="line"> <span class="title function_">constructor</span> () &#123; </span><br><span class="line"> items.<span class="title function_">set</span>(<span class="variable language_">this</span>, []); <span class="comment">// &#123;2&#125; </span></span><br><span class="line"> &#125; </span><br><span class="line"> <span class="title function_">push</span>(<span class="params">element</span>)&#123; </span><br><span class="line"> <span class="keyword">const</span> s = items.<span class="title function_">get</span>(<span class="variable language_">this</span>); <span class="comment">// &#123;3&#125; </span></span><br><span class="line"> s.<span class="title function_">push</span>(element); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="title function_">pop</span>(<span class="params"></span>)&#123; </span><br><span class="line"> <span class="keyword">const</span> s = items.<span class="title function_">get</span>(<span class="variable language_">this</span>); </span><br><span class="line"> <span class="keyword">const</span> r = s.<span class="title function_">pop</span>(); </span><br><span class="line"> <span class="keyword">return</span> r; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="comment">// 其他方法</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>行{1}，声明一个 WeakMap 类型的变量 items。</p>
<p>行{2}，在 constructor 中，以 this（Stack 类自己的引用）为键，把代表栈的数组 存入 items。</p>
<p>行{3}，从 WeakMap 中取出值，即以 this 为键（行{2}设置的）从 items 中取值。</p>
<p>采用这种方法，代码的可读性 不强，而且在扩展该类时无法继承私有属性。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>数据结构</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>css中的grid</title>
    <url>/2022/08/04/%E6%A0%85%E6%A0%BC%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h1 id="栅格布局"><a href="#栅格布局" class="headerlink" title="栅格布局"></a>栅格布局</h1><h3 id="创建栅格容器"><a href="#创建栅格容器" class="headerlink" title="创建栅格容器"></a>创建栅格容器</h3><p><code>display:grid</code>:创建常规栅格</p>
<p><code>display:inline-grid</code>:创建行内栅格</p>
<p>常规栅格与块级元素仍有区别：</p>
<p>浮动元素不会打乱栅格容器，栅格不会移动到浮动元素下方</p>
<p>栅格容器的外边距不与其后代的外边距折叠</p>
<ul>
<li><p>栅格容器上所有column属性都被忽略</p>
</li>
<li><p>栅格容器没有::first-line和::first-letter伪元素</p>
</li>
<li><p>栅格元素的float和clear属性会被忽略</p>
</li>
<li><p>vertical-align属性对栅格元素不起作用</p>
</li>
<li><p>如果设置的是inline-grid，但目标元素是浮动的或者绝对定位的，inline-grid将变成grid</p>
</li>
</ul>
<h3 id="栅格术语"><a href="#栅格术语" class="headerlink" title="栅格术语"></a>栅格术语</h3><ul>
<li>栅格元素：通常是栅格容器的子元素或者其中的匿名文本，参与栅格布局</li>
<li>栅格轨道：两条相邻栅格线之间夹住的整个区域（栅格列，栅格行）</li>
<li>栅格单元：四条栅格线确定的区域，内部没有其他栅格线（最小单元格）</li>
<li>栅格区域：任意四条栅格线确定的区域，最小的栅格区域是栅格单元</li>
</ul>
<h3 id="放置栅格线"><a href="#放置栅格线" class="headerlink" title="放置栅格线"></a>放置栅格线</h3><p>使用<code>grid-template-rows</code>和<code>grid-template-columns</code>定义栅格模板中的栅格线</p>
<h4 id="宽度固定的栅格轨道"><a href="#宽度固定的栅格轨道" class="headerlink" title="宽度固定的栅格轨道"></a>宽度固定的栅格轨道</h4><p>宽度固定指栅格线之间的距离不随着栅格轨道中内容的变化而变化，百分数也算宽度固定</p>
<p>如<code>grid-template-columns:100px 50% 200px</code>;</p>
<p>为栅格线命名：使用中括号，如：</p>
<p><code>grid-template-columns:[start]100px[first] 50%[second] 200px[end]</code>为四条栅格线分别命名</p>
<p>名称可以重用</p>
<p>设置百分数时可能会使内容超出容器，可以使用设置极值的方式解决</p>
<p>设定极值<code>minmax(a,b)</code>指明行的高度不能小于一个值也不能大于一个值</p>
<p>如<code>grid-template-columns:[start]100px[first] minmax(3em,50%)[second] 200px[end]</code>规定列宽不能大于50%也不能小于3个字号</p>
<p>使用设定极值时浏览器会自动计算让其在范围内把剩余空间尽量铺满</p>
<p>除了使用minmax()还可以使用calc()计算</p>
<h4 id="弹性栅格轨道"><a href="#弹性栅格轨道" class="headerlink" title="弹性栅格轨道"></a>弹性栅格轨道</h4><p>弹性栅格轨道的尺寸基于整个轨道中的具体内容而定</p>
<p>份数单位：fr</p>
<p><code>grid-template-columns:1fr 1fr 1fr 1fr</code>&#x3D;<code>grid-template-columns:25% 25% 25% 25%</code></p>
<p>除了替代百分数外，fr还可以实现部分弹性伸缩</p>
<p>例如：<code>grid-template-columns:100px 1fr 100px</code></p>
<p>容器宽度大于200px时，剩余部分会全被分给1fr对应的部分</p>
<p>minmax()设定的最小值不允许以fr为单位，但最大值可以</p>
<h5 id="min-content和max-content"><a href="#min-content和max-content" class="headerlink" title="min-content和max-content"></a>min-content和max-content</h5><p>max-content:占据内容所需的最大空间&#x2F;内容尽量宽，以免换行</p>
<p>min-content:尽量少占据空间，能够显示出内容即可</p>
<p>这两个属性会应用到整个栅格轨道之上，如果把一列的尺寸设置成max-content,整列的宽度都与列中最宽的内容一样</p>
<p>如果在minmax中设置<code>minmax(0,max-content)</code>；那么将在确保不超出弹性容器的基础上尽量向max的值靠拢</p>
<p>如果将列和行都设置为max-content，浏览器先解析列再解析行，和只设置列是一样的</p>
<h5 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h5><p>auto用作最小值时，视作栅格元素的最小尺寸（由mid-width和mid-height定义）</p>
<p>作最大值时，作用等同于max-content</p>
<p>任何地方都可以使用auto，要么作最小值，要么作最大值，但<strong>尽量避免使用auto</strong></p>
<h5 id="fit-content"><a href="#fit-content" class="headerlink" title="fit-content"></a>fit-content</h5><p><code>fit-content(argument)=minmax(argument&gt;min-content?argument:min-content , argument&lt;max-content?arguement:max-content);</code></p>
<p>使用fit-content,内容不多时，轨道将缩小为最小内容尺寸，内容较多时，能为轨道尺寸设置一个上限</p>
<h4 id="重复栅格线"><a href="#重复栅格线" class="headerlink" title="重复栅格线"></a>重复栅格线</h4><p>使用repeat（）设置重复栅格线</p>
<p>例如：<code>grid-template-columns:repeat(10,5em)</code>将创建10个5字号轨道宽度的列轨道</p>
<p>也可以重复固定模式的列轨道</p>
<p>如：<code>grid-template-columns:repeat(10,5em 1fr 1fr)</code>将创建列结构为5em，1fr，1fr，然后重复10次，也就是创建了30个列轨道</p>
<p>如果想额外增加列，可以：<code>grid-template-columns:repeat(10,5em 1fr 1fr) 5em</code>在重复结束后加上一个列轨道</p>
<p>repeat（）中几乎可以使用任意值，但不能在重复中嵌套重复</p>
<h5 id="自动填充轨道"><a href="#自动填充轨道" class="headerlink" title="自动填充轨道"></a>自动填充轨道</h5><p>如果想让一直重复：<code>repeat(auto-fill,5em)</code>将会把5em的宽度一直重复到放不下为止</p>
<p>在一个模板里只能有一个自动重复的模式</p>
<p>固定数量的重复模式可以与自动填充的轨道结合到一起使用</p>
<p>使用auto-fill，没有元素的单元格会得到保留</p>
<p>但如果使用auto-fit，则会剔除</p>
<h4 id="栅格区域"><a href="#栅格区域" class="headerlink" title="栅格区域"></a>栅格区域</h4><p><code>grid-template-areas:none/String</code></p>
<p>使用字符串作为标识符，合并相同字符串</p>
<p>如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">grid-template-areas</span>:</span><br><span class="line"><span class="string">&quot;h h h h&quot;</span></span><br><span class="line"><span class="string">&quot;b c c c&quot;</span></span><br><span class="line"><span class="string">&quot;f f d d&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>第一行只有一列，第二行两列，宽度1：3，第三行同理</p>
<p>只能合并矩形区域，不能合并非矩形区域，形状太复杂会导致模板失效</p>
<p>通过area为区域标记名称，区域的栅格线实际上也已经隐式确定了名称</p>
<p>为了与内容匹配可以设置元素的grid-area</p>
<h3 id="在栅格中添加元素"><a href="#在栅格中添加元素" class="headerlink" title="在栅格中添加元素"></a>在栅格中添加元素</h3><p>可以引用栅格线，也可以引用栅格区域</p>
<h4 id="使用行线和列线"><a href="#使用行线和列线" class="headerlink" title="使用行线和列线"></a>使用行线和列线</h4><p><code>grid-row-start</code>:规定元素起始的行线（栅格线）</p>
<p><code>grid-row-end</code>:规定元素在那条行线结束</p>
<p><code>grid-column-start</code>和<code>grid-column-end</code>同理</p>
<p>如果省略的结束线，则自动使用起始线的下一条线结束，这等同于</p>
<p><code>grid-column-end:span 1 </code>或<code>grid-column-end: span</code></p>
<p>span后面的数字表示”跨越指定数目的栅格轨道“，只能用正整数</p>
<p>span既可以用于开始线也可以用于结束线。用于开始线时，意思是”从结束线开始，向开始方向计数“</p>
<p>通过显式定义的栅格线编号可以为负数，代表从后往前数第|n|个栅格线</p>
<p>栅格线编号除了通过数字引用也可以通过声明过的命名调用</p>
<p>还可以通过<code>grid-template-area</code>中定义的名称调用</p>
<h4 id="行和列的简写"><a href="#行和列的简写" class="headerlink" title="行和列的简写"></a>行和列的简写</h4><p>使用<code>grid-row</code>和<code>grid-column</code>可以简化声明开始和结束栅格线的过程</p>
<p>如：<code>grid-row:1/3</code></p>
<p>以斜线分割的两部分中，前半部分定义开始栅格线，后半部分定义结束栅格线</p>
<p>如果没有斜杆，定义的是开始栅格线，结束栅格线的位置却决于开始栅格线</p>
<ul>
<li>如果开始栅格线是名称，结束栅格线就是下一条同名栅格线</li>
<li>如果只提供一个数字，下一个栅格线是auto</li>
</ul>
<h4 id="隐式栅格"><a href="#隐式栅格" class="headerlink" title="隐式栅格"></a>隐式栅格</h4><p>如果行线只显示定义了三条，却进行了类似<code>grid-row:1/4</code>这样的声明，浏览器会再创建一条行线，这条栅格线和由此产生的栅格轨道是隐式栅格的一部分</p>
<p>span是从显示栅格内部开始计数的，但不一定在显示栅格内部结束</p>
<h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>如果开始线在结束线后面，会将两者对调</p>
<p>如果开始线和结束线都为跨度，忽略结束线并将值设置成auto</p>
<h4 id="使用区域"><a href="#使用区域" class="headerlink" title="使用区域"></a>使用区域</h4><p>将预先声明的<code>grid-template-areas</code>的标识符通过<code>grid-area</code>赋给元素</p>
<p>grid-area也可以直接使用</p>
<p><code>grid-area:row-start/column-start/row-end/column-end</code>根据这种规范来确定区域</p>
<h4 id="栅格元素重叠"><a href="#栅格元素重叠" class="headerlink" title="栅格元素重叠"></a>栅格元素重叠</h4><p>栅格元素是有可能重叠的</p>
<h3 id="栅格流"><a href="#栅格流" class="headerlink" title="栅格流"></a>栅格流</h3><p>栅格流主要分为两种模式：行优先和列优先，二者都可以通过密集流增强</p>
<p>通过grid-auto-flow设置栅格流</p>
<p><code>grid-auto-flow:row/column||dense</code>默认是row</p>
<p>栅格流放置的实际上是栅格区域，然后再把栅格元素放置到栅格区域中</p>
<p>行流和列流的工作方式是：如果下一个单元格可以放下对应的元素则放下，如果不能则跳过此单元格保证顺序。</p>
<p>如果想让元素尽量堆满单元格而不考虑顺序，可以在<code>grid-auto-flow</code>中加入dense</p>
<h3 id="自动增加栅格线"><a href="#自动增加栅格线" class="headerlink" title="自动增加栅格线"></a>自动增加栅格线</h3><p>如果有元素超出了声明的行&#x2F;列，系统会自动增加栅格线</p>
<p>一般来说，自动增加的栅格线对应的是最小尺寸，如果需要修改最小尺寸，可以使用</p>
<p><code>grid-auto-columns,grid-auto-rpws</code></p>
<p>可以为其添加一个属性值（极值）来为自动添加的行规范尺寸</p>
<h3 id="栏距"><a href="#栏距" class="headerlink" title="栏距"></a>栏距</h3><p>栏距由row-gap和column-gap设置，只能为非负数，不能为百分数或fr</p>
<p>简写是grid-gap</p>
<h3 id="栅格元素与盒模型"><a href="#栅格元素与盒模型" class="headerlink" title="栅格元素与盒模型"></a>栅格元素与盒模型</h3><p>当未为元素设置width和height时，设置正外边距会让元素向中心收缩，负外边距会向周围扩张</p>
<p>如果元素尺寸设置了，那么外边距将被覆盖</p>
<p>元素外边距不会影响栅格轨道尺寸的计算</p>
<p>如果栅格元素声明了绝对定位：对应的栅格区域充当容纳块和定位上下文</p>
<h3 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h3><p><code>justify-self</code>和<code>align-self</code>:控制元素在对应栅格区域内的横向&#x2F;纵向对齐方式</p>
<p><code>justify-item</code>和<code>align-item</code>:控制栅格容器内所有元素的横向&#x2F;纵向对齐方式</p>
<p><code>justify-content</code>和<code>align-content</code>:控制栅格的对齐属性，为栅格分配多余的空间事实上是调整栅格的栏距尺寸</p>
<h3 id="分层和排序"><a href="#分层和排序" class="headerlink" title="分层和排序"></a>分层和排序</h3><p>元素若重叠，分层可以使用z-index</p>
<p>若想控制元素出现的顺序，同样可以使用order，只改变视觉顺序不改变阅读源码顺序</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>栅格布局内容繁杂，引入了大量新特性，需要时常温故知新</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器的工作原理</title>
    <url>/2022/08/03/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%88%E7%AE%80%E6%98%93%E7%89%88%EF%BC%89/</url>
    <content><![CDATA[<h3 id="浏览器的工作原理（简易版）"><a href="#浏览器的工作原理（简易版）" class="headerlink" title="浏览器的工作原理（简易版）"></a>浏览器的工作原理（简易版）</h3><p>输入url后</p>
<ol>
<li><p>浏览器进行dns查找，把域名转换为ip地址，根据ip地址找到对应的服务器</p>
</li>
<li><p>浏览器通过TCP握手机制跟服务器建立连接，如果为https还有一步TLS握手</p>
</li>
<li><p>浏览器发起http&#x2F;https请求，获取响应。在浏览器接收响应时，受制于TCP连接的性质，浏览器先收到前14kb的数据，后续才会慢慢增加传输速度下载其他文件</p>
</li>
<li><p>收到html代码后，浏览器开始渲染网页</p>
<ol>
<li><p>解析html代码，构建DOM树（HTML文档在浏览器中的对象表示）</p>
<p>浏览器在解析HTML时顺序执行并且只有一个主线程负责，遇到script标签会先执行js代码，暂停解析html代码。对于图片，css文件，设置了defer&#x2F;async的script标签不会影响html解析，会异步加载</p>
<p>浏览器具有预扫描线程，扫描html代码，提前把css文件，字体，js文件下载下来，不影响主线程</p>
<p><img src="/image/image1.png" alt="dom树"></p>
</li>
<li><p>构建CSSOM树</p>
<p><img src="/image/image2.png" alt="CSSOM树"></p>
</li>
<li><p>合并DOM和CSSOM，形成渲染树</p>
<p><img src="/image/image3.png" alt="渲染树"></p>
</li>
<li><p>布局</p>
<p>对于图片这样的结点，如果没有指定宽高，会先忽略大小。图片下载完成后，浏览器根据图片的大小重新计算受影响的结点的宽高，这种方法被称为回流（reflow）</p>
</li>
<li><p>绘制</p>
<p>第一次布局之后，浏览器会把结点和结点的样式绘制在屏幕上，要求过程快速</p>
<p>如果布局发生回流，浏览器会发生重绘，把变化的布局重新绘制在屏幕上</p>
<p>绘制期间可能会有组合发生（产生了新的图层）,浏览器需要把图层组合起来，按正确的图层顺序渲染，发生了重绘也会导致重新组合</p>
<p>上述五步完成后，设置了defer&#x2F;async的script中的内容，网页加载完成</p>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>关于爱情</title>
    <url>/2022/08/06/%E7%88%B1%E6%83%85/</url>
    <content><![CDATA[<h3 id="爱情"><a href="#爱情" class="headerlink" title="爱情"></a>爱情</h3><p>看了b站一个视频，对其中的内容做一个笔记，结合一下自身</p>
<h3 id="爱与情"><a href="#爱与情" class="headerlink" title="爱与情"></a>爱与情</h3><p><strong>爱是能发自内心的替ta而死，情是能彼此同时能有一种感觉</strong></p>
<p>​	爱是能发自内心的替ta而死，替ta而死不是为ta而死。为ta而死总有种自我感动的成分在其中，替ta而死更接近于你可以在ta不知道你死的情况下去死。父母的爱是真正的爱，他们往往能做到替孩子而死，即使孩子很叛逆很无知。为ta而死的情感最多可以称为恋，不是爱。</p>
<p>​	情是彼此同时有一种感觉。情强调双向，如亲情，如果只是父母对孩子很好，而孩子不知感恩，对父母很差的话，我们只能评价他爸他妈对他很好，他爸他妈很惯他，而不能说他们家庭里亲情很浓厚</p>
<p>​	那么爱情就是双方都能感觉到让对方活比自己活更为快乐</p>
<h3 id="男性：真理"><a href="#男性：真理" class="headerlink" title="男性：真理"></a>男性：真理</h3><p>​	在谈如何选择爱时，先解释一下男性和女性对待事物的原型。男性的原型是真理，女性的原型是爱。真理和爱是生命的一部分，真理是生命的形式，爱是生命的力量。当谈到爱情的时候，要有爱的感觉，然后也要有途径</p>
<p>​	真理是强调过程，行为的。当男性谈到一件事的时候，一件不能十分轻松做到的事的时候，相比于判断自己是否真的要做，会花更多的精力研究怎么去做，完成的途径。</p>
<p>​	男性在对待伴侣的选择问题是，会更想寻找一个对自己有所爱慕，敬仰的。因为真理本身的特点就是渴望被认可，敬佩的，兄弟彼此之间的敬佩也是这个原因。我们谈到智者也会先联想到男性老者而不是女性老者，也是因为男性会更强调认可。</p>
<h3 id="女性：爱"><a href="#女性：爱" class="headerlink" title="女性：爱"></a>女性：爱</h3><p>​	相比于男性的真理，女性的原型就是爱。<strong>真理强调行为，爱强调选择</strong>。女性会更需要<strong>承认</strong>，承认是指自己不用变，做自己就行了。而男性在这方面是相反的，男性更倾向于改变。男性的真理需要扩充，不断更新，女性的爱则更倾向于自己的内心不被污染，更倾向保护，保护自己的纯真</p>
<h3 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h3><p>​	通过男性和女性的原型，可以有：<strong>男性看行动，女性看选择</strong>。女性选择男性，要看这个男性做了什么而不是说了什么，因为男性在语言上是可以学习的，可以学习各种话术。他可以让女性认为自己可能是怎样的，通过话术包装自己。男性的行为往往可以反应出他的真理，因此在选择男性时更应该看行为。</p>
<p>​	而男性选择女性，要看女性在关键时刻做出的选择。我们经常可以发现，一对男女在经历过一件事之后，男性会说自己突然发现她不爱我了，因为他看到了女性的选择。男性选择女性，不必纠结于女性过去做了什么，这是真理层面的内容，而是要看她在人生关键时刻做出的选择。她对这些事情的选择体现了她的爱。例如一个女性，当她的生活安然无恙时她体现的很纯良，但当压力很大，面临危机时，这时候应该看她选择宽恕还是憎恶，戾气还是温柔，这样就知道她的爱了</p>
<p>最后贴一下视频链接<a href="https://www.bilibili.com/video/BV15a411f7Xt/?spm_id_from=333.788&vd_source=ea0b821b0c66dd7f6257ac303626c797">18分钟解密爱情的核心，男生看行动，女生看选择_哔哩哔哩_bilibili</a>单纯是比较赞同观点而记录下</p>
]]></content>
      <categories>
        <category>爱情</category>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>爱情</tag>
        <tag>真理</tag>
        <tag>爱</tag>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title>css中的滤镜，混合，遮罩，裁剪</title>
    <url>/2022/08/03/%E6%BB%A4%E9%95%9C%E3%80%81%E6%B7%B7%E5%90%88%E3%80%81%E8%A3%81%E5%89%AA%E5%92%8C%E9%81%AE%E7%BD%A9/</url>
    <content><![CDATA[<h1 id="滤镜、混合、裁剪和遮罩"><a href="#滤镜、混合、裁剪和遮罩" class="headerlink" title="滤镜、混合、裁剪和遮罩"></a>滤镜、混合、裁剪和遮罩</h1><h2 id="CSS滤镜"><a href="#CSS滤镜" class="headerlink" title="CSS滤镜"></a>CSS滤镜</h2><p><code>filter:none/blur()/brightness()/contrast()/drop-shadow()/grayscale()/</code></p>
<p><code>hue-rotate()/invert()/opacity()/sepia()/saturate()/url()</code></p>
<p>滤镜函数可以有多个，之间以空格分隔，各滤镜按列出的顺序应用</p>
<h3 id="基本滤镜"><a href="#基本滤镜" class="headerlink" title="基本滤镜"></a>基本滤镜</h3><p><code>blur(&lt;length&gt;)</code>使用高斯模糊对元素进行处理，标准偏差由length的值确定，设为0时不做模糊处理，不能为负值</p>
<p><code>opacity(&lt;number&gt;|&lt;percentage&gt;)</code>把透明度应用到元素上，与opacity属性十分相似，0表示完全透明，1或100%不做处理，不能使用负值</p>
<p><code>drop-shadow(&lt;length&gt;&#123;2,3&#125;&lt;color&gt;?)</code>长度和颜色的处理方式和box-shadow一样，如果不提供color，则使用元素的color属性决定阴影颜色</p>
<h3 id="颜色滤镜"><a href="#颜色滤镜" class="headerlink" title="颜色滤镜"></a>颜色滤镜</h3><p><code>grayscale([&lt;length&gt;|&lt;percentage&gt;])</code>把元素颜色变为指定的灰阶，当为0时不变，值为1或100%时完全变灰</p>
<p><code>sepia([&lt;number|&lt;percentage&gt;])</code>把元素由原色变为墨色调，当为0时不变，值为1或100%时完全变褐色</p>
<p><code>invert([&lt;number|&lt;percentage&gt;])</code>把元素作反相处理，0时不变，1时完全反相，0.5时得到均匀的灰色</p>
<p><code>hue-rotate(&lt;angle&gt;)</code>在色轮上旋转色相，而饱和度和透明度不变，0deg时无变化，360deg时也没变化，也可以为负数，表示逆时针转动</p>
<h3 id="亮度，对比度，饱和度"><a href="#亮度，对比度，饱和度" class="headerlink" title="亮度，对比度，饱和度"></a>亮度，对比度，饱和度</h3><p><code>brightness([&lt;number|&lt;percentage&gt;])</code>调整亮度，0时为黑色，1时正常，大于1时变亮，最终可能会变为白色</p>
<p><code>contrast([&lt;number|&lt;percentage&gt;])</code>调整对比度，0时变为纯灰色，1时正常，大于1时对比度加大</p>
<p><code>saturate([&lt;number|&lt;percentage&gt;])</code>调整饱和度,值越大颜色越鲜艳，越小颜色越暗淡</p>
<h3 id="SVG滤镜"><a href="#SVG滤镜" class="headerlink" title="SVG滤镜"></a>SVG滤镜</h3><p><code>url()</code>可以使用这个函数指定在SVG中定义的滤镜，实现从外部引用滤镜</p>
<h2 id="合成和混合"><a href="#合成和混合" class="headerlink" title="合成和混合"></a>合成和混合</h2><p>使用<code>mix-bend-mode</code>属性设定</p>
<p><code>mix-bend-mode: normal/multiply/screen/overlay/darken/lighten/color-dodge</code></p>
<p><code>/color-burn/hard-light/soft-light/difference/exclusion/hue/saturation/color/luminosity</code></p>
<ul>
<li>应用<code>mix-bend-mode</code>的元素是前景</li>
<li>位于元素背后的是背着物</li>
<li>像素分量是某个像素的颜色分量</li>
</ul>
<h3 id="变暗，变亮，差值和排除"><a href="#变暗，变亮，差值和排除" class="headerlink" title="变暗，变亮，差值和排除"></a>变暗，变亮，差值和排除</h3><p><code>darken</code>:前景中每个像素与背着物每个像素比较，取R,G,B中的较小值</p>
<p><code>lighten</code>:前景中每个像素与背着物每个像素比较，取R,G,B中的较大值</p>
<p><code>difference</code>:前景中每个像素与背着物每个像素比较，取R,G,B差的绝对值</p>
<p><code>exclusion</code>:<code>difference</code>的温和版本，所用公式是back+fore-|2 x back x fore|,back和fore是0到1之间的值</p>
<h3 id="正片叠底，滤色和叠加"><a href="#正片叠底，滤色和叠加" class="headerlink" title="正片叠底，滤色和叠加"></a>正片叠底，滤色和叠加</h3><p><code>multiply</code>:前景中每个像素分量与背着物中对应位置上的像素分量相乘。得到的结果与前景相比更暗</p>
<p><code>screen</code>:对前景和背着物中同一位置的像素分量作反相处理，相乘后再反相。得到的结果与前景相比更亮</p>
<p><code>overlay</code>:<code>multiply</code>和<code>screen</code>的综合运用，如果前景像素分量比50%暗，执行multiply，反之执行screen</p>
<h3 id="强光和柔光"><a href="#强光和柔光" class="headerlink" title="强光和柔光"></a>强光和柔光</h3><p><code>hard-light</code>: 与<code>overlay</code>相反，起决定作用的是背着物</p>
<p><code>soft-light</code>:<code>hard-light</code>的柔和版本，效果有所缓和</p>
<h3 id="颜色减淡和加深"><a href="#颜色减淡和加深" class="headerlink" title="颜色减淡和加深"></a>颜色减淡和加深</h3><p><code>color-dodge</code>:前景中各像素分量做反相处理，再拿背着物中对应的像素分量除以反相后的前景值。得到的结果是背着物变得更亮</p>
<p><code>color-bend</code>:与<code>color-dodge</code>的作用相反。背着物各像素分量做反相处理，反相后的背着物值除以没有修改的前景值，然后再反相。结果是背着物中越暗的像素，由前景中像素加深的程度越大</p>
<h3 id="色相，饱和度，明度和颜色"><a href="#色相，饱和度，明度和颜色" class="headerlink" title="色相，饱和度，明度和颜色"></a>色相，饱和度，明度和颜色</h3><p><code>hue</code>:把背着物中每一像素的明度和饱和度与前景中对应像素的色相角度合并</p>
<p><code>saturation</code>:把背着物中每一像素的色相角度和明度与前景中对应像素的饱和度合并</p>
<p><code>color</code>:把背着物中每一像素的明度与前景中对应像素的色相角度和饱和度合并</p>
<p><code>luminosity</code>:把背着物中每一像素的色相角度和饱和度与前景中的对应像素合并</p>
<h2 id="与背景混合"><a href="#与背景混合" class="headerlink" title="与背景混合"></a>与背景混合</h2><p><code>mix-blend-mode</code>只能将元素与背着物混合，当元素有多个背景图且背景图有重叠时，可以使用<code>background-blend-mode</code>属性</p>
<p>该属性的值与<code>mix-blend-mode</code>相同</p>
<h3 id="独立混合"><a href="#独立混合" class="headerlink" title="独立混合"></a>独立混合</h3><p>使用<code>isolation:isolate</code>将父元素独立出来从而影响子元素的混合方式</p>
<h2 id="裁剪和遮罩"><a href="#裁剪和遮罩" class="headerlink" title="裁剪和遮罩"></a>裁剪和遮罩</h2><p>如果只想把元素的一部分裁掉，可以使用<code>clip-path</code>属性</p>
<h3 id="裁剪形状"><a href="#裁剪形状" class="headerlink" title="裁剪形状"></a>裁剪形状</h3><p><code>inset()</code>:值为1到4个长度或百分数，定义距离范围框各边的偏移量,可以使用<code>round</code>关键字或另一组4个长度或百分比定义圆角</p>
<p><code>circle()</code>:只接受一个值定义圆的半径。在一或两个长度或百分数后使用at关键字定义圆心位置</p>
<p><code>ellispse()</code>值为两个长度或百分数或关键字定义椭圆在横轴或纵轴上的半径，在一或两个长度或百分数后使用at关键字定义圆心位置</p>
<p><code>polygon()</code>一系列以x和y坐标值（空格分开）定义多边形</p>
<h2 id="蒙版"><a href="#蒙版" class="headerlink" title="蒙版"></a>蒙版</h2><p>“蒙版的意思是”：位于形状内部的内容可见，而在形状外部的内容不可见</p>
<h3 id="定义蒙版"><a href="#定义蒙版" class="headerlink" title="定义蒙版"></a>定义蒙版</h3><p>指定用什么图像作为蒙版:<code>mask-image</code></p>
<h3 id="改变蒙版模式"><a href="#改变蒙版模式" class="headerlink" title="改变蒙版模式"></a>改变蒙版模式</h3><p>使用<code>mask-mode</code>改变蒙版模式</p>
<p><code>mask-mode:alpha/luminance/match-source</code></p>
<p><code>alpha</code>:通过alpha通道计算蒙版，<code>luminance</code>使用亮度计算蒙版</p>
<p><code>match-source</code>:是<code>alpha</code>和<code>luminance</code>的结合体</p>
<h3 id="调整蒙版尺寸和重复方式"><a href="#调整蒙版尺寸和重复方式" class="headerlink" title="调整蒙版尺寸和重复方式"></a>调整蒙版尺寸和重复方式</h3><p>使用<code>mask-size</code>调整蒙版尺寸</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>HUSTSE李院长数据结构课程初评</title>
    <url>/2022/08/31/%E7%AE%80%E8%AF%84%E8%BD%AF%E9%99%A2%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE/</url>
    <content><![CDATA[<h3 id="HUSTSE数据结构李院长课程听后感"><a href="#HUSTSE数据结构李院长课程听后感" class="headerlink" title="HUSTSE数据结构李院长课程听后感"></a>HUSTSE数据结构李院长课程听后感</h3><p>​	首先，我很少听课，或者很少上课，因为李院长特有的随时提问机制，不得不选择听课，听了两节课之后，简要写一下听后感</p>
<p>​	其实对于李院长的课我早已有了心理准备，作为软院四大名师之一声名远扬，念念ppt，上课水我确实能够接受，毕竟很多老师都是这样，给学生留下了充足的自学空间</p>
<p>​	但李院长能位列四大名师，必定有他过人之处：<strong>让你无论是听课还是自学都困难</strong></p>
<p>​	首先课堂上我个人认为学生有权利选择是否听课，因为授课老师的方式或者教学质量并不能适合所有学生，学生应该选择更适合自己的学习方式，然而李不同意。李对自己的课堂教学有着超出寻常的自信，认为我们都应该认真听他上课。事实是什么样子呢？喜欢夹带些英语，问些奇怪问题暂且不说，自己做的ppt上的断句都要琢磨半天真的像是认真备课的样子吗？而且不知道自己上节课讲了什么，把要讲的内容当成讲过的内容，是不是祖传ppt就忘了备课？反正我听下来是比较失望的</p>
<p>​	如果我已经听到这里，我一定会选择打开电脑自己去实现数据结构，然而，李院长通过提问实时检测你有没有听课。而且他提问的内容千奇百怪，因为我个人有一些数据结构基础，我的个人感觉是他认为我们都已经学完数据结构了，能回答他的问题的同学应该是提前学过的。对于没有学过的同学，既不知道他在问什么，也不知道他问的有什么用。除了这种“向后提问”，还有”向前提问“。李会突然提问他刚刚讲过的知识，仿佛在抽查同学们的听课效率，让我梦回高中。</p>
<p>​	最后一点，还是这个提问，我最想说的其实是尊重问题。李明显有种作为教师高高在上的感觉，他不屑于倾听，只想听到他想听到的答案。因此他会突然打断同学的发言让他坐下或者提问其他人。如果是想省时间就不要提问好吧，提问又不给学生最基本的尊重，属于师德问题。</p>
<p>​	顺便提一下上学期教英语的Helen老师，真的天使，无论学生有没有听课，回答的怎么样，她都能认真倾听，努力识别我们不熟的口语。她真的是很照顾学生的老师，希望李能够向她学习。</p>
<p>​	目前只听了两堂课，后面可能会再写些，关于他数据结构核心知识的讲解评价</p>
<p>​	</p>
]]></content>
      <categories>
        <category>课堂</category>
        <category>评价</category>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
        <tag>课程评价</tag>
      </tags>
  </entry>
  <entry>
    <title>css中的过渡</title>
    <url>/2022/08/03/%E8%BF%87%E6%B8%A1/</url>
    <content><![CDATA[<h1 id="过渡"><a href="#过渡" class="headerlink" title="过渡"></a>过渡</h1><h2 id="定义过渡属性"><a href="#定义过渡属性" class="headerlink" title="定义过渡属性"></a>定义过渡属性</h2><p>CSS中使用四个属性定义过渡</p>
<p><code>transition-property</code></p>
<p><code>transition-duration</code></p>
<p><code>transition-timing-function</code></p>
<p><code>transition-delay</code></p>
<p>以及简写属性<code>transition</code></p>
<p>与过渡相关的属性加在非悬停状态上可以使开始和结束状态都实现过渡</p>
<p>而加在悬停状态上只会使开始时实现过渡，结束时瞬时切换</p>
<h3 id="设置使用过渡的属性transition-property"><a href="#设置使用过渡的属性transition-property" class="headerlink" title="设置使用过渡的属性transition-property"></a>设置使用过渡的属性<code>transition-property</code></h3><p>属性的值是以逗号分隔的属性列表，指使用过渡的属性</p>
<p>默认值为all，即所有支持动画的属性都采用过渡</p>
<p>不支持动画的属性会立即变为过渡后的值</p>
<p>如果需要对某些例外属性单独设置，应该把all设在首位，然后声明例外的属性如：</p>
<p><code>transition:all,color;  transition-duration:1s,2s;</code></p>
<p>值为none时禁用所有过渡，如果想禁用部分只能单独列出其他所有元素</p>
<h3 id="设置过渡持续时间transition-duration"><a href="#设置过渡持续时间transition-duration" class="headerlink" title="设置过渡持续时间transition-duration"></a>设置过渡持续时间<code>transition-duration</code></h3><p>值是以逗号分隔的长度列表，单位为s或ms，指定从一个状态过渡到另一个状态需要多久</p>
<p>如果在两个状态间来回切换但只设置了一个时间，则那么这个时间只在向那个状态过渡时起作用</p>
<p>即使值为零也要写成0s</p>
<p>如果设置的<code>transition-delay</code>时长不为正数，<code>transition-duration</code>又没有声明，不会触发<code>transitionend</code>事件，只要过渡总时间大于0s，就会触发<code>transitionend</code>事件</p>
<p>如果列表中有一个时间为负数，整个<code>transition-duration</code>属性都会失效</p>
<p>如果时间列表中时间数量与属性数量不一致，按照浏览器的规则处理</p>
<p>如果时间数多于属性数，忽略后面的属性</p>
<p>如果时间数少于属性数且恰好为2个，奇数属性使用第一个，偶数属性使用第二个</p>
<p>100ms到200ms的时间最佳</p>
<h3 id="调整过渡的内部时序transition-timing-function"><a href="#调整过渡的内部时序transition-timing-function" class="headerlink" title="调整过渡的内部时序transition-timing-function"></a>调整过渡的内部时序<code>transition-timing-function</code></h3><p>可以取的值有<code>ease,linear,ease-in,ease-out,ease-in-out,step-start,step-end,steps(n,start)(n是步进的次数),step(n,end),cubic-bezier(x1,y1,x2,y2)</code></p>
<h4 id="通过三次方贝塞尔函数定义"><a href="#通过三次方贝塞尔函数定义" class="headerlink" title="通过三次方贝塞尔函数定义"></a>通过三次方贝塞尔函数定义</h4><p><code>ease</code>慢速开始，中间很快，然后变慢，结尾特别慢</p>
<p><code>linear</code>整个过程匀速</p>
<p><code>ease-in</code>慢速开始，然后加速</p>
<p><code>ease-out</code>快速开始，然后慢速</p>
<p><code>ease-in-out</code>于ease类似，两端慢中间快，但两端不同速</p>
<p><code>cubic-bezier(x1,y1,x2,y2)</code>定义一个三次方贝塞尔函数</p>
<h4 id="通过步进时序函数定义"><a href="#通过步进时序函数定义" class="headerlink" title="通过步进时序函数定义"></a>通过步进时序函数定义</h4><p><code>step-start</code>整个过程都处于最终关键帧上，等同于<code>steps(1,start)</code></p>
<p><code>step-end</code>整个过渡都在初始关键帧上，等同于<code>steps(1,end)</code></p>
<p><code>steps(n,start)</code></p>
<p><code>step(n,end)</code></p>
<p>这两个函数可以显示固定的镜头数</p>
<p>使用<code>transition-timing-function</code>不改变过渡的持续时间，只控制过渡的行进节奏</p>
<h3 id="延时过渡transition-delay"><a href="#延时过渡transition-delay" class="headerlink" title="延时过渡transition-delay"></a>延时过渡<code>transition-delay</code></h3><p>该属性在元素上发生触发过渡的变化与开始过渡之间引入一定的延迟</p>
<p>默认是0s，即无延迟</p>
<p>值也可以为负数</p>
<p>设置延迟可以防止误操作</p>
<h5 id="值为负数"><a href="#值为负数" class="headerlink" title="值为负数"></a>值为负数</h5><p>如果值为负数，则会从中间某个位置立即过渡</p>
<p>如：让元素x移动200像素，<code>transition-duration</code>设置为200ms,<code>transition-delay</code>设置为-150ms，那么元素x将立即移动150px，再过渡运动到200px</p>
<p>从悬停状态回到初始状态时，默认还会使用相同的delay值，所以x会立即反向运动150px，再过渡回到原点</p>
<h3 id="transition简写"><a href="#transition简写" class="headerlink" title="transition简写"></a><code>transition</code>简写</h3><p>可以同时书写四个属性</p>
<p>如果没有声明<code>transition-timing-function</code>默认为ease</p>
<p>要注意<code>transition-duration</code>和<code>transition-delay</code>的顺序，前面的是<code>duration</code>,后面的是<code>delay</code></p>
<p>持续时间必须设置，否则过渡不可见</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>css中表格样式</title>
    <url>/2022/08/03/%E8%A1%A8%E6%A0%BC%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h1 id="表格布局"><a href="#表格布局" class="headerlink" title="表格布局"></a>表格布局</h1><h3 id="表格格式化"><a href="#表格格式化" class="headerlink" title="表格格式化"></a>表格格式化</h3>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>未完成（鸽）</tag>
      </tags>
  </entry>
  <entry>
    <title>js数据结构：队列</title>
    <url>/2022/08/30/%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列是一种先进先出的数据结构</p>
<p>用JavaScript实现队列的下列功能：</p>
<p><code>enqueue</code>:入队</p>
<p><code>dequeue</code>:出队</p>
<p><code>peek</code>:返回队首元素</p>
<p><code>isEmpty</code>:判断队列是否为空</p>
<p><code>size</code>:返回队列长度</p>
<p><code>toString</code>:队列字符串化</p>
<p><code>clear</code>:清空队列</p>
<p>代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span>=<span class="number">0</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">lowestCount</span>=<span class="number">0</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span>=&#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">enqueue</span>(<span class="params">element</span>) &#123;<span class="comment">//入队</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">count</span>]=element;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span>++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">dequeue</span>(<span class="params"></span>) &#123;<span class="comment">//出队</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> result=<span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">lowestCount</span>];</span><br><span class="line">    <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">lowestCount</span>];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">lowestCount</span>++;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;<span class="comment">//是否为空</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">count</span>===<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">peek</span>(<span class="params"></span>) &#123;<span class="comment">//返回队首元素</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">lowestCount</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">size</span>(<span class="params"></span>) &#123;<span class="comment">//返回队列长度</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">count</span>-<span class="variable language_">this</span>.<span class="property">lowestCount</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">clear</span>(<span class="params"></span>) &#123;<span class="comment">//清空队列</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span>=&#123;&#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span>=<span class="number">0</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">lowestCount</span>=<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;<span class="comment">//转换成字符串</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> objString=<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.items[<span class="variable language_">this</span>.lowestCount]&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="variable language_">this</span>.<span class="property">lowestCount</span>+<span class="number">1</span>;i &lt; <span class="variable language_">this</span>.<span class="property">count</span>;i++) &#123;</span><br><span class="line">      objString=<span class="string">`<span class="subst">$&#123;objString&#125;</span>,<span class="subst">$&#123;<span class="variable language_">this</span>.items[i]&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> objString;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用队列的例子：击鼓传花</p>
<p>传入一个成员数组，和一个数字，在传到指定数字时淘汰对应的成员</p>
<p>思路：创建一个队列，每传一次就将队首元素出队并从队尾入队，这样使得拿着花圈的成员永远对应队首元素。到达指定次数之后，将队首元素出队，不再添加至队尾，添加至淘汰者名单中。当队列中只有一个元素时，结束循环，得到胜者</p>
<p>代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hotPotato</span>(<span class="params">elementsList,num</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> queue=<span class="keyword">new</span> <span class="title class_">Queue</span>();</span><br><span class="line">  <span class="keyword">let</span> out=[];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> elementsList) &#123;</span><br><span class="line">    queue.<span class="title function_">enqueue</span>(elementsList[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(queue.<span class="title function_">size</span>()&gt;<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;num;i++) &#123;</span><br><span class="line">      queue.<span class="title function_">enqueue</span>(queue.<span class="title function_">dequeue</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;queue.peek()&#125;</span>被淘汰了！`</span>)</span><br><span class="line">    out.<span class="title function_">push</span>(queue.<span class="title function_">dequeue</span>())</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">winner</span>: queue.<span class="title function_">dequeue</span>(),</span><br><span class="line">    <span class="attr">outList</span>: out</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h3><p>双端队列与队列的区别是双端队列可以任意在队首或队尾增加，删除元素</p>
<p>用JavaScript实现队列的下列功能：</p>
<p><code>addFront</code>:从队首添加元素</p>
<p><code>addBack</code>:从队尾添加元素（与队列中的enqueue类似）</p>
<p><code>removeFront</code>:从队首删除元素（与队列中dequeue类似）</p>
<p><code>removeBack</code>:从队尾删除元素（与栈中pop类似）</p>
<p><code>peekFront</code>:返回队首元素</p>
<p><code>peekBack</code>:返回队尾元素</p>
<p><code>isEmpty</code>:判断队列是否为空</p>
<p><code>size</code>:返回队列长度</p>
<p><code>clear</code>:清空队列</p>
<p><code>toString</code>:队列字符串化</p>
<p>代码实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Deque</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span>=<span class="number">0</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">lowestCount</span>=<span class="number">0</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span>=&#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">addBack</span>(<span class="params">element</span>) &#123;<span class="comment">//后端入队</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">count</span>]=element;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span>++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">addFront</span>(<span class="params">element</span>) &#123;<span class="comment">//前端入队</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">addBack</span>(element);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">lowestCount</span>&gt;<span class="number">0</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">lowestCount</span>--;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">lowestCount</span>]=element;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="variable language_">this</span>.<span class="property">count</span>;i&gt;<span class="number">0</span>;i--) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">items</span>[i]=<span class="variable language_">this</span>.<span class="property">items</span>[i-<span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">count</span>++;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">lowestCount</span>=<span class="number">0</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">items</span>[<span class="number">0</span>]=element;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">removeFront</span>(<span class="params"></span>) &#123;<span class="comment">//前端出队</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> result=<span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">lowestCount</span>];</span><br><span class="line">    <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">lowestCount</span>];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">lowestCount</span>++;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">removeBack</span>(<span class="params"></span>) &#123;<span class="comment">//后端出队</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> result=<span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">count</span>-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">count</span>-<span class="number">1</span>];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span>--;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;<span class="comment">//是否为空</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">count</span>===<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">peekFront</span>(<span class="params"></span>) &#123;<span class="comment">//返回队首元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">lowestCount</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">peekBack</span>(<span class="params"></span>) &#123;<span class="comment">//返回队尾元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">count</span>-<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">count</span>-<span class="variable language_">this</span>.<span class="property">lowestCount</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">clear</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span>=&#123;&#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span>=<span class="number">0</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">lowestCount</span>=<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> objString=<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.items[<span class="variable language_">this</span>.lowestCount]&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="variable language_">this</span>.<span class="property">lowestCount</span>+<span class="number">1</span>;i &lt; <span class="variable language_">this</span>.<span class="property">count</span>;i++) &#123;</span><br><span class="line">      objString=<span class="string">`<span class="subst">$&#123;objString&#125;</span>,<span class="subst">$&#123;<span class="variable language_">this</span>.items[i]&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> objString;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用双端队列的例子：检测回文串</p>
<p>回文串就是从前向后和从后向前读起来一样的字符串</p>
<p>思路：首先检测是否传入以及将字符串字母大写转为小写，然后创建双端队列，不断将队首队尾元素出队比较直至双端队列长度小于等于1即可</p>
<p>代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">palindromeChecker</span>(<span class="params">aString</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (aString === <span class="literal">undefined</span> || aString === <span class="literal">null</span> ||</span><br><span class="line">      (aString !== <span class="literal">null</span> &amp;&amp; aString.<span class="property">length</span> === <span class="number">0</span>)) &#123; <span class="comment">// 先判断是否传入字符串</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> deque = <span class="keyword">new</span> <span class="title class_">Deque</span>(); <span class="comment">// 创建一个双端对列</span></span><br><span class="line">  <span class="keyword">const</span> lowerString = aString.<span class="title function_">toLocaleLowerCase</span>().<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>).<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>); <span class="comment">// 将大写全部转换成小写</span></span><br><span class="line">  <span class="keyword">let</span> isEqual = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">let</span> firstChar, lastChar;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; lowerString.<span class="property">length</span>; i++) &#123; <span class="comment">// 向队列中添加字母</span></span><br><span class="line">    deque.<span class="title function_">addBack</span>(lowerString.<span class="title function_">charAt</span>(i));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (deque.<span class="title function_">size</span>() &gt; <span class="number">1</span> &amp;&amp; isEqual) &#123; <span class="comment">// 随时跳出</span></span><br><span class="line">    firstChar = deque.<span class="title function_">removeFront</span>(); <span class="comment">// 首字母</span></span><br><span class="line">    lastChar = deque.<span class="title function_">removeBack</span>(); <span class="comment">// 末尾字母</span></span><br><span class="line">    <span class="keyword">if</span> (firstChar !== lastChar) &#123;</span><br><span class="line">      isEqual = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> isEqual;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>数据结构</tag>
        <tag>队列</tag>
      </tags>
  </entry>
</search>
