<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>css中的float</title>
    <url>/2022/10/12/CSS%E6%B5%AE%E5%8A%A8/</url>
    <content><![CDATA[<h1 id="CSS浮动"><a href="#CSS浮动" class="headerlink" title="CSS浮动"></a>CSS浮动</h1><h3 id="浮动规则"><a href="#浮动规则" class="headerlink" title="浮动规则"></a>浮动规则</h3><p>1.浮动元素不会超过容纳块的边界</p>
<p>2.排队浮动</p>
<p>3.浮动元素间不会重叠</p>
<p>4.浮动元素的顶边不能比父级元素的内顶边高</p>
<p>5.浮动元素的顶边不能比之前任何一个浮动元素或块元素的顶边高</p>
<p>6.浮动元素顶边不能高于源码中出现浮动元素之前的元素生成的框体所在行框的顶边</p>
<p>7.浮动元素必须放在尽可能高的位置</p>
<p>8.左浮动元素尽量向左移动，右浮动元素尽量向右移动</p>
<p>浮动元素的后代也会浮动</p>
<h3 id="浮动元素与内容重叠"><a href="#浮动元素与内容重叠" class="headerlink" title="浮动元素与内容重叠"></a>浮动元素与内容重叠</h3><p>与行内元素重叠时：行内元素边框背景内容都会在浮动元素”之上“渲染</p>
<p>与块元素重叠时：边框和背景在浮动元素”背后“渲染，内容在”之上“渲染</p>
<p>重叠方式与元素出现顺序无关</p>
<h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><p>禁止每个区域的第一个元素出现在浮动元素旁</p>
<p>如：禁止元素出现在左浮动元素的右侧：<code>clear：left</code></p>
<p>确保某个元素不与任何浮动元素共处一行：<code>clear both</code></p>
<p>实现方式：<strong>间距</strong></p>
<p><strong>间距</strong>：为了把元素向下移动，确保显示在浮动元素下方而在元素上外边距<strong>上方额外增加的空白</strong>，不影响上外边距</p>
<p>为确保清除浮动了的元素与浮动元素间的边距，可以为浮动元素设置下外边距</p>
<h3 id="形状浮动"><a href="#形状浮动" class="headerlink" title="形状浮动"></a>形状浮动</h3><p>可以让文字按照浮动<strong>透明</strong>图片的轮廓填充在旁边</p>
<p>先为浮动图片定义一个形状：</p>
<p><code>shape-outside:url(&quot;绝对路径&quot;);</code></p>
<p>若图片向左浮动则会填充在右边，若为向右浮动则填充左边</p>
<p><strong>必须是透明图片！！！！</strong></p>
<p>shape-outside还可以直接使用设置其他形状,分为basic-shape和shape-box两类</p>
<p>basic-shape:</p>
<p><code>inset() circle() ellipse() polygon()</code></p>
<p>shape-box:</p>
<p><code>margin-box border-box padding-box content-box</code>指形状最外边的界限</p>
<p>默认使用外边距框</p>
<p>如果设置的形状超过了浮动框，则不会按形状填充而是按浮动框进行填充</p>
<p>可以使用shape-margin为形状设置”外边距“</p>
<p>但设置时要注意设置之后有没有超过浮动框，有时候浮动框要设置的更大才能体现出效果</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>浮动是css的基础，虽然简单，但十分强大和有用。浮动不可或缺，有了浮动才能把内容放在某一边，让其他内容围绕它流动。引入浮动形状后，浮动框不再局限为方形</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>canvas绘图</title>
    <url>/2022/10/12/Canvas/</url>
    <content><![CDATA[<h3 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h3><p>​	<code>canvas</code>API提供了一种通过JavaScript和HTML来绘制图形的方式</p>
<p>​	<code>canvas</code>API主要聚焦于2D表现</p>
<h4 id="canvas初体验"><a href="#canvas初体验" class="headerlink" title="canvas初体验"></a><code>canvas</code>初体验</h4><p>让我们先体验一下canvas吧</p>
<p>首先，我们需要在HTML中写一个<code>canvas</code>标签</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;canvas&quot;</span> <span class="attr">width</span>=<span class="string">&quot;150&quot;</span> <span class="attr">height</span>=<span class="string">&quot;150&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>canvas</code>标签会忽略标签内的内容，但如果浏览器不支持的话就会显示其中的内容</p>
<p>因此可以这样写来判断浏览器兼容性(目前大部分浏览器都兼容canvas了)</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;canvas&quot;</span> <span class="attr">width</span>=<span class="string">&quot;150&quot;</span> <span class="attr">height</span>=<span class="string">&quot;150&quot;</span>&gt;</span>你的浏览器不支持canvas<span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>canvas</code>标签有两个属性：<code>width</code>和<code>height</code>,它们的单位都是px</p>
<p>现在我们就声明好了一个画布，现在让我们在JavaScript中操作它吧</p>
<ul>
<li><p>在JavaScript中选中画布</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> canvas=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;canvas&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>但我们并不能直接操作canvas对象，因为canvas的操作是定义在画布的“上下文”中的，让我们选中它的上下文</p>
<ul>
<li><p>选中上下文</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ctx=canvas.<span class="title function_">getContext</span>(<span class="string">&quot;2d&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>通过<code>canvas</code>对象的<code>getContext</code>方法选中上下文，<code>canvas</code>API是聚焦于2d效果的，需要传入<code>2d</code></p>
<ul>
<li><p>画一个矩形</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ctx.<span class="property">fillStyle</span>=<span class="string">&quot;rgb(200,0,0)&quot;</span>;</span><br><span class="line">ctx.<span class="title function_">fillRect</span>(<span class="number">10</span>,<span class="number">10</span>,<span class="number">55</span>,<span class="number">50</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>获取上下文之后我们就可以开始画图了。<code>fillStyle</code>可以设置填充风格，可以设置一个颜色值，这里的颜色值可以为rgb，rgba等等。<code>fillRect</code>的意思是填充一个矩形，它接收四个参数，前两个参数构成的坐标代表矩形左上角的位置，后两个参数构成的坐标代表矩形右下角的位置</p>
<p>我们利用canvas完成了一个矩形的绘制！下面我们还会介绍更多基本用法</p>
<h4 id="canvas基本操作"><a href="#canvas基本操作" class="headerlink" title="canvas基本操作"></a><code>canvas</code>基本操作</h4><p>上面我们体验了通过canvas绘制一个矩形，现在我们介绍更多常用操作</p>
<ul>
<li><p>绘制矩形边框</p>
<p>上面我们使用的<code>fillRect</code>意识是填充一个矩形，但我们还可以只勾勒它的边框，将<code>fillRect</code>替换为<code>strokeRect</code>即可</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ctx.<span class="title function_">strokeRect</span>(<span class="number">25</span>,<span class="number">25</span>,<span class="number">30</span>,<span class="number">30</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>清空矩形区域</p>
<p>目前我们还只能绘制，不能清除。</p>
<p>清除一个矩形区域的方法是<code>clearRect</code>，它的用法和<code>fillRect,strokeRect</code>相同</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ctx.<span class="title function_">clearRect</span>(<span class="number">25</span>,<span class="number">25</span>,<span class="number">10</span>,<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过路径绘制</p>
<p>只能绘制一个矩形未免太单调了，事实上，我们可以通过路径绘制任意图形</p>
<p>要启用路径绘制，我们需要使用<code>beginPath</code>方法</p>
<p>然后我们需要将我们的画笔移到一个位置开始绘画，使用<code>moveTo</code>方法。它接收两个参数构成一个坐标代表位置</p>
<p>现在开始绘画，使用<code>lineTo</code>方法，它也接收两个参数构成位置坐标，该坐标会与上一个坐标（来自<code>lineTo</code>或者<code>moveTo</code>）连起来；</p>
<p>当你绘制了足够你想要连接的坐标后，使用<code>fill</code>或<code>stroke</code>方法决定是要绘制填充还是边框</p>
<p>如果你还需要继续绘制新的路径，别忘了关闭当前路径，使用<code>closePath</code>方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ctx.<span class="title function_">beginPath</span>();</span><br><span class="line">ctx.<span class="title function_">moveTo</span>(<span class="number">50</span>,<span class="number">50</span>);</span><br><span class="line">ctx.<span class="title function_">lineTo</span>(<span class="number">75</span>,<span class="number">75</span>);</span><br><span class="line">ctx.<span class="title function_">lineTo</span>(<span class="number">100</span>,<span class="number">25</span>);</span><br><span class="line">ctx.<span class="title function_">fill</span>();</span><br><span class="line">ctx.<span class="title function_">closePath</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p>绘制圆</p>
<p>使用<code>lineTo</code>确实能够绘制自定义图案了，但图案还是只由直线构成。事实上在canvas也提供了绘制曲线的方法，如圆，贝塞尔曲线等，这里介绍圆的绘制</p>
<p>使用<code>arc</code>方法绘制圆，<code>arc</code>接收6个参数，分别为：圆心的x坐标，圆心的y坐标，半径，起始弧度，终止弧度，是否为顺时针（可以不传，默认false）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ctx.<span class="title function_">beginPath</span>();</span><br><span class="line">ctx.<span class="title function_">arc</span>(<span class="number">30</span>,<span class="number">30</span>,<span class="number">10</span>,<span class="number">0</span>,<span class="number">2</span>*<span class="title class_">Math</span>.<span class="property">PI</span>,<span class="literal">false</span>);</span><br><span class="line">ctx.<span class="title function_">closePath</span>();</span><br><span class="line">ctx.<span class="title function_">stroke</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用Path2D对象</p>
<p>除了直接在使用<code>ctx</code>绘制外，还可以使用<code>Path2D</code>对象先设置好样式再在<code>ctx</code>上直接实现</p>
<p>下面是一个使用例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> round=<span class="keyword">new</span> <span class="title class_">Path2D</span>();</span><br><span class="line">round.<span class="title function_">arc</span>(<span class="number">100</span>,<span class="number">100</span>,<span class="number">20</span>,<span class="number">0</span>,<span class="number">2</span>*<span class="title class_">Math</span>.<span class="property">PI</span>,<span class="literal">false</span>);</span><br><span class="line">ctx.<span class="title function_">stroke</span>(round);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="canvas样式"><a href="#canvas样式" class="headerlink" title="canvas样式"></a><code>canvas</code>样式</h4><p>上面我们学习了<code>canvas</code>绘制的基本操作，下面我们来学习给绘制好的图形添加样式</p>
<ul>
<li><p>添加颜色</p>
<p>添加颜色的方法在上面已经提到过，使用<code>fillStyle</code>或者<code>strokeStyle</code>即可</p>
<p>要为元素添加透明度的话，使用rgba即可</p>
</li>
<li><p>处理线条</p>
<p>我们可以对绘制出的线条进行处理</p>
<ul>
<li><p>设置线条宽度</p>
<p>使用<code>lineWidth</code>属性</p>
</li>
<li><p>设置线条末端样式</p>
<p>使用<code>lineCap</code>属性，它的值可以是<code>butt</code>,<code>round</code>,<code>square</code>，默认为<code>butt</code>,<code>round</code>是在线条末端绘制一个半圆，<code>square</code>是在线条末端绘制半个方块</p>
</li>
<li><p>设置线条转折处样式</p>
<p>使用<code>lineJoin</code>属性，它的值可以是<code>milter</code>,<code>round</code>,<code>bevel</code>,默认为<code>milter</code>，两条线末端会延长直至形成一个尖角，<code>round</code>就是在连接处用一段元素柔和连接，<code>bevel</code>是直接把连接处磨平</p>
</li>
<li><p>设置<code>milterLimit</code></p>
<p>这个属性主要用于<code>lineJoin</code>设置成<code>milter</code>时的情况，试想一下，当线条夹角很小时，连接处的尖角就会延长特别多，而<code>milterLimit</code>就是设置一个限制，超出限制的尖角会被磨平，形成类似<code>bevel</code>的效果</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线条</span></span><br><span class="line">ctx2.<span class="title function_">beginPath</span>();</span><br><span class="line">ctx2.<span class="property">lineWidth</span>=<span class="number">10</span>;<span class="comment">//设置线条宽度</span></span><br><span class="line">ctx2.<span class="property">lineCap</span>=<span class="string">&quot;round&quot;</span><span class="comment">//设置线条末端</span></span><br><span class="line">ctx2.<span class="property">lineJoin</span>=<span class="string">&quot;round&quot;</span><span class="comment">//设置线条转折处的连接</span></span><br><span class="line">ctx2.<span class="title function_">moveTo</span>(<span class="number">30</span>,<span class="number">30</span>);</span><br><span class="line">ctx2.<span class="title function_">lineTo</span>(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">ctx2.<span class="title function_">lineTo</span>(<span class="number">120</span>,<span class="number">70</span>);</span><br><span class="line">ctx2.<span class="title function_">stroke</span>();</span><br><span class="line"></span><br><span class="line">ctx3.<span class="title function_">beginPath</span>();</span><br><span class="line">ctx3.<span class="property">lineWidth</span>=<span class="number">10</span>;</span><br><span class="line">ctx3.<span class="property">miterLimit</span>=<span class="number">2</span>;<span class="comment">//控制拐点处的延申</span></span><br><span class="line">ctx3.<span class="title function_">moveTo</span>(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">ctx3.<span class="title function_">lineTo</span>(<span class="number">110</span>,<span class="number">50</span>);</span><br><span class="line">ctx3.<span class="title function_">lineTo</span>(<span class="number">120</span>,<span class="number">150</span>);</span><br><span class="line">ctx3.<span class="title function_">stroke</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>设置渐变</p>
<p>除了设置一个不变的颜色，canvas还提供了线性渐变和径向渐变</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> radial1=ctx5.<span class="title function_">createRadialGradient</span>(<span class="number">20</span>,<span class="number">20</span>,<span class="number">10</span>,<span class="number">20</span>,<span class="number">20</span>,<span class="number">40</span>);</span><br><span class="line">radial1.<span class="title function_">addColorStop</span>(<span class="number">0</span>,<span class="string">&quot;rgb(0,0,255)&quot;</span>);</span><br><span class="line">radial1.<span class="title function_">addColorStop</span>(<span class="number">0.9</span>,<span class="string">&quot;rgb(255,0,0)&quot;</span>);</span><br><span class="line">radial1.<span class="title function_">addColorStop</span>(<span class="number">1</span>,<span class="string">&quot;rgba(255,0,0,0)&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> radial2=ctx5.<span class="title function_">createRadialGradient</span>(<span class="number">100</span>,<span class="number">100</span>,<span class="number">10</span>,<span class="number">100</span>,<span class="number">100</span>,<span class="number">40</span>);</span><br><span class="line">radial2.<span class="title function_">addColorStop</span>(<span class="number">0</span>,<span class="string">&quot;rgb(0,255,255)&quot;</span>);</span><br><span class="line">radial2.<span class="title function_">addColorStop</span>(<span class="number">0.9</span>,<span class="string">&quot;rgb(255,255,0)&quot;</span>);</span><br><span class="line">radial2.<span class="title function_">addColorStop</span>(<span class="number">1</span>,<span class="string">&quot;rgba(255,255,0,0)&quot;</span>);</span><br><span class="line">ctx5.<span class="property">fillStyle</span>=radial1;<span class="comment">//将渐变设置为填充模式</span></span><br><span class="line">ctx5.<span class="title function_">fillRect</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">200</span>,<span class="number">200</span>);<span class="comment">//填充一个矩形</span></span><br><span class="line">ctx5.<span class="property">fillStyle</span>=radial2;</span><br><span class="line">ctx5.<span class="title function_">fillRect</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">200</span>,<span class="number">200</span>);</span><br></pre></td></tr></table></figure>

<p><code>createRadialGradient</code>：创建一个径向渐变，接收6个参数，分别为圆心1横坐标，圆心1纵坐标，圆1半径，圆心2横坐标，圆心2纵坐标，圆2半径。圆1和圆2之间的部分就是径向渐变范围</p>
<p><code>addColorStop</code>:接收两个参数，位置和颜色，位置范围是从0到1，用比例表示位置</p>
<p>线性渐变类似</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> linear=ctx4.<span class="title function_">createLinearGradient</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">200</span>,<span class="number">200</span>);<span class="comment">//设置线性渐变方向</span></span><br><span class="line">linear.<span class="title function_">addColorStop</span>(<span class="number">0</span>,<span class="string">&quot;rgb(0,0,255)&quot;</span>);<span class="comment">//在起始处设置颜色</span></span><br><span class="line">linear.<span class="title function_">addColorStop</span>(<span class="number">1</span>,<span class="string">&quot;rgb(255,0,0)&quot;</span>);<span class="comment">//在结束处设置颜色</span></span><br><span class="line">ctx4.<span class="property">fillStyle</span>=linear;<span class="comment">//将渐变设置为填充模式</span></span><br><span class="line">ctx4.<span class="title function_">fillRect</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">200</span>,<span class="number">200</span>);<span class="comment">//填充一个矩形</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>设置阴影</p>
<p>与css类似，需要设置偏移量，颜色，模糊</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ctx6.<span class="property">shadowOffsetX</span>=<span class="number">10</span>;</span><br><span class="line">ctx6.<span class="property">shadowOffsetY</span>=<span class="number">10</span>;</span><br><span class="line">ctx6.<span class="property">shadowBlur</span>=<span class="number">10</span>;</span><br><span class="line">ctx6.<span class="property">shadowColor</span>=<span class="string">&quot;rgba(0,0,255,0.5)&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="canvas使用图片"><a href="#canvas使用图片" class="headerlink" title="canvas使用图片"></a><code>canvas</code>使用图片</h4><p>使用<code>new Image()</code>创建图片对象，调用<code>src</code>属性设置图片路径</p>
<p><code>drawImage</code>方法接收5个参数，分别为图片对象，图片绘制的横坐标，图片绘制的纵坐标，图片的横向缩放，图片的纵向缩放</p>
<h4 id="canvas动画"><a href="#canvas动画" class="headerlink" title="canvas动画"></a><code>canvas</code>动画</h4><p>使用<code>requestAnimationFrame</code>申请动画帧，它接收一个回调函数，浏览器以大约60帧的频率执行</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>js进阶</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>js进阶</tag>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker入门</title>
    <url>/2022/10/15/Docker/</url>
    <content><![CDATA[<h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><h4 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</span><br></pre></td></tr></table></figure>

<h4 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -it --<span class="built_in">rm</span> ubuntu:18.04 bash</span></span><br></pre></td></tr></table></figure>

<h4 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker image <span class="built_in">ls</span></span></span><br></pre></td></tr></table></figure>

<h4 id="查看镜像所占空间"><a href="#查看镜像所占空间" class="headerlink" title="查看镜像所占空间"></a>查看镜像所占空间</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker system <span class="built_in">df</span></span></span><br></pre></td></tr></table></figure>

<h4 id="显示包含中间层镜像在内的所有镜像"><a href="#显示包含中间层镜像在内的所有镜像" class="headerlink" title="显示包含中间层镜像在内的所有镜像"></a>显示包含中间层镜像在内的所有镜像</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker image <span class="built_in">ls</span> -a</span></span><br></pre></td></tr></table></figure>

<h4 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker image <span class="built_in">rm</span> &lt;name&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker build -t &lt;name&gt; &lt;ctx&gt;</span></span><br></pre></td></tr></table></figure>





<h4 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run</span></span><br></pre></td></tr></table></figure>

<h4 id="守护态运行"><a href="#守护态运行" class="headerlink" title="守护态运行"></a>守护态运行</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -d</span></span><br></pre></td></tr></table></figure>

<h4 id="查看容器列表"><a href="#查看容器列表" class="headerlink" title="查看容器列表"></a>查看容器列表</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker container <span class="built_in">ls</span></span></span><br></pre></td></tr></table></figure>

<h4 id="获取守护态容器输出信息"><a href="#获取守护态容器输出信息" class="headerlink" title="获取守护态容器输出信息"></a>获取守护态容器输出信息</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker logs &lt;contatinerID or Name&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="查看所有容器"><a href="#查看所有容器" class="headerlink" title="查看所有容器"></a>查看所有容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker container <span class="built_in">ls</span> -a</span></span><br></pre></td></tr></table></figure>

<h4 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker <span class="built_in">exec</span> -it 69d1 bash</span></span><br></pre></td></tr></table></figure>

<h4 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker <span class="built_in">export</span> &lt;<span class="built_in">id</span>&gt; &gt; &lt;filename&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="导入容器快照"><a href="#导入容器快照" class="headerlink" title="导入容器快照"></a>导入容器快照</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker import &lt;url&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker container <span class="built_in">rm</span>  -f &lt;<span class="built_in">id</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="删除所有容器"><a href="#删除所有容器" class="headerlink" title="删除所有容器"></a>删除所有容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker container prune</span></span><br></pre></td></tr></table></figure>



<h4 id="Dockerfile-指令"><a href="#Dockerfile-指令" class="headerlink" title="Dockerfile 指令"></a>Dockerfile 指令</h4><h4 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h4><p>在<code>docker build</code>时运行</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> &lt;COMMAND&gt;</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> [<span class="string">&quot;可执行文件&quot;</span>, <span class="string">&quot;参数1&quot;</span>, <span class="string">&quot;参数2&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<h4 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h4><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> [--<span class="built_in">chown</span>=&lt;user&gt;:&lt;group&gt;] &lt;源路径&gt;... &lt;目标路径&gt;</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> [--<span class="built_in">chown</span>=&lt;user&gt;:&lt;group&gt;] [<span class="string">&quot;&lt;源路径1&gt;&quot;</span>,... <span class="string">&quot;&lt;目标路径&gt;&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>如果源路径为文件夹，复制的时候不是直接复制该文件夹，而是将文件夹中的内容复制到目标路径。</p>
<h4 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h4><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ADD</span><span class="language-bash"> [--<span class="built_in">chown</span>=&lt;user&gt;:&lt;group&gt;] &lt;源路径&gt;... &lt;目标路径&gt;</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> [--<span class="built_in">chown</span>=&lt;user&gt;:&lt;group&gt;] [<span class="string">&quot;&lt;源路径1&gt;&quot;</span>,... <span class="string">&quot;&lt;目标路径&gt;&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>ADD可以使用URL作为路径，对压缩包文件会自动解压缩</p>
<h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h4><p>CMD命令指定了容器启动时执行的命令</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="language-bash"> &lt;命令&gt;</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;可执行文件&quot;</span>,<span class="string">&quot;参数1&quot;</span>,<span class="string">&quot;参数2&quot;</span>...]</span></span><br></pre></td></tr></table></figure>

<h4 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h4><p>同样是在容器启动时执行的命令</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;&lt;executeable&gt;&quot;</span>,<span class="string">&quot;&lt;param1&gt;&quot;</span>,<span class="string">&quot;&lt;param2&gt;&quot;</span>,...]</span></span><br></pre></td></tr></table></figure>

<h4 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h4><p>设置环境变量，可以在后续指令中引用</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENV</span> NODE_VERSION <span class="number">7.2</span>.<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> curl -SLO <span class="string">&quot;https://nodejs.org/dist/v<span class="variable">$NODE_VERSION</span>/node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz&quot;</span> \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; curl -SLO <span class="string">&quot;https://nodejs.org/dist/v<span class="variable">$NODE_VERSION</span>/SHASUMS256.txt.asc&quot;</span></span></span><br></pre></td></tr></table></figure>

<h4 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h4><p>与ENV作用一致但设置的参数只能在<code>docker build</code>中使用</p>
<h4 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h4><p>定义匿名数据卷</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"> [<span class="string">&quot;&lt;路径1&gt;&quot;</span>, <span class="string">&quot;&lt;路径2&gt;&quot;</span>...]</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"> &lt;路径&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h4><p>声明端口</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPOSE</span> &lt;端口<span class="number">1</span>&gt; [&lt;端口<span class="number">2</span>&gt;...]</span><br></pre></td></tr></table></figure>

<h4 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h4><p>指定工作目录（必须提前创建好）</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> &lt;工作目录路径&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h4><p>切换后续命令执行的用户</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">USER</span> &lt;用户名&gt;[:&lt;用户组&gt;]</span><br></pre></td></tr></table></figure>

<h4 id="HEALTHCHECK"><a href="#HEALTHCHECK" class="headerlink" title="HEALTHCHECK"></a>HEALTHCHECK</h4><p>指定运行状态</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">HEALTHCHECK</span><span class="language-bash"> [选项] CMD &lt;命令&gt;：设置检查容器健康状况的命令</span></span><br><span class="line"><span class="keyword">HEALTHCHECK</span><span class="language-bash"> NONE：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令</span></span><br></pre></td></tr></table></figure>

<h4 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h4><p>延迟构建指令（第一次构建不会执行的指令，但之后再以此构建新的镜像会执行）</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ONBUILD</span> &lt;其它指令&gt;</span><br></pre></td></tr></table></figure>

<h4 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h4><p>LABEL 指令用来给镜像添加一些元数据（metadata），以键值对的形式</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Echarts</title>
    <url>/2022/10/12/Echarts%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<h2 id="Echarts使用手册"><a href="#Echarts使用手册" class="headerlink" title="Echarts使用手册"></a>Echarts使用手册</h2><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;https://cdn.jsdelivr.net/npm/echarts@5.3.3/dist/echarts.min.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="设置容器"><a href="#设置容器" class="headerlink" title="设置容器"></a>设置容器</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;chart&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height: 300px;width: 100vw&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>容器必须指定一个大小（宽高）</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> chart=echarts.<span class="title function_">init</span>(<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.chart&quot;</span>));</span><br></pre></td></tr></table></figure>

<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">chart.<span class="title function_">setOption</span>(&#123;</span><br><span class="line">  <span class="attr">title</span>: &#123;</span><br><span class="line">    <span class="attr">text</span>: <span class="string">&#x27;ECharts 入门示例&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">tooltip</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">xAxis</span>: &#123;</span><br><span class="line">    <span class="attr">data</span>: [<span class="string">&#x27;衬衫&#x27;</span>, <span class="string">&#x27;羊毛衫&#x27;</span>, <span class="string">&#x27;雪纺衫&#x27;</span>, <span class="string">&#x27;裤子&#x27;</span>, <span class="string">&#x27;高跟鞋&#x27;</span>, <span class="string">&#x27;袜子&#x27;</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">yAxis</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">series</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;销量&#x27;</span>,</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">      <span class="attr">data</span>: [<span class="number">5</span>, <span class="number">20</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">20</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="图表容器及大小"><a href="#图表容器及大小" class="headerlink" title="图表容器及大小"></a>图表容器及大小</h4><ul>
<li><p>HTML中定义大小</p>
</li>
<li><p>为图表指定大小</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> chart=echarts.<span class="title function_">init</span>(<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.chart&quot;</span>),<span class="literal">null</span>,&#123;</span><br><span class="line">  <span class="attr">width</span>:<span class="number">300</span>,</span><br><span class="line">  <span class="attr">height</span>:<span class="number">200</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置响应式大小</p>
<p>可以监听页面的<code>onresize</code>事件然后调用图表的<code>resize</code>方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onresize</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    myChart.<span class="title function_">resize</span>();</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p><code>resize</code>方法也可传入对象表示在页面发生变化后变化的宽高</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onresize</span>=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  chart.<span class="title function_">resize</span>(&#123;</span><br><span class="line">    <span class="attr">width</span>:<span class="number">700</span>,</span><br><span class="line">    <span class="attr">height</span>:<span class="number">400</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>​	</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>Echarts</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP知识点总结</title>
    <url>/2022/10/12/HTTP/</url>
    <content><![CDATA[<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><hr>
<h2 id="第一章：了解web及网络基础"><a href="#第一章：了解web及网络基础" class="headerlink" title="第一章：了解web及网络基础"></a>第一章：了解web及网络基础</h2><h3 id="1-1-TCP-x2F-IP"><a href="#1-1-TCP-x2F-IP" class="headerlink" title="1.1 TCP&#x2F;IP"></a>1.1 TCP&#x2F;IP</h3><p>不同硬件，操作系统之间的通信都需要规则，这种规则成为<strong>协议</strong>。</p>
<p>把与互联网相关联的协议集合称为TCP&#x2F;IP</p>
<h3 id="1-2-TCP-x2F-IP分层管理"><a href="#1-2-TCP-x2F-IP分层管理" class="headerlink" title="1.2 TCP&#x2F;IP分层管理"></a>1.2 TCP&#x2F;IP分层管理</h3><p>TCP&#x2F;IP协议族分为四层：</p>
<ul>
<li>应用层：决定了向用户提供应用服务时通信的活动，如FTP,DNS,HTTP</li>
<li>传输层：提供处于网络连接中的两台计算机之间的数据传输，如TCP,UDP</li>
<li>网络层：用来处理在网络上流动的数据包</li>
<li>链路层：处理连接网络的硬件部分</li>
</ul>
<h3 id="1-3-IP-TCP-DNS"><a href="#1-3-IP-TCP-DNS" class="headerlink" title="1.3 IP,TCP,DNS"></a>1.3 IP,TCP,DNS</h3><h4 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h4><p>IP网络协议位于网络层，作用是把各种数据包传给对方。要想确保传输需要满足各种条件，最重要的是IP地址和MAC地址</p>
<p>IP地址是节点被分配的地址，MAC地址是网卡的固定地址，IP地址可变换，MAC地址一般不可变换</p>
<h5 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h5><p>IP间的通信依赖MAC地址，数据在网络上的传递需要经过多个中转站，通过MAC来搜索中转站，ARP协议可以通过IP地址反查出MAC地址</p>
<p>没有设备能够全面掌握数据的传输情况</p>
<h4 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h4><p>位于传输层，提供可靠的字节流服务</p>
<h5 id="确保数据能到达目标"><a href="#确保数据能到达目标" class="headerlink" title="确保数据能到达目标"></a>确保数据能到达目标</h5><p>采用三次握手策略。</p>
<p>握手过程中使用了TCP的标志：SYN和ACK</p>
<p>发送端发送带有SYN标志的数据包给对方，接收端返回带有SYN&#x2F;ACK标志的数据包以示传达确认信息，最后发送端回传带有ACK标志的数据包代表握手结束</p>
<p>若握手在某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包</p>
<h4 id="DNS服务"><a href="#DNS服务" class="headerlink" title="DNS服务"></a>DNS服务</h4><p>位于应用层，提供域名到IP的解析服务</p>
<h3 id="1-4-HTTP与其他协议的关系"><a href="#1-4-HTTP与其他协议的关系" class="headerlink" title="1.4 HTTP与其他协议的关系"></a>1.4 HTTP与其他协议的关系</h3><p>HTTP生成报文-&gt;TCP将报文分割处理-&gt;IP将报文段传输-&gt;TCP将报文段重组-&gt;HTTP对接受到的报文进行处理再回传</p>
<h3 id="1-5-URL和URI"><a href="#1-5-URL和URI" class="headerlink" title="1.5 URL和URI"></a>1.5 URL和URI</h3><p>URI用字符串标识某一互联网资源，URL表示资源的地点，URL是URI的子集</p>
<hr>
<h2 id="第二章：简单的HTTP协议"><a href="#第二章：简单的HTTP协议" class="headerlink" title="第二章：简单的HTTP协议"></a>第二章：简单的HTTP协议</h2><h3 id="2-1-HTTP协议用于客户端和服务器端之间的通信"><a href="#2-1-HTTP协议用于客户端和服务器端之间的通信" class="headerlink" title="2.1 HTTP协议用于客户端和服务器端之间的通信"></a>2.1 HTTP协议用于客户端和服务器端之间的通信</h3><p>请求访问文本等资源的一端成为客户端，提供资源做出响应的一端称为服务器端</p>
<h3 id="2-2-通过请求和响应的交换达成协议"><a href="#2-2-通过请求和响应的交换达成协议" class="headerlink" title="2.2 通过请求和响应的交换达成协议"></a>2.2 通过请求和响应的交换达成协议</h3><p>服务器在没有接收到请求时是不会响应的</p>
<p>一段请求报文：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/index.htm</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>hacker.jp</span><br></pre></td></tr></table></figure>

<ul>
<li>GET表示请求服务的类型，称为<strong>方法</strong></li>
<li><code>/index.htm</code>表示了请求访问的资源对象，也叫请求URI</li>
<li><code>HTTP/1.1</code>表示HTTP的版本号</li>
</ul>
<p>请求报文是由请求方法，请求URI，协议版本，可选的请求首部字段和内容实体构成的</p>
<p>请求首部字段和内容实体之后介绍</p>
<p>一段响应报文：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>TUe, 10 Jul 2012 6:50:15 GMT</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>362</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html</span><br><span class="line"></span><br><span class="line"><span class="language-lasso">&lt;html&gt;</span></span><br><span class="line"><span class="language-lasso"><span class="params">...</span><span class="params">...</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>HTTP/1.1</code>表示服务器对应的HTTP版本</p>
</li>
<li><p><code>200 OK</code>表示状态码和原因短语</p>
</li>
<li><p><code>Date Content</code>为首部字段内的属性</p>
</li>
<li><p>以一空行分隔，之后的内容为资源实体的主体</p>
</li>
</ul>
<p>响应报文由协议版本，状态码，解释状态码的原因短语，可选的响应首部字段以及实体主体构成</p>
<h3 id="2-3-HTTP是不保存状态的协议"><a href="#2-3-HTTP是不保存状态的协议" class="headerlink" title="2.3 HTTP是不保存状态的协议"></a>2.3 HTTP是不保存状态的协议</h3><p>HTTP协议自身不具备保存之前发送过的请求或响应的功能</p>
<p>为了实现保存状态，引入了Cookie技术</p>
<h3 id="2-4-请求URI定位资源"><a href="#2-4-请求URI定位资源" class="headerlink" title="2.4 请求URI定位资源"></a>2.4 请求URI定位资源</h3><p>HTTP协议使用URI定位互联网上的资源</p>
<p>指定请求URI的方式很多</p>
<p>如果不是访问资源而是对服务器本身发送请求，URI可以使用*代替</p>
<h3 id="2-5告知服务器意图的HTTP方法"><a href="#2-5告知服务器意图的HTTP方法" class="headerlink" title="2.5告知服务器意图的HTTP方法"></a>2.5告知服务器意图的HTTP方法</h3><h4 id="GET-获取资源"><a href="#GET-获取资源" class="headerlink" title="GET:获取资源"></a>GET:获取资源</h4><p>GET方法用来请求已被URI识别的资源</p>
<h4 id="POST：传输实体主体"><a href="#POST：传输实体主体" class="headerlink" title="POST：传输实体主体"></a>POST：传输实体主体</h4><p>POST方法用来传输实体的主体，虽说GET也能传输，但一般不用GET，POST的主要目的并不是获取响应的主体内容</p>
<h4 id="PUT：传输文件"><a href="#PUT：传输文件" class="headerlink" title="PUT：传输文件"></a>PUT：传输文件</h4><p>PUT方法用来传输文件。在报文的主体中包含文件内容，保存到请求URI的指定位置</p>
<p>由于不存在验证机制，任何人都可以上传，存在安全性问题，一般网站不使用PUT</p>
<h4 id="HEAD：获取报文首部"><a href="#HEAD：获取报文首部" class="headerlink" title="HEAD：获取报文首部"></a>HEAD：获取报文首部</h4><p>HEAD与GET一样，只是不返回报文的主体部分，用于确认URI的有效性以及资源更新的日期时间等</p>
<h4 id="DELETE-删除文件"><a href="#DELETE-删除文件" class="headerlink" title="DELETE:删除文件"></a>DELETE:删除文件</h4><p>与PUT相反的方法，一般不用</p>
<h4 id="OPTIONS：查询支持的方法"><a href="#OPTIONS：查询支持的方法" class="headerlink" title="OPTIONS：查询支持的方法"></a>OPTIONS：查询支持的方法</h4><p>查询针对URI指定的资源支持的方法</p>
<h4 id="TRACE：追踪路径"><a href="#TRACE：追踪路径" class="headerlink" title="TRACE：追踪路径"></a>TRACE：追踪路径</h4><p>不常用且可能引发XST攻击，通常不会用到</p>
<h4 id="CONNECT：要求用隧道协议连接代理"><a href="#CONNECT：要求用隧道协议连接代理" class="headerlink" title="CONNECT：要求用隧道协议连接代理"></a>CONNECT：要求用隧道协议连接代理</h4><p>主要使用SSL和TLS协议把通信加密后经网络隧道传输</p>
<h3 id="2-6-持久连接"><a href="#2-6-持久连接" class="headerlink" title="2.6 持久连接"></a>2.6 持久连接</h3><p>即在建立TCP连接后，如果一端没有明确要求断开链接，则保持TCP连接状态</p>
<h3 id="2-7-管线化"><a href="#2-7-管线化" class="headerlink" title="2.7 管线化"></a>2.7 管线化</h3><p>从前发送请求需要收到响应才能发送下一个请求，通过管线化技术不用等待即可发送下一个请求</p>
<h3 id="2-8-使用Cookie的状态管理"><a href="#2-8-使用Cookie的状态管理" class="headerlink" title="2.8 使用Cookie的状态管理"></a>2.8 使用Cookie的状态管理</h3><p>Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端状态</p>
<p>如果请求中没有cookie，则会在响应报文中添加cookie</p>
<p>如果请求中有cookie，服务器端会检查cookie识别状态做出响应</p>
<hr>
<h2 id="第三章：HTTP报文内的HTTP信息"><a href="#第三章：HTTP报文内的HTTP信息" class="headerlink" title="第三章：HTTP报文内的HTTP信息"></a>第三章：HTTP报文内的HTTP信息</h2><h3 id="3-1-HTTP报文"><a href="#3-1-HTTP报文" class="headerlink" title="3.1 HTTP报文"></a>3.1 HTTP报文</h3><p>用于HTTP协议交互的信息叫做HTTP报文，请求端的HTTP报文叫请求报文，相应端的叫响应报文</p>
<p>HTTP报文大致可分为报文首部和报文主体两部分，由空行划分，通常并不一定有报文主体</p>
<h3 id="3-2-请求报文和响应报文的结构"><a href="#3-2-请求报文和响应报文的结构" class="headerlink" title="3.2 请求报文和响应报文的结构"></a>3.2 请求报文和响应报文的结构</h3><ul>
<li>报文首部<ul>
<li>请求行：包含用于请求的方法，请求URI和HTTP版本</li>
<li>状态行：包含表明响应结果的状态码，原因短语和HTTP版本</li>
<li>首部字段：包含表示请求和响应的各种条件和属性的各类首部<ul>
<li>通用首部</li>
<li>请求首部</li>
<li>响应首部</li>
<li>实体首部</li>
</ul>
</li>
<li>其他（HTTP的RFC未规定的首部，如Cookie）</li>
</ul>
</li>
<li>空行</li>
<li>报文主体</li>
</ul>
<h3 id="3-3-编码提升传输速率"><a href="#3-3-编码提升传输速率" class="headerlink" title="3.3 编码提升传输速率"></a>3.3 编码提升传输速率</h3><h4 id="报文主体和实体主体"><a href="#报文主体和实体主体" class="headerlink" title="报文主体和实体主体"></a>报文主体和实体主体</h4><p>一般来说报文主体等于实体主体，当编码后实体主体发生变化，与报文主体不同</p>
<h4 id="压缩传输的内容编码"><a href="#压缩传输的内容编码" class="headerlink" title="压缩传输的内容编码"></a>压缩传输的内容编码</h4><p>内容编码指明应用在实体内容上的编码格式，并保持实体信息原样进行压缩，编码后的实体主体由客户端接收并负责解码</p>
<h4 id="分割发送的分块传输编码"><a href="#分割发送的分块传输编码" class="headerlink" title="分割发送的分块传输编码"></a>分割发送的分块传输编码</h4><p>把数据分割成多块，能够让浏览器逐步显示页面</p>
<p>这种把实体主体分块的功能称为分块传输编码，由客户端负责解码</p>
<h3 id="3-4-发送多种数据的多部分对象集合"><a href="#3-4-发送多种数据的多部分对象集合" class="headerlink" title="3.4 发送多种数据的多部分对象集合"></a>3.4 发送多种数据的多部分对象集合</h3><p>HTTP协议采用了多部分对象集合，发送的一份报文主体内可能含有多种类型的实体</p>
<p>多部分对象集合包含的对象如下：</p>
<ul>
<li><p><code>multipart/form-data</code>：在web表单文件上传时使用</p>
</li>
<li><p><code>multipart/byteranges</code>：在状态码206响应报文包含了多个范围的内容时使用</p>
</li>
</ul>
<p>详见p48</p>
<h3 id="3-5-获取部分内容的范围请求"><a href="#3-5-获取部分内容的范围请求" class="headerlink" title="3.5 获取部分内容的范围请求"></a>3.5 获取部分内容的范围请求</h3><p>为指定范围发送的请求称为范围请求</p>
<p>针对范围请求，响应会返回状态码为<code>206 Partial Content</code>的响应报文。对于多重范围的范围请求，响应会在首部字段Content-Type标明multipart&#x2F;byteranges后返回响应报文</p>
<p>如果服务器端无法响应范围请求，则会返回状态码200 OK和完整的实体内容</p>
<h3 id="3-6-内容协商返回最合适的内容"><a href="#3-6-内容协商返回最合适的内容" class="headerlink" title="3.6 内容协商返回最合适的内容"></a>3.6 内容协商返回最合适的内容</h3><p>内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，最终提供给客户端最合适的资源。内容协商会以语言，字符集，编码方式等作为基准判断响应的资源</p>
<p>包含在请求报文中的某些首部字段就是判断标准</p>
<ul>
<li><code>Accept</code></li>
<li><code>Accept-Charset</code></li>
<li><code>Accept-Encoding</code></li>
<li><code>Accept-Language</code></li>
<li><code>Content-Language</code></li>
</ul>
<p>内容协商技术分为以下三种类型</p>
<ul>
<li>服务器驱动协商：以请求的首部字段为参考，由服务器端自动进行内容协商，未必能选择出最优内容</li>
<li>客户端驱动协商：由客户端进行内容协商。用户可从浏览器的可选列表里手动选择，还可以利用JS脚本自动选择</li>
<li>透明协商：是服务器驱动和客户端驱动的结合体，是服务器端和客户端各自进行内容协商的一种方法</li>
</ul>
<hr>
<h2 id="第四章：返回结果状态的HTTP状态码"><a href="#第四章：返回结果状态的HTTP状态码" class="headerlink" title="第四章：返回结果状态的HTTP状态码"></a>第四章：返回结果状态的HTTP状态码</h2><h3 id="4-1-状态码告知服务器端返回的请求结果"><a href="#4-1-状态码告知服务器端返回的请求结果" class="headerlink" title="4.1 状态码告知服务器端返回的请求结果"></a>4.1 状态码告知服务器端返回的请求结果</h3><p>借助状态码，用户可以知道服务器端是正常处理了请求还是出现了错误</p>
<p>响应类别有如下5种</p>
<ul>
<li>1XX<ul>
<li>信息性状态码</li>
<li>表示接收的请求正在处理</li>
</ul>
</li>
<li>2XX<ul>
<li>成功状态码</li>
<li>表示请求正常处理完毕</li>
</ul>
</li>
<li>3XX<ul>
<li>重定向状态码</li>
<li>需要进行附加操作以完成请求</li>
</ul>
</li>
<li>4XX<ul>
<li>客户端错误状态码</li>
<li>服务器无法处理请求</li>
</ul>
</li>
<li>5XX<ul>
<li>服务器错误状态码</li>
<li>服务器处理请求出错</li>
</ul>
</li>
</ul>
<p>经常使用的状态码有14种</p>
<h3 id="4-2-2XX-成功"><a href="#4-2-2XX-成功" class="headerlink" title="4.2 2XX 成功"></a>4.2 2XX 成功</h3><h4 id="200-OK"><a href="#200-OK" class="headerlink" title="200 OK"></a>200 OK</h4><p>表示从客户端发来的请求在服务器端被正常处理了</p>
<p>随状态码返回的信息会因方法不同而发生改变</p>
<h4 id="204-No-Content"><a href="#204-No-Content" class="headerlink" title="204 No Content"></a>204 No Content</h4><p>表示接收的请求已被成功处理，但返回的响应报文中不含实体的主体部分，也不允许返回任何实体的主体</p>
<p>在客户端忘服务器端发送信息，而客户端不需要更新信息内容时使用</p>
<h4 id="206-Partial-Content"><a href="#206-Partial-Content" class="headerlink" title="206 Partial Content"></a>206 Partial Content</h4><p>表示客户端进行了范围请求，服务器成功执行了这部分的GET请求。响应报文中包含有Content-Range指定范围的实体内容</p>
<h3 id="4-3-3XX-重定向"><a href="#4-3-3XX-重定向" class="headerlink" title="4.3 3XX 重定向"></a>4.3 3XX 重定向</h3><h4 id="301-Moved-Permanently"><a href="#301-Moved-Permanently" class="headerlink" title="301 Moved Permanently"></a>301 Moved Permanently</h4><p>永久性重定向。表示请求的资源已经被分配了新的URI，以后应使用资源现在所指的URI</p>
<h4 id="302-Found"><a href="#302-Found" class="headerlink" title="302 Found"></a>302 Found</h4><p>临时重定向。表示请求的资源已经被分配了新的URI，本次应使用资源现在所指的URI</p>
<h4 id="303-See-Other"><a href="#303-See-Other" class="headerlink" title="303 See Other"></a>303 See Other</h4><p>表示请求的资源存在着另一个URI，应使用GET方法定向获取请求的资源</p>
<p>与302有着相同的功能，但明确表示客户端应该使用GET方法获取资源</p>
<h4 id="304-Not-Modified"><a href="#304-Not-Modified" class="headerlink" title="304 Not Modified"></a>304 Not Modified</h4><p>表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但因发生请求未满足条件的情况后直接返回304</p>
<p>和重定向没有关系</p>
<h4 id="307-Temporary-Redirect"><a href="#307-Temporary-Redirect" class="headerlink" title="307 Temporary Redirect"></a>307 Temporary Redirect</h4><p>临时重定向，与302有相同的含义</p>
<p>302标准禁止POST变为GET，但大家并不遵守</p>
<p>307会遵照浏览器标准，不会从POST变为GET。但是对于处理响应时的行为，不同浏览器有可能出现不同情况</p>
<h3 id="4-4-4XX-客户端错误"><a href="#4-4-4XX-客户端错误" class="headerlink" title="4.4 4XX 客户端错误"></a>4.4 4XX 客户端错误</h3><h4 id="400-Bad-Request"><a href="#400-Bad-Request" class="headerlink" title="400 Bad Request"></a>400 Bad Request</h4><p>表示请求报文中有语法错误，需要修改请求内容后再次发送请求</p>
<h4 id="401-Unauthorized"><a href="#401-Unauthorized" class="headerlink" title="401 Unauthorized"></a>401 Unauthorized</h4><p>表示发送的请求需要有通过HTTP认证（BASIC认证，DIGEST认证）的认证信息。若之前已经进行过一次请求，则表示用户认证失败</p>
<p>浏览器初次接收到401响应会弹出认证用的对话窗口</p>
<h4 id="403-Forbidden"><a href="#403-Forbidden" class="headerlink" title="403 Forbidden"></a>403 Forbidden</h4><p>表示对请求资源的访问被服务器拒绝了</p>
<h4 id="404-Not-Found"><a href="#404-Not-Found" class="headerlink" title="404 Not Found"></a>404 Not Found</h4><p>表明服务器上没有请求的资源</p>
<h3 id="4-5-5XX-服务器错误"><a href="#4-5-5XX-服务器错误" class="headerlink" title="4.5 5XX 服务器错误"></a>4.5 5XX 服务器错误</h3><h4 id="500-Internet-Server-Error"><a href="#500-Internet-Server-Error" class="headerlink" title="500 Internet Server Error"></a>500 Internet Server Error</h4><p>表明服务器端在执行请求时发生了错误，也许是web应用的bug所致</p>
<h4 id="503-Server-Unavailable"><a href="#503-Server-Unavailable" class="headerlink" title="503 Server Unavailable"></a>503 Server Unavailable</h4><p>表明服务器正处于超负载或停机维护，暂时无法处理请求</p>
<hr>
<h2 id="第五章-与HTTP协作的web服务器"><a href="#第五章-与HTTP协作的web服务器" class="headerlink" title="第五章 与HTTP协作的web服务器"></a>第五章 与HTTP协作的web服务器</h2><h3 id="5-1-用单台虚拟主机实现多个域名"><a href="#5-1-用单台虚拟主机实现多个域名" class="headerlink" title="5.1 用单台虚拟主机实现多个域名"></a>5.1 用单台虚拟主机实现多个域名</h3><p>即使物理层面只有一个服务器，但使用了虚拟主机的功能，则可以假想已经具有了多台服务器</p>
<p>当两个域名被部署在一个服务器上时，使用DNS服务解析域名后会得到相同的IP地址。</p>
<p>在相同的IP地址下，由于虚拟主机可以寄存多个不同主机名和域名的web网站，因此在发送HTTP请求时，必须在HOST主部中完整指定主机名和域名的URI</p>
<h3 id="5-2-代理，网关，隧道"><a href="#5-2-代理，网关，隧道" class="headerlink" title="5.2 代理，网关，隧道"></a>5.2 代理，网关，隧道</h3><h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><p>代理服务器的基本行为就是接收客户端发送的请求后转发给其他服务器。代理不改变请求URI</p>
<p>持有资源实体的服务器称为源服务器，源服务器返回的响应经过代理服务器传回客户端</p>
<p>可级联多台代理服务器。转发时需要用Via首部字段以标记经处的主机信息</p>
<p>代理有多种使用方法，按两种基准分类</p>
<ul>
<li>缓存代理：代理转发响应时，缓存代理会预先将资源副本（缓存）保存在代理服务器上，当代理再次接收到相同资源的请求时，将缓存的资源直接返回</li>
<li>透明代理：不对报文做任何类型加工的代理类型称为透明代理，反之称为非透明代理</li>
</ul>
<h3 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h3><p>网关的工作方式与代理相似，但网关能使通信链路上的服务器提供非HTTP协议服务</p>
<p>利用网关能提高通信的安全性，因为可以在客户端和网关之间的通信链路上加密以确保连接的安全</p>
<h4 id="隧道"><a href="#隧道" class="headerlink" title="隧道"></a>隧道</h4><p>隧道可按要求建立起一条与其他服务器的通信链路，使用SSL等加密手段进行通信。隧道的目的是确保服务器和客户端能安全通信</p>
<p>隧道本身不会解析HTTP请求，请求保持原样中转给之后的服务器</p>
<h3 id="5-3-缓存"><a href="#5-3-缓存" class="headerlink" title="5.3 缓存"></a>5.3 缓存</h3><p>缓存指代理服务器或客户端本地磁盘内保存的资源副本</p>
<p>利用缓存可减少对源服务器的访问，节省了通信流量和通信时间</p>
<p>缓存服务器是代理服务器的一种，归类在缓存代理类型中</p>
<p>缓存服务器的优势在于利用缓存可以避免多次从源服务器转发资源。</p>
<h4 id="缓存的有效期限"><a href="#缓存的有效期限" class="headerlink" title="缓存的有效期限"></a>缓存的有效期限</h4><p>即使缓存服务器内存在缓存，也会因为客户端的要求，缓存的有效期限等因素，向原服务器确认资源的有效性。若判断缓存失效，缓存服务器会再次从原服务器上获取”新”资源</p>
<h4 id="客户端的缓存"><a href="#客户端的缓存" class="headerlink" title="客户端的缓存"></a>客户端的缓存</h4><p>除了代理服务器中存在缓存，客户端浏览器中也能存在缓存。如果缓存有效，则不用向服务器发送请求，直接从本地磁盘中读取资源</p>
<p>和缓存服务器相同，当判定缓存过期后，会向源服务器确认资源的有效性，若判断缓存失效，浏览器会再次请求新资源</p>
<hr>
<h2 id="第六章-HTTP首部"><a href="#第六章-HTTP首部" class="headerlink" title="第六章 HTTP首部"></a>第六章 HTTP首部</h2><h3 id="6-1-HTTP报文首部"><a href="#6-1-HTTP报文首部" class="headerlink" title="6.1 HTTP报文首部"></a>6.1 HTTP报文首部</h3><p>HTTP请求和响应报文中必定包含报文首部，报文首部由几个字段组成</p>
<ul>
<li>HTTP请求报文：由方法，HTTP版本，HTTP首部字段等部分构成</li>
<li>HTTP响应报文：由HTTP版本，状态码（数字和原因短语），HTTP首部字段三部分构成</li>
</ul>
<h3 id="6-2-HTTP首部字段"><a href="#6-2-HTTP首部字段" class="headerlink" title="6.2 HTTP首部字段"></a>6.2 HTTP首部字段</h3><h4 id="6-2-1-首部字段传递重要信息"><a href="#6-2-1-首部字段传递重要信息" class="headerlink" title="6.2.1 首部字段传递重要信息"></a>6.2.1 首部字段传递重要信息</h4><p>使用首部字段是为了给浏览器和服务器提供报文主体大小，所使用的语言，认证信息等内容</p>
<h4 id="6-2-2-HTTP首部字段结构"><a href="#6-2-2-HTTP首部字段结构" class="headerlink" title="6.2.2 HTTP首部字段结构"></a>6.2.2 HTTP首部字段结构</h4><p>首部字段名： 字段值</p>
<p>可以有多个值，用逗号隔开</p>
<h4 id="6-2-3-4种HTTP首部字段类型"><a href="#6-2-3-4种HTTP首部字段类型" class="headerlink" title="6.2.3 4种HTTP首部字段类型"></a>6.2.3 4种HTTP首部字段类型</h4><ul>
<li>通用首部字段：请求和响应报文双方都会使用的首部</li>
<li>请求首部字段：从客户端向服务器端发送请求报文时使用的首部</li>
<li>响应首部字段：从服务器端向客户端发送响应报文时使用的首部</li>
<li>实体首部字段：针对请求报文和响应报文的实体部分使用的首部</li>
</ul>
<h4 id="6-2-4-HTTP-x2F-1-1首部字段一览"><a href="#6-2-4-HTTP-x2F-1-1首部字段一览" class="headerlink" title="6.2.4 HTTP&#x2F;1.1首部字段一览"></a>6.2.4 HTTP&#x2F;1.1首部字段一览</h4><ul>
<li>通用首部字段<ul>
<li><code>Cache-Control</code>:控制缓存行为</li>
<li><code>Connection</code>:逐跳首部、连接的管理</li>
<li><code>Date</code>:创建报文的日期时间</li>
<li><code>Pragma</code>:报文指令</li>
<li><code>Trailer</code>:报文末端的首部一览</li>
<li><code>Transfer-Encoding</code>:指定报文主体的传输编码方式</li>
<li><code>Upgrade</code>:升级为其他协议</li>
<li><code>Via</code>:代理服务器的相关信息</li>
<li><code>Warning</code>:错误通知</li>
</ul>
</li>
<li>请求首部字段<ul>
<li><code>Accept</code>:用户代理可处理的媒体类型</li>
<li><code>Accept-Charset</code>:优先的字符集</li>
<li><code>Accept-Encoding</code>:优先的内容编码</li>
<li><code>Accept-Language</code>:优先的语言（自然语言）</li>
<li><code>Authorized</code>:Web认证信息</li>
<li><code>Expect</code>:期待服务器的特定行为</li>
<li><code>From</code>:用户的电子邮箱地址</li>
<li><code>Host</code>:请求资源所在的服务器</li>
<li><code>If-Match</code>:比较实体标记（ETag）</li>
<li><code>If-Modified-Since</code>:比较资源的更新时间</li>
<li><code>If-None-Match</code>:比较实体标记（与If-Match相反）</li>
<li><code>If-Range</code>:资源未更新时发送实体Byte的范围请求</li>
<li><code>If-Unmodified-Since</code>:比较资源的更新时间（与If-Modified-Since相反）</li>
<li><code>Max-Forwards</code>:最大传输跳转数</li>
<li><code>Proxy-Authorization</code>:代理服务器要求客户端的认证信息</li>
<li><code>Range</code>:实体的字节范围请求</li>
<li><code>Referer</code>:对请求中URI的原始获取方</li>
<li><code>TE</code>:传输编码的优先级</li>
<li><code>User-Agent</code>:HTTP客户端程序的信息</li>
</ul>
</li>
<li>响应首部字段<ul>
<li><code>Accept-Ranges</code>:是否接收字节范围请求</li>
<li><code>Age</code>:推算资源创建经过时间</li>
<li><code>ETAG</code>:资源的匹配信息</li>
<li><code>Location</code>:令客户端重定向至指定URI</li>
<li><code>Proxy-Authenticate</code>:代理服务器对客户端的认证信息</li>
<li><code>Retry-After</code>:对再次发起请求的时间要求</li>
<li><code>Server</code>:HTTP服务器的安装信息</li>
<li><code>Vary</code>:代理服务器缓存的管理信息</li>
<li><code>WWW-Authenticate</code>:服务器对客户端的认证信息</li>
</ul>
</li>
<li>实体首部字段：<ul>
<li><code>Allow</code>:资源可支持的HTTP方法</li>
<li><code>Content-Encoding</code>:实体主体适用的编码方式</li>
<li><code>Content-Language</code>:实体主体的自然语言</li>
<li><code>Content-Length</code>:实体主体的大小</li>
<li><code>Content-Location</code>:替代对应资源的URI</li>
<li><code>Content-MD5</code>:实体主体的报文摘要</li>
<li><code>Content-Range</code>:实体主体的位置范围</li>
<li><code>Content-Type</code>:实体主体的媒体类型</li>
<li><code>Expires</code>:实体主体过期的日期时间</li>
<li><code>Last-Modified</code>:资源最后的修改日期</li>
</ul>
</li>
</ul>
<h4 id="6-2-5-非HTTP-x2F-1-1首部字段"><a href="#6-2-5-非HTTP-x2F-1-1首部字段" class="headerlink" title="6.2.5 非HTTP&#x2F;1.1首部字段"></a>6.2.5 非HTTP&#x2F;1.1首部字段</h4><p>除了RFC2616中定义的47种首部字段，还有Cookie，Set-Cookie和Content-Disposition等在其他RFC中定义的首部字段，它们的使用频率很高</p>
<h4 id="6-2-6-End-to-end首部和Hop-by-hop首部"><a href="#6-2-6-End-to-end首部和Hop-by-hop首部" class="headerlink" title="6.2.6 End-to-end首部和Hop-by-hop首部"></a>6.2.6 End-to-end首部和Hop-by-hop首部</h4><ul>
<li>端到端首部：分在此类的首部会转发给请求&#x2F;响应对应的最终接受目标，且必须保存在由缓存生成的响应中，另外规定它必须被转发</li>
<li>逐跳首部：分在此类别中的首部只对单次转发有效，会因通过缓存或代理而不再转发</li>
</ul>
<p>HTTP&#x2F;1.1及之后版本中，使用逐跳首部需要提供Connection首部字段</p>
<h3 id="6-3-HTTP通用首部字段"><a href="#6-3-HTTP通用首部字段" class="headerlink" title="6.3 HTTP通用首部字段"></a>6.3 HTTP通用首部字段</h3><p>看书！</p>
<hr>
<h2 id="第七章-确保Web安全的HTTPS"><a href="#第七章-确保Web安全的HTTPS" class="headerlink" title="第七章 确保Web安全的HTTPS"></a>第七章 确保Web安全的HTTPS</h2><h3 id="7-1-HTTP的缺点"><a href="#7-1-HTTP的缺点" class="headerlink" title="7.1 HTTP的缺点"></a>7.1 HTTP的缺点</h3><h4 id="7-1-1-通信使用明文可能被窃听"><a href="#7-1-1-通信使用明文可能被窃听" class="headerlink" title="7.1.1 通信使用明文可能被窃听"></a>7.1.1 通信使用明文可能被窃听</h4><p>HTTP使用未经加密的报文发送。</p>
<p>按TCP&#x2F;IP协议族的工作机制，通信内容在所有的通信链路上都可能遭到窥视</p>
<p>加密后的报文也会被人看到，但是不容易破解而得到其中的含义</p>
<p>可以通过加密处理防止被窃听，加密对象可以如下：</p>
<ul>
<li>通信的加密</li>
</ul>
<p>通过SSL（安全套接层）和TLS（安全传输层协议）组合使用，加密HTTP的通信内容</p>
<p>用SSL建立安全通信链路后，就可以在这条链路上进行HTTP通信，与SSL组合使用的HTTP称为HTTPS（超文本传输安全协议）.</p>
<ul>
<li>内容的加密</li>
</ul>
<p>即把HTTP报文里所含的内容进行加密，前提是客户端和服务器端同时具有加密和解密的功能</p>
<p>这种方式所传输的内容仍有被篡改的风险</p>
<h4 id="7-1-2-不验证通信方的身份就可能遭遇伪装"><a href="#7-1-2-不验证通信方的身份就可能遭遇伪装" class="headerlink" title="7.1.2 不验证通信方的身份就可能遭遇伪装"></a>7.1.2 不验证通信方的身份就可能遭遇伪装</h4><p>HTTP协议中的请求和响应不会对通信方进行确认</p>
<p><strong>任何人可发起请求</strong></p>
<ul>
<li>无法确定目标web服务器是否是伪装服务器</li>
<li>无法确认收到响应的客户端是否是伪装客户端</li>
<li>无法确定正在通信的对方是否具备访问权限</li>
<li>无法判断请求来自何方</li>
<li>无意义的请求也会照单全收，无法阻止Dos攻击</li>
</ul>
<p><strong>查明对手的证书</strong></p>
<p>单单使用HTTP协议无法确定通信方，但使用SSL则可以</p>
<p>SSL不仅提供加密处理，还提供了一种名为证书的手段，用于确定通信方</p>
<p>证书由值得信任的第三方机构提供，用以证明服务器和客户端是实际存在的，伪造证书在技术上异常困难，因此只要能确认证书，就能判断通信方的真实意图</p>
<p>通过使用证书证明通信方就是意料中的服务器，减少了个人信息泄露的可能</p>
<p>客户端持有证书可以用于完成个人身份的确认，也可以用于web网站的认证环节</p>
<h4 id="7-1-3-无法证明报文完整性，可能已遭篡改"><a href="#7-1-3-无法证明报文完整性，可能已遭篡改" class="headerlink" title="7.1.3 无法证明报文完整性，可能已遭篡改"></a>7.1.3 无法证明报文完整性，可能已遭篡改</h4><p><strong>接收到的内容可能有误</strong></p>
<p>HTTP协议无法证明通信报文的完整性，也就是说，没有任何办法确认发送的报文和通信方接收到的报文是相同的</p>
<p><strong>如何防止篡改</strong></p>
<p>常用的方法是用MD5和SHA-1等散列值校验的方法，以及用来确认文件数字签名的方法（PGP）</p>
<p>用户需要自己查看下载的文件是否是原来服务器上的文件，浏览器无法帮助查看</p>
<p>但一旦MD5和PGP本身被改写，用户是无法察觉到的，因此无法确认结果一定正确</p>
<p>因此有必要使用HTTPS</p>
<h3 id="7-2-HTTP-加密-认证-完整性保护-x3D-HTTPS"><a href="#7-2-HTTP-加密-认证-完整性保护-x3D-HTTPS" class="headerlink" title="7.2 HTTP+加密+认证+完整性保护&#x3D;HTTPS"></a>7.2 HTTP+加密+认证+完整性保护&#x3D;HTTPS</h3><h4 id="7-2-1-HTTP加上加密处理和认证及完整性保护后就是HTTPS"><a href="#7-2-1-HTTP加上加密处理和认证及完整性保护后就是HTTPS" class="headerlink" title="7.2.1 HTTP加上加密处理和认证及完整性保护后就是HTTPS"></a>7.2.1 HTTP加上加密处理和认证及完整性保护后就是HTTPS</h4><p>使用HTTPS通信时，使用<code>https://</code>，访问HTTPS通信有效的web网站时，地址栏会出现一个锁。对HTTPS的显示方式会因浏览器不同有所改变</p>
<h4 id="7-2-2-HTTPS是身披SSL外壳的HTTP"><a href="#7-2-2-HTTPS是身披SSL外壳的HTTP" class="headerlink" title="7.2.2 HTTPS是身披SSL外壳的HTTP"></a>7.2.2 HTTPS是身披SSL外壳的HTTP</h4><p>HTTPS并不是全新的协议，只是HTTP通信接口部分用SSL和TLS协议代替</p>
<p>通常HTTP直接和TCP通信，使用SSL时，先和SSL通信，再由SSL和TCP通信</p>
<p>SSL是独立于HTTP的协议，不光HTTP，其他应用层协议也可配合SSL使用</p>
<h4 id="7-2-3-相互交换密钥的公开密钥交换技术"><a href="#7-2-3-相互交换密钥的公开密钥交换技术" class="headerlink" title="7.2.3 相互交换密钥的公开密钥交换技术"></a>7.2.3 相互交换密钥的公开密钥交换技术</h4><p><strong>共享加密密钥的困境</strong></p>
<p>加密和解密公用一个密钥的方式称为共享密钥加密（对称密钥加密）</p>
<p>但发送密钥有被窃听的风险，不发送通信方就无法解密，而且若密钥能安全发送，直接发送数据也能安全到达</p>
<p><strong>使用两种密钥的公开密钥加密</strong></p>
<p>公开密钥加密使用非对称的密钥。一把叫私钥，一把叫公钥。私钥不能让其他任何人知道，公钥可以发送给任何人</p>
<p>发送数据一方使用对方的公钥对数据进行加密，对方收到加密后的数据后使用私钥解密</p>
<p>只有公钥对密文还原是非常困难的</p>
<p><strong>HTTPS使用混合加密机制</strong></p>
<p>HTTPS使用共享密钥加密和公开密钥加密两者并用的混合加密机制。但公开密钥加密比共享密钥加密速度慢</p>
<p>因此充分利用二者优势，在交换密钥环节使用公开密钥加密，之后建立通信交换报文阶段使用共享密钥加密方式</p>
<p>即用公开密钥加密之后会在共享密钥加密过程中使用的密钥。</p>
<h4 id="7-2-4-证明公开密钥正确的证书"><a href="#7-2-4-证明公开密钥正确的证书" class="headerlink" title="7.2.4 证明公开密钥正确的证书"></a>7.2.4 证明公开密钥正确的证书</h4><p>公开密钥加密还是存在一些问题的，那就是无法证明公钥本身是否货真价实</p>
<p>为解决这个问题，可以由数字证书认证机构和其相关机关颁布的公开密钥证书</p>
<p>数字证书认证机构会将服务器运营人员发来的公开密钥添加进入数字证书并标记上数字签名，服务器取得了数字证书后将其发给客户端，客户端可使用数字证书机构的公开密钥对证书上的数字签名进行验证。一旦验证通过，客户端即可确定：1.认证服务器的公开密钥的是真实有效的数字机构 2.服务器的公开密钥值得信赖</p>
<p>认证机构的公共密钥也必须安全的转交给客户端，因此多数浏览器开发商都会事先在浏览器内部植入常用认证机关的公钥</p>
<p><strong>EV SSL证书</strong></p>
<p>此证书可以确认服务器背后运营的企业真实存在</p>
<p>持有该证书的网站的浏览器地址栏处的背景颜色是绿色的</p>
<p>愿意图是防止用户被钓鱼攻击，但实际效果不佳，因为大部分用户不了解该证书相关知识，并不会注意</p>
<p><strong>客户端证书</strong></p>
<p>客户端也可以申请客户端证书，发挥服务器证书相同的作用</p>
<p>但每申请一张证书都要相应的费用，安装证书也需要用户自身的知识水平，客户端证书只在少数情况下使用</p>
<p>如银行的网上银行采用客户端证书，登录网银时不仅要确认id和密码，还需要客户端证书来确认是否从特定终端上访问</p>
<p>客户端证书只能证明客户端实际存在，却无法证明客户端用户身份，若用户控制了计算机的使用权，也就拥有了客户端证书的使用权</p>
<p><strong>自签名证书</strong></p>
<p>由个体自己给自己的服务器颁布的证书称为自签名证书。独立构建的认证机构被称为自认证机构。自签名证书在互联网上无法被当作证书使用</p>
<p>当访问使用自签名证书的网站时，会提示”该网站的证书存在问题“等提示</p>
<h4 id="7-2-5-HTTPS的安全通信机制"><a href="#7-2-5-HTTPS的安全通信机制" class="headerlink" title="7.2.5 HTTPS的安全通信机制"></a>7.2.5 HTTPS的安全通信机制</h4><p>以TLS握手为例</p>
<ul>
<li>客户端发送clienthello消息，包含TLS版本，加密算法集，随机数</li>
<li>服务器端接收消息后发送serverHello消息，包含TLS版本，加密算法集，随机数</li>
<li>服务器端发送包含公钥的证书</li>
<li>服务器端发送serverHelloDone消息</li>
<li>客户端接收服务器端消息后验证证书机构是否权威和服务器是否为值得信赖的服务器，获取公钥</li>
<li>客户端发送由公钥加密的premaster secret</li>
<li>服务器端用私钥解密premaster secret</li>
<li>客户端和服务端使用之前生成的两个随机数＋premaster secret生成master secret用于对之后通信的所有数据加密</li>
<li>客户端发送ChangeCipherSpec消息和用master secret加密的finish消息</li>
<li>服务器端接收并验证，发送ChangeCipherSpec消息和用master secret加密的finish消息</li>
<li>客户端接收并认证，握手结束</li>
</ul>
<hr>
<h2 id="第八章-确认访问用户身份的认证"><a href="#第八章-确认访问用户身份的认证" class="headerlink" title="第八章 确认访问用户身份的认证"></a>第八章 确认访问用户身份的认证</h2><h3 id="8-1-何为认证"><a href="#8-1-何为认证" class="headerlink" title="8.1 何为认证"></a>8.1 何为认证</h3><p>认证用于核实客户端使用者的身份</p>
<p>HTTP&#x2F;1.1的认证方式如下</p>
<ul>
<li><p>BASIC认证（基本认证）</p>
</li>
<li><p>DIGEST认证（摘要认证）</p>
</li>
<li><p>SSL客户端认证</p>
</li>
<li><p>FormBase认证（基于表单认证）</p>
</li>
</ul>
<h3 id="8-2-BASIC认证"><a href="#8-2-BASIC认证" class="headerlink" title="8.2 BASIC认证"></a>8.2 BASIC认证</h3><ul>
<li>用户发送请求后，服务器返回401状态码，返回带WWW-Authenticate首部字段的响应，字段内含有认证方式和Request-URI安全域字符串（realm）</li>
<li>接到401状态码的客户端为了通过认证需要将用户id和密码发送给服务器，发送内容由“ID：密码”组成，经Base64编码处理后写入Authorization字段发送。若用户代理为浏览器，输入ID和密码即可，浏览器自动进行Base64编码</li>
<li>接到含首部字段Authorization请求的服务器对其进行验证，若通过则返回包含Request-URI资源的响应</li>
</ul>
<p>BASIC认证的Base编码并不是加密，可以直接解码为明文，因此在非加密通信的链路上进行认证时有可能被窃听</p>
<p>一般的浏览器无法实现认证注销</p>
<h3 id="8-3-DIGEST认证"><a href="#8-3-DIGEST认证" class="headerlink" title="8.3 DIGEST认证"></a>8.3 DIGEST认证</h3><p>DIGEST认证不会像BASIC认证那样直接发送明文密码</p>
<p>但同样安全系数有限，不被常用</p>
<h3 id="8-4-SSL客户端认证"><a href="#8-4-SSL客户端认证" class="headerlink" title="8.4 SSL客户端认证"></a>8.4 SSL客户端认证</h3><p>服务器端发送报文要求客户端发送客户端证书内容，客户端发送含公钥的客户端证书，服务器端收到证书后开启HTTPS连接</p>
<p><strong>双因素认证</strong></p>
<p>通过客户端认证确认终端，通过表单认证确认是用户本人操作，这种认证方式称为双因素认证</p>
<h3 id="8-5-基于表单认证"><a href="#8-5-基于表单认证" class="headerlink" title="8.5 基于表单认证"></a>8.5 基于表单认证</h3><p>并不是在HTTP中定义。客户端会向服务器的web应用发送登录信息，按登录信息的验证结果进行认证</p>
<p>现实中大多为基于表单的认证</p>
<p><strong>session管理和cookie应用</strong></p>
<p>客户端向服务器发送账号密码，服务器端验证后返回包含session-id的cookie，客户端再次登录时直接发送含session的cookie，服务器通过验证session信息验证是否为以登录的用户</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用指令</title>
    <url>/2022/10/14/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C/</url>
    <content><![CDATA[<h3 id="Linux-CommandLine"><a href="#Linux-CommandLine" class="headerlink" title="Linux CommandLine"></a>Linux CommandLine</h3><h4 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h4><ul>
<li>列出所有文件按行显示<code>ls -l</code></li>
<li>列出包含隐藏文件<code>ls -a</code></li>
<li>在目录后加&#x2F;<code>ls -F</code></li>
<li>显示访问时间（默认显示修改时间）<code>ls -l --time=atime &lt;filename&gt;</code></li>
</ul>
<h4 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h4><ul>
<li>创建文件<code>touch &lt;fileName&gt;</code></li>
<li>改变修改时间<code>touch &lt;filename&gt;</code></li>
<li>改变访问时间<code>touch -a &lt;filename&gt;</code></li>
</ul>
<h4 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h4><ul>
<li>复制文件<code>cp &lt;filename&gt; &lt;destination&gt;</code>,<code>&lt;destination&gt;</code>为文件名就会复制并重命名文件</li>
<li>提醒目标文件是否存在<code>cp -i &lt;filename&gt; &lt;destination&gt;</code></li>
<li>复制整个目录<code>cp -R &lt;foldName&gt; &lt;destination&gt;</code></li>
</ul>
<h4 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h4><ul>
<li>重命名<code>mv &lt;originalName&gt; &lt;hopedName&gt;</code></li>
<li>移动文件<code>mv &lt;filename&gt; &lt;destination&gt;</code></li>
<li>移动并重命名文件<code>mv &lt;path1&gt; &lt;path2&gt;</code></li>
</ul>
<h4 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h4><ul>
<li><p>提示是否删除<code>rm -i &lt;filename&gt;</code></p>
</li>
<li><p>强制删除<code>rm -f &lt;filename&gt;</code></p>
</li>
<li><p>删除目录<code>rm -r &lt;folderName&gt;</code></p>
</li>
</ul>
<h4 id="ln"><a href="#ln" class="headerlink" title="ln"></a>ln</h4><ul>
<li>创建符号链接<code>ln -s &lt;filename&gt; &lt;hopedName&gt;</code></li>
<li>查看原始文件<code>readlink -f &lt;filename&gt;</code></li>
<li>创建硬连接<code>ln &lt;filename&gt; &lt;hopedname&gt;</code></li>
</ul>
<h4 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h4><ul>
<li>创建文件夹<code>mkdir &lt;folderName&gt;</code></li>
<li>创建父目录以及其子目录<code>mkdir -p &lt;path&gt;</code></li>
</ul>
<h4 id="file"><a href="#file" class="headerlink" title="file"></a>file</h4><ul>
<li><p>查看文件类型<code>file &lt;filename&gt;</code></p>
</li>
<li><p>查看文件末尾<code>tail &lt;filename&gt;</code></p>
</li>
<li><p>查看指定行数的文件末尾<code>tail -n &lt;num&gt; &lt;filename&gt;</code></p>
</li>
<li><p>查看文件开头<code>head &lt;filename&gt;</code></p>
</li>
<li><p>查看指定行数的文件开头<code>head -n &lt;num&gt; &lt;filename&gt;</code></p>
</li>
<li><p>查看文件内容<code>cat &lt;filename&gt;</code></p>
</li>
<li><p>阅读文件<code>less</code></p>
<ul>
<li><code>b</code>:向上翻页</li>
<li><code>space</code>向下翻页</li>
<li><code>/&lt;string&gt;</code>查找匹配字符串</li>
<li><code>G</code>到达文件末尾</li>
<li><code>g</code>到达文件开头</li>
<li><code>v</code>用编辑器打开</li>
<li><code>q</code>退出</li>
</ul>
</li>
<li><p>阅读文件按页显示<code>more</code></p>
<ul>
<li><code>enter</code>向下n行，默认1行</li>
<li><code>ctrl F/space</code>向下滚动一屏</li>
<li><code>=</code>输出行号</li>
<li><code>ctrl B</code>返回上一屏</li>
<li><code>q</code>退出</li>
</ul>
</li>
<li><p>按照某种方式打印文件<code>awk &#39;&lt;options&gt;&#39; </code><filename></p>
<ul>
<li>以空格为分隔符，打印文件每行第五列(也称作字段)：<code>awk &#39;&#123;print $5&#125;&#39; &lt;filename&gt;</code></li>
<li>以空格为分隔符，打印文件包含“foo” 的所有行的第二列：<code>awk &#39;/foo/ &#123;print $2&#125;&#39; &lt;filename&gt;</code></li>
</ul>
</li>
</ul>
<h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><ul>
<li>通过拓展名查找文件<code>find &lt;path&gt; -name &#39;*.&lt;name&gt;&#39;</code></li>
<li>查找指定类型的文件<code>find &lt;path&gt; -type &lt;options&gt;</code><ul>
<li><code>f</code>一般文件</li>
<li><code>d</code>目录</li>
</ul>
</li>
</ul>
<h4 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h4><ul>
<li>查看进程<code>ps</code></li>
<li>查看所有进程<code>ps -e</code></li>
<li>显示更多进程信息<code>ps -f</code></li>
<li>显示更多进程信息<code>ps -l</code></li>
<li>BSD模式输出<code>ps l</code></li>
</ul>
<h4 id="top"><a href="#top" class="headerlink" title="top"></a>top</h4><ul>
<li>显示进程实时信息<code>top</code><ul>
<li><code>f</code>选择排序字段</li>
<li><code>d</code>修改查询间隔</li>
</ul>
</li>
</ul>
<h4 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h4><ul>
<li>向进程发送<code>TERM</code>信号<code>kill &lt;PID&gt;</code></li>
<li>向进程发送其他信号<code>kill -s &lt;name&gt; &lt;PID&gt;</code></li>
</ul>
<h4 id="killall"><a href="#killall" class="headerlink" title="killall"></a>killall</h4><ul>
<li>通过进程名发送信号<code>killall &lt;processName&gt;</code></li>
</ul>
<h4 id="pkill"><a href="#pkill" class="headerlink" title="pkill"></a>pkill</h4><ul>
<li>通过进程名发送信号<code>pkill &lt;processName&gt;</code></li>
</ul>
<h4 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h4><ul>
<li>输出文件中搜索匹配的行<code>grep &lt;string&gt; &lt;filename&gt;</code></li>
<li>输出不匹配的行<code>grep -v &lt;string&gt; &lt;filename&gt; </code></li>
<li>输出匹配行的行数<code>grep -c &lt;string&gt; &lt;filename&gt;</code></li>
<li>输出多个匹配<code>grep -e &lt;string1&gt; -e &lt;string2&gt; &lt;filename&gt;</code></li>
</ul>
<h4 id="jobs"><a href="#jobs" class="headerlink" title="jobs"></a>jobs</h4><ul>
<li>显示后台进程<code>jobs</code></li>
<li>显示包含<code>PID</code>的后ps台进程<code>jobs -l</code></li>
</ul>
<h4 id="amp"><a href="#amp" class="headerlink" title="&amp;"></a>&amp;</h4><ul>
<li>将命令放入后台<code>&lt;command&gt; &amp;</code></li>
</ul>
<h4 id="lsof"><a href="#lsof" class="headerlink" title="lsof"></a>lsof</h4><ul>
<li>查看端口占用情况<code>losf -i:&lt;port&gt;</code></li>
<li>ps</li>
</ul>
<h4 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h4><ul>
<li>创建一个别名<code>alias &lt;shortname&gt; = &quot;&lt;command&gt;&quot;</code></li>
</ul>
<h4 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h4><ul>
<li>改变文件权限<code>chmod &lt;options&gt; &lt;mode&gt; &lt;filename&gt;</code><ul>
<li>文件的权限有三种：rwx（读，写，执行）,根据有无先转成二进制在转成8进制可表示成唯一符号，如r-x为101，5；rwx为111，7</li>
<li>在八进制模式下修改直接指定3个八进制参数就行，分别代表用户，组，其他的权限</li>
<li>在符号模式下：<code>chmod [ugoa...] [+=-] [rwx...]</code><ul>
<li>u：用户</li>
<li>g：组</li>
<li>o：其他</li>
<li>a：全部</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h4><ul>
<li><p>改变文件属主<code>chown &lt;username&gt; &lt;filename&gt;</code></p>
</li>
<li><p>改变文件属主和组别<code>chown &lt;username&gt;.&lt;groupname&gt; &lt;filename&gt;</code></p>
</li>
<li><p>只改变组属<code>chown .&lt;groupname&gt; filename</code></p>
</li>
<li><p>递归改变子目录<code>chown -R &lt;username&gt; &lt;filename&gt;</code></p>
</li>
</ul>
<h4 id="systemd"><a href="#systemd" class="headerlink" title="systemd"></a>systemd</h4><ul>
<li>列出所有的unit<code>systemctl list-units</code></li>
<li>列出所有的unit<code>systemctl list-units --all</code></li>
<li>启动<code>sudo systemctl start &lt;unit&gt;</code></li>
<li>终止<code>sudo systemctl stop &lt;unit&gt;</code></li>
<li>结束<code>sudo systemctl kill &lt;unit&gt;</code></li>
<li>查看配置<code>systemctl cat &lt;unit&gt;</code></li>
<li>查看日志<code>sudo journalctl</code></li>
<li>滚动显示最新日志<code>sudo journalctl -f</code></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>速查</tag>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise学习笔记</title>
    <url>/2022/10/26/Promise%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="Promise-学习笔记"><a href="#Promise-学习笔记" class="headerlink" title="Promise 学习笔记"></a>Promise 学习笔记</h3><p>希望通过学习Promise增强自己对异步的理解</p>
<h3 id="chapter-1：什么是Promise"><a href="#chapter-1：什么是Promise" class="headerlink" title="chapter 1：什么是Promise"></a>chapter 1：什么是Promise</h3><p>Promise是抽象异步处理对象以及对其进行各种操作的组件，promise的功能是可以将复杂的异步处理轻松地进行模式化</p>
<h4 id="Promise简介"><a href="#Promise简介" class="headerlink" title="Promise简介"></a>Promise简介</h4><h5 id="Promise的基本用法"><a href="#Promise的基本用法" class="headerlink" title="Promise的基本用法"></a><code>Promise</code>的基本用法</h5><ul>
<li><p>通过构造函数创建一个<code>Promise</code>对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//异步操作</span></span><br><span class="line">    <span class="comment">//异步操作完成后调用resolve或者reject</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>为了设置<code>promise</code>在<code>resolve</code>或者<code>reject</code>时调用的回调函数，使用<code>Promise.then()</code>方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">promise.<span class="title function_">then</span>(onFulfilled,onRejected);</span><br></pre></td></tr></table></figure>

<p>如果<code>Promise</code>中调用的是<code>resolve</code>，就会触发<code>onFulfilled</code>回调，如果调用的是<code>reject</code>，触发<code>onRejected</code>回调</p>
</li>
<li><p>其他方法：Promise对象还有一系列静态方法和原型方法</p>
</li>
<li><p>举个例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;完成耗时工作&quot;</span>);</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&quot;这是传递给then中value的值&quot;</span>);</span><br><span class="line">  &#125;, <span class="number">200</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">  &#125;, <span class="number">200</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>控制台会在200ms之后输出‘完成耗时工作’，又过200ms输出“这是传递给then中value的值”</p>
<ul>
<li>创建<code>Promise</code>对象后，其中的内容立即执行，经过200ms后触发<code>console.log</code>和<code>resolve</code></li>
<li>触发<code>resolve</code>后，then中的内容开始执行，接受到的值即使传入<code>resolve</code>中的值，200ms后输出</li>
</ul>
</li>
</ul>
<h5 id="Promise的状态"><a href="#Promise的状态" class="headerlink" title="Promise的状态"></a><code>Promise</code>的状态</h5><p>使用<code>new Promise</code>实例化的对象有三种状态</p>
<ul>
<li>Pending：既不是Fulfilled也不是Rejected的状态，也就是初始化状态等</li>
<li>Fulfilled：成功状态，此时调用<code>onFulfilled</code></li>
<li>Rejected：失败状态，此时调用<code>onRejected</code></li>
<li>Fulfilled和Rejected状态都可以被认为是“不变的”，promise对象的状态，从_Pending_转换为_Fulfilled_或_Rejected_之后， 这个promise对象的状态就不会再发生任何变化。因此在<code>.then</code> 后执行的函数可以肯定地说只会被调用一次。</li>
</ul>
<h5 id="Promise的其他方法举例"><a href="#Promise的其他方法举例" class="headerlink" title="Promise的其他方法举例"></a><code>Promise</code>的其他方法举例</h5><ul>
<li><code>resolve</code>：<code>Promise.resolve(val)</code>返回一个<code>Fulfilled</code>状态的<code>Promise</code>对象，val就是该<code>Promise</code>对象的value值</li>
<li><code>reject</code>:<code>Promise.reject(val)</code>返回一个<code>Rejected</code>状态的<code>Promise</code>对象，val就是该<code>Promise</code>对象的reason值</li>
<li><code>catch</code>:<code>catch(onrejected)</code>用于注册当前Promise对象在<code>rejected</code>状态下的回调函数</li>
<li><code>finally</code>:<code>finally(callback)</code>用于注册当前<code>Promise</code>对象无论在<code>Fulfilled</code>还是<code>Rejected</code>状态下都会执行的回调</li>
<li><code>all</code>:<code>Promise.all(PromiseList)</code>传入一个由Promise对象组成的数组，并返回一个Promise对象，当数组中全部变为<code>Fulfilled</code>状态时返回的Promise对象才变为Fulfilled状态，否则为<code>rejected</code>状态</li>
<li><code>race</code>:<code>Promise.race(PromiseList)</code>也接受一个由Promise对象组成的数组，并返回一个Promise对象，当数组中有Promise对象的状态变化时，返回的Promise状态也会跟着变化</li>
</ul>
<h3 id="chapter2：自己实现一个Promise"><a href="#chapter2：自己实现一个Promise" class="headerlink" title="chapter2：自己实现一个Promise"></a>chapter2：自己实现一个Promise</h3><p>我们先去实现Promise中最需要的构造函数和then方法,原型方法和静态方法稍后实现</p>
<h4 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor()"></a><code>constructor()</code></h4><p>关于Promise的构造方法，在使用Promise时我们都知道，我们需要传入一个执行函数，该函数会立即执行，该函数存在两个参数，<code>resolve，reject</code>，这两个参数都是函数，当调用时，就会改变<code>Promise</code>的状态，接着then中的回调便会开始执行，这两个参数函数在调用时都可以传入一个值，代表Promise的<code>value</code>或者<code>reject</code>,在then的回调中可以直接使用</p>
<p>有了上面的使用经验，我们根据用法来实现一个构造函数</p>
<h5 id="初始化一些值"><a href="#初始化一些值" class="headerlink" title="初始化一些值"></a>初始化一些值</h5><p>根据上面的用法我们知道，我们需要一些在Promise对象中会使用到的值，如状态<code>status</code>,给resolve传入的值<code>value</code>,给reject传入的值<code>reason</code>，他们都是值形式。除他们以外，还要想到，我们还需要储存then中传入的回调函数，因为当Promise的状态为<code>pending</code>时then中函数的执行需要滞后，我们需要把回调存储起来，当调用<code>resolve</code>或<code>reject</code>函数时，执行他们</p>
<p>关于回调的存储可以直接采用赋值形式吗？不行，看下面的代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>()</span><br><span class="line">&#125;)</span><br><span class="line">p1.<span class="title function_">then</span>(onResolved1);</span><br><span class="line">p1.<span class="title function_">then</span>(onResolved2);</span><br></pre></td></tr></table></figure>

<p>我们希望的是当执行到<code>resolve</code>之后去执行<code>onResolved1</code>和<code>onResolved2</code>，但如果我们采用直接赋值的方式，那么<code>onResolved2</code>就会覆盖掉<code>onResolved1</code>，这是我们所不希望的，因此，我们需要把所有<code>onResolved</code>和<code>onRejected</code>存放进数组里，当需要调用是按顺序调用即可</p>
<p>这样我们就为<code>constructor</code>初始化了值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reason</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">status</span> = <span class="string">&quot;pending&quot;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onResolvedCallback</span> = [];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onRejectedCallback</span> = [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="定义resolve和reject"><a href="#定义resolve和reject" class="headerlink" title="定义resolve和reject"></a>定义<code>resolve</code>和<code>reject</code></h5><p>然后，我们的执行函数接收的两个参数也是需要在<code>constructor</code>中定义的，根据他们的作用，很容易做出定义</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">resolve</span> = (<span class="params">value</span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">status</span> = <span class="string">&quot;resolved&quot;</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">onResolvedCallback</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">callback</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">callback</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">reject</span> = (<span class="params">reason</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">status</span> = <span class="string">&quot;rejected&quot;</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">reason</span> = reason;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">onRejectedCallback</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">callback</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">callback</span>(<span class="variable language_">this</span>.<span class="property">reason</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p>这两个函数作用大同小异，都是需要在<code>pending</code>状态下才能执行，然后修改状态，保存给他们传入的值，然后调用then中的回调并给这些回调传入需要的参数</p>
<h5 id="执行传入的函数"><a href="#执行传入的函数" class="headerlink" title="执行传入的函数"></a>执行传入的函数</h5><p>传入的执行函数需要立即执行，直接在<code>constructor</code>中立即执行即可</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="title function_">executor</span>(resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="title function_">reject</span>(err);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如果在执行中出错就会直接修改<code>Promise</code>的状态</p>
<p>这样我们就实现了Promise对象的<code>constructor</code>，你可以发现在这部分中我们直接执行了<code>executor</code>，这是同步的，所以说<code>Promise</code>本身是同步的</p>
<p>该部分完整代码如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LyPromise</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reason</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">status</span> = <span class="string">&quot;pending&quot;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onResolvedCallback</span> = [];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onRejectedCallback</span> = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> executor !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Promise resolver undefined is not a function&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">resolve</span> = (<span class="params">value</span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">status</span> = <span class="string">&quot;resolved&quot;</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">onResolvedCallback</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">callback</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">callback</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">reject</span> = (<span class="params">reason</span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">status</span> = <span class="string">&quot;rejected&quot;</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">reason</span> = reason;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">onRejectedCallback</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">callback</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">callback</span>(<span class="variable language_">this</span>.<span class="property">reason</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// console.log(&quot;现在执行executor&quot;);</span></span><br><span class="line">      <span class="title function_">executor</span>(resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="title function_">reject</span>(err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="then"><a href="#then" class="headerlink" title="then()"></a><code>then()</code></h4><p>这是<code>Promise</code>对象的一个原型方法，它的实现要比<code>constructor</code>更为复杂，在开始实现之前，我们先来看看<code>then()</code>有哪些特殊之处</p>
<ul>
<li><p>返回值。我们都知道<code>Promise</code>中的<code>then</code>是可以链式调用的，那么<code>then</code>就需要返回一个<code>Promise</code>，能不能直接返回自身（<code>this</code>）呢？显然不可以。因为自身的状态一旦改变就固定，如果返回自身必然造成某些情况下状态的错误。因此我们需要返回一个新的<code>Promise</code>对象。此外，then中传入的函数的返回值充当了返回的Promise的value</p>
</li>
<li><p>透传。当传给then的参数不是一个函数时，如果存在链式调用，参数会作为<code>value</code>被传给下一个<code>then</code>。</p>
</li>
<li><p>微任务。<code>Promise</code>中的函数是同步立即执行的，但<code>then</code>中的回调是异步执行的，在<code>Promise A+</code>中并没有规范then的异步究竟是宏任务还是微任务，但从ES6引入的<code>Promise</code>来看，大家更愿意采用微任务的形式</p>
</li>
<li><p>对返回值做进一步规范。思考一下，我们需要让<code>then</code>返回一个<code>Promise</code>，<code>Promise</code>中的<code>value</code>或<code>reason</code>是由<code>then</code>中回调的返回值确定的，但如果then中回调返回了一个<code>Promise</code>呢？假设我们声明了一个<code>Promise</code>为<code>p1</code>,调用<code>p1.then(fun)</code>,<code>fun</code>返回一个<code>Promise</code>对象<code>p2</code>，那么就会出现下面这种情况</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">LyPromise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="comment">//一些操作</span></span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;p1任务完成&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p2 = p1.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LyPromise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123; <span class="title function_">resolve</span>(<span class="string">&quot;p1中then返回值完成&quot;</span>) &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p2.<span class="title function_">then</span>(<span class="function">(<span class="params">p3</span>) =&gt;</span> &#123;</span><br><span class="line">  p3.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;多了一层嵌套&quot;</span>)  </span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>想一下，如果一直返回<code>Promise</code>，就可能会出现下面的情况</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">p1.<span class="title function_">then</span>(<span class="function">(<span class="params">p2</span>) =&gt;</span> &#123;</span><br><span class="line">    p2.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> p3</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">p3</span>) =&gt;</span> &#123;</span><br><span class="line">        p3.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> p4</span><br><span class="line">        &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">p4</span>) =&gt;</span> &#123;</span><br><span class="line">            p4.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> p5</span><br><span class="line">                <span class="comment">//回调地狱</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>因此，我们需要一个函数处理这种情况，将包裹进去的<code>Promise</code>的最终值提取出来。此外，如果x是含有then方法的函数，对象，也需要做处理</p>
<p>下面开始实现<code>then</code></p>
<h5 id="解决透传"><a href="#解决透传" class="headerlink" title="解决透传"></a>解决透传</h5><p>透传相对来说是最好处理的，我们需要对传入的参数做一定的处理</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">onResolved =</span><br><span class="line">     <span class="keyword">typeof</span> onResolved === <span class="string">&quot;function&quot;</span></span><br><span class="line">       ? onResolved</span><br><span class="line">       : <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> value;</span><br><span class="line">         &#125;;</span><br><span class="line">   onRejected =</span><br><span class="line">     <span class="keyword">typeof</span> onRejected === <span class="string">&quot;function&quot;</span></span><br><span class="line">       ? onRejected</span><br><span class="line">       : <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">           <span class="keyword">throw</span> reason;</span><br><span class="line">         &#125;;</span><br></pre></td></tr></table></figure>

<p>检测传入的值是否为函数，如果不是就包装成有返回值或者抛出错误的函数</p>
<h5 id="返回新对象"><a href="#返回新对象" class="headerlink" title="返回新对象"></a>返回新对象</h5><p>我们定义一个新的<code>Promise</code>对象<code>promise2</code>，对它做处理之后返回即可</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="title class_">LyPromise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//做处理  </span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> promise2;</span><br></pre></td></tr></table></figure>

<h5 id="对promise2的处理"><a href="#对promise2的处理" class="headerlink" title="对promise2的处理"></a>对<code>promise2</code>的处理</h5><p>对<code>promise2</code>中内容的处理，大致概括如下:</p>
<p>根据<code>this.status</code>对状态的判断执行不同的操作</p>
<ul>
<li>pending状态：此时还没有执行到<code>resolve()</code>，将要执行的内容(及下面两种状态的操作)封装成函数推入<code>this.onResolvedCallback</code>和<code>this.onRejectedCallback</code>中</li>
<li>resolved状态：也就是Fulfilled状态，若处于这种状态，直接执行<code>onResolved</code>并获取到返回值，然后通过返回值的类型做进一步工作（处理掉嵌套的Promise等），最终得到我们需要的promise2，这些进一步操作我们放在<code>resolvePromise</code>函数中</li>
<li>rejected状态：若处于这种状态，直接执行<code>onRejected</code>并获取到返回值，再执行<code>resolvePromise()</code></li>
<li>如果执行函数的过程中出错了，返回的promise2直接变为rejected状态</li>
<li>微任务包裹，我们使用node.js中<code>process.nextTick()</code>，这个函数会把传入的回调在当前宏任务结束之后执行，也就是符合微任务的执行流程。把我们需要执行的内容用<code>process.nextTick()</code>包裹起来，就实现了微任务化</li>
</ul>
<p>由此我们得到then方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">then</span>(<span class="params">onResolved, onRejected</span>) &#123;</span><br><span class="line">  onResolved =</span><br><span class="line">    <span class="keyword">typeof</span> onResolved === <span class="string">&quot;function&quot;</span></span><br><span class="line">      ? onResolved</span><br><span class="line">      : <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> value;</span><br><span class="line">        &#125;;</span><br><span class="line">  onRejected =</span><br><span class="line">    <span class="keyword">typeof</span> onRejected === <span class="string">&quot;function&quot;</span></span><br><span class="line">      ? onRejected</span><br><span class="line">      : <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> reason;</span><br><span class="line">        &#125;;</span><br><span class="line">  <span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="title class_">LyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="string">&quot;resolved&quot;</span>) &#123;</span><br><span class="line">      process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> x = <span class="title function_">onResolved</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">          <span class="title function_">resolvePromise</span>(promise2, x, resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">          <span class="title function_">reject</span>(err);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="string">&quot;rejected&quot;</span>) &#123;</span><br><span class="line">      process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> x = <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>);</span><br><span class="line">          <span class="title function_">resolvePromise</span>(promise2, x, resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">          <span class="title function_">reject</span>(err);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">onResolvedCallback</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = <span class="title function_">onResolved</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">            <span class="title function_">resolvePromise</span>(promise2, x, resolve, reject);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(err);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">onRejectedCallback</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>);</span><br><span class="line">            <span class="title function_">resolvePromise</span>(promise2, x, resolve, reject);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(err);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> promise2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们需要实现<code>resolvePromise</code></p>
<h5 id="resolvePromise"><a href="#resolvePromise" class="headerlink" title="resolvePromise"></a><code>resolvePromise</code></h5><p>根据<code>Promise A+</code>规范，<code>resolvePromise</code>主要解决以下四种情况</p>
<ul>
<li><p><code>then</code>中回调的返回值x和<code>promise2</code>是相同的引用，即循环调用，抛出一个<code>TypeError</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p2 = p1.<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p2;<span class="comment">//这种写法应该报错</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>then</code>中回调的返回值x是<code>Promise</code>对象，<code>promise2</code>的状态应该采用x的状态</p>
</li>
<li><p><code>then</code>中回调的返回值x是<code>thenable</code>对象或函数，用<code>x.then</code>代替<code>then</code></p>
</li>
<li><p><code>then</code>中回调的返回值x既不是函数也不是对象，把x作为<code>promise2</code>的resolve</p>
</li>
</ul>
<p>读规范或许并不能启示我们如何编写<code>resolvePromise</code>，且<code>Promise</code>本身也是一个thenable对象，因此我们把规范再整合一下,得到<code>resolvePromise</code>的大体结构：</p>
<ul>
<li><p>x是循环调用：<code>promise2</code>变为<code>rejected</code>状态，抛出TypeError</p>
</li>
<li><p>x是对象或者函数</p>
<ul>
<li><p>x是thenable的：</p>
<ul>
<li><p><code>x.then</code>是函数：执行下面的函数,这就引入了递归，因为假设x是一个promise对象，给<code>x.then</code>的<code>onResolved</code>回调传入的参数我们很难保证不是thenable的，我们需要逐层递归拿到最终值，根据<code>resolvePromise</code>的结构，最终值会充当<code>promise2</code>中<code>resolve</code>的参数或者中间出错执行<code>reject(err)</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//x.then为函数的处理框架</span></span><br><span class="line">x.<span class="title function_">then</span>(<span class="function">(<span class="params">y</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolvePromise</span>(promise2,y,resolve,reject)</span><br><span class="line">&#125;,<span class="function">(<span class="params">r</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(r)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>规范还规定，在这种情况下，如果<code>then</code>中传递的两个函数都会被执行（如下面的情况），只执行最前面的，而且如果在执行了之后才catch到错误，就忽略这个错误。所以我们还需要引入一个变量<code>used</code>来控制传入的函数是否会执行以及是否需要<code>reject(err)</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">then</span>:<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//一些操作</span></span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&quot;既执行了resolve&quot;</span>)</span><br><span class="line">        <span class="comment">//一些操作</span></span><br><span class="line">        <span class="title function_">reject</span>(<span class="string">&quot;又执行了reject&quot;</span>)</span><br><span class="line">        <span class="comment">//只执行resolve</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>x.then</code>不是函数：执行<code>resolve(x)</code></p>
</li>
</ul>
</li>
<li><p>x不是thenable的：执行<code>resolve(x)</code></p>
</li>
</ul>
</li>
<li><p>x为其他值：执行<code>resolve(x)</code></p>
</li>
<li><p>期间捕获到错误err：执行<code>reject(err)</code></p>
</li>
</ul>
<p>有了这样一个相对清晰的结构，我们可以编写<code>resolvePromise</code>的代码了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">resolvePromise</span> = (<span class="params">promise2, x, resolve, reject</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> used = <span class="literal">false</span>;<span class="comment">//控制只执行一次</span></span><br><span class="line">  <span class="keyword">if</span> (x === promise2) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Chaining cycle detected for promise!&quot;</span>));</span><br><span class="line">  &#125;<span class="comment">//处理循环调用</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (x != <span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> x === <span class="string">&quot;function&quot;</span> || <span class="keyword">typeof</span> x === <span class="string">&quot;object&quot;</span>)) &#123;<span class="comment">//处理函数和对象</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> then = x.<span class="property">then</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">&quot;function&quot;</span>) &#123;<span class="comment">//如果x.then是函数</span></span><br><span class="line">        then.<span class="title function_">call</span>(</span><br><span class="line">          x,</span><br><span class="line">          <span class="function">(<span class="params">y</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (used) &#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            used = <span class="literal">true</span>;</span><br><span class="line">            <span class="title function_">resolvePromise</span>(promise2, y, resolve, reject);<span class="comment">//递归得到最后的结果</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="function">(<span class="params">r</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (used) &#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            used = <span class="literal">true</span>;</span><br><span class="line">            <span class="title function_">reject</span>(r);</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(x);<span class="comment">//不是函数，可以直接resolve</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="keyword">if</span> (used) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      used = <span class="literal">true</span>;</span><br><span class="line">      <span class="title function_">reject</span>(err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(x);<span class="comment">//x为其他值，直接resolve</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>到此为止，我们已经完成了一个能通过<code>Promise A+</code>测试的<code>Promise</code>对象了，完整代码如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LyPromise</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reason</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">status</span> = <span class="string">&quot;pending&quot;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onResolvedCallback</span> = [];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onRejectedCallback</span> = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> executor !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Promise resolver undefined is not a function&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">resolve</span> = (<span class="params">value</span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">status</span> = <span class="string">&quot;resolved&quot;</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">onResolvedCallback</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">callback</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">callback</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">reject</span> = (<span class="params">reason</span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">status</span> = <span class="string">&quot;rejected&quot;</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">reason</span> = reason;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">onRejectedCallback</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">callback</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">callback</span>(<span class="variable language_">this</span>.<span class="property">reason</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="title function_">executor</span>(resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="title function_">reject</span>(err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">then</span>(<span class="params">onResolved, onRejected</span>) &#123;</span><br><span class="line">    onResolved =</span><br><span class="line">      <span class="keyword">typeof</span> onResolved === <span class="string">&quot;function&quot;</span></span><br><span class="line">        ? onResolved</span><br><span class="line">        : <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">          &#125;;</span><br><span class="line">    onRejected =</span><br><span class="line">      <span class="keyword">typeof</span> onRejected === <span class="string">&quot;function&quot;</span></span><br><span class="line">        ? onRejected</span><br><span class="line">        : <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> reason;</span><br><span class="line">          &#125;;</span><br><span class="line">    <span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="title class_">LyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="string">&quot;resolved&quot;</span>) &#123;</span><br><span class="line">        process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = <span class="title function_">onResolved</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">            <span class="title function_">resolvePromise</span>(promise2, x, resolve, reject);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(err);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="string">&quot;rejected&quot;</span>) &#123;</span><br><span class="line">        process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>);</span><br><span class="line">            <span class="title function_">resolvePromise</span>(promise2, x, resolve, reject);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(err);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">onResolvedCallback</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">let</span> x = <span class="title function_">onResolved</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">              <span class="title function_">resolvePromise</span>(promise2, x, resolve, reject);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">              <span class="title function_">reject</span>(err);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">onRejectedCallback</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">let</span> x = <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>);</span><br><span class="line">              <span class="title function_">resolvePromise</span>(promise2, x, resolve, reject);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">              <span class="title function_">reject</span>(err);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> promise2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">resolvePromise</span> = (<span class="params">promise2, x, resolve, reject</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> used = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (x === promise2) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Chaining cycle detected for promise!&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (x != <span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> x === <span class="string">&quot;function&quot;</span> || <span class="keyword">typeof</span> x === <span class="string">&quot;object&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> then = x.<span class="property">then</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        then.<span class="title function_">call</span>(</span><br><span class="line">          x,</span><br><span class="line">          <span class="function">(<span class="params">y</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (used) &#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            used = <span class="literal">true</span>;</span><br><span class="line">            <span class="title function_">resolvePromise</span>(promise2, y, resolve, reject);</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="function">(<span class="params">r</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (used) &#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            used = <span class="literal">true</span>;</span><br><span class="line">            <span class="title function_">reject</span>(r);</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(x);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="keyword">if</span> (used) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      used = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">      <span class="title function_">reject</span>(err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>如何测试自己实现的<code>Promise</code>是否符合规范呢，我们需要安装相应的测试模块</p>
<h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure>

<h5 id="下载测试"><a href="#下载测试" class="headerlink" title="下载测试"></a>下载测试</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i promises-aplus-tests -D</span><br></pre></td></tr></table></figure>

<h5 id="配置package-jion，在其中添加或修改为如下内容"><a href="#配置package-jion，在其中添加或修改为如下内容" class="headerlink" title="配置package.jion，在其中添加或修改为如下内容"></a>配置<code>package.jion</code>，在其中添加或修改为如下内容</h5><p>把<code>Promise.js</code>修改为你存放对象的js文件</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;test&quot;</span><span class="punctuation">:</span> <span class="string">&quot;promises-aplus-tests Promise.js&quot;</span></span><br><span class="line"> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>

<h5 id="添加测试相关的代码"><a href="#添加测试相关的代码" class="headerlink" title="添加测试相关的代码"></a>添加测试相关的代码</h5><p>把<code>LyPromise</code>改成你实现的<code>Promise</code>类名</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">LyPromise</span>.<span class="property">deferred</span> = <span class="title class_">LyPromise</span>.<span class="property">defer</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> dfd = &#123;&#125;;</span><br><span class="line">  dfd.<span class="property">promise</span> = <span class="keyword">new</span> <span class="title class_">LyPromise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    dfd.<span class="property">resolve</span> = resolve;</span><br><span class="line">    dfd.<span class="property">reject</span> = reject;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> dfd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title class_">LyPromise</span>;</span><br></pre></td></tr></table></figure>

<h5 id="开始测试"><a href="#开始测试" class="headerlink" title="开始测试"></a>开始测试</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm run test</span><br></pre></td></tr></table></figure>

<p>若所有项均通过则说明符合规范</p>
<h4 id="其他原型方法和静态方法"><a href="#其他原型方法和静态方法" class="headerlink" title="其他原型方法和静态方法"></a>其他原型方法和静态方法</h4><p>除了<code>then</code>外，规范中还有其他原型方法和静态方法，只不过某些还没有被标准化</p>
<p>我们来实现一下已经被标准化的方法</p>
<h5 id="catch"><a href="#catch" class="headerlink" title="catch()"></a><code>catch()</code></h5><p>这是一个原型方法，作用在前面说过，实现起来也很简单</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">catch</span>(onRejected) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(<span class="literal">null</span>, onRejected);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="finally"><a href="#finally" class="headerlink" title="finally()"></a><code>finally()</code></h5><p>也是原型方法，实现起来也是简单封装</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">finally</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(callback, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="resolve"><a href="#resolve" class="headerlink" title="resolve()"></a><code>resolve()</code></h5><p>静态方法，返回一个<code>resolved</code>状态的<code>Promise</code>对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="title function_">resolve</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(val);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h5 id="reject"><a href="#reject" class="headerlink" title="reject()"></a><code>reject()</code></h5><p>静态方法，返回一个<code>rejected</code>状态的<code>Promise</code>对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="title function_">reject</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">reject</span>(val);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h5 id="all"><a href="#all" class="headerlink" title="all()"></a><code>all()</code></h5><p>静态方法，返回一个promise对象，作用在上面有提到</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="title function_">all</span>(<span class="params">promiseList</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> result = [];</span><br><span class="line">      <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">      promiseList.<span class="title function_">forEach</span>(<span class="function">(<span class="params">promise, index</span>) =&gt;</span> &#123;</span><br><span class="line">        promise.<span class="title function_">then</span>(</span><br><span class="line">          <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">            result[index] = data;</span><br><span class="line">            <span class="keyword">if</span> (++count === promiseList.<span class="property">length</span>) &#123;</span><br><span class="line">              <span class="title function_">resolve</span>(result);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">reject</span>(err);</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这个静态方法比上面的要相对复杂，我们依次执行传入的<code>Promise</code>数组中的<code>Promise</code>的<code>then()</code>,当所有的<code>onResolved</code>都被执行之后才执行返回的Promise的<code>resolve</code>，一旦数组中的<code>Promise</code>有进入<code>reject</code>状态（即then中<code>onRejected</code>执行了），立即执行返回的<code>Promise</code>中的<code>reject</code></p>
<h5 id="race"><a href="#race" class="headerlink" title="race()"></a><code>race()</code></h5><p>这是一个静态方法，同样返回一个<code>promise</code>，作用上面提到过</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="title function_">race</span>(<span class="params">promiseList</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      promiseList.<span class="title function_">forEach</span>(<span class="function">(<span class="params">promise</span>) =&gt;</span> &#123;</span><br><span class="line">        promise.<span class="title function_">then</span>(resolve, reject);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>直接把返回<code>Promise</code>的<code>resolve</code>和<code>reject</code>传给then,当数组中其中任意一个<code>Promise</code>的状态改变时就会触发<code>resolve</code>或者<code>reject</code>从而影响返回的<code>Promise</code>的状态</p>
<h5 id="allSettled"><a href="#allSettled" class="headerlink" title="allSettled()"></a><code>allSettled()</code></h5><p>这是一个静态方法，方法返回一个在所有给定的 promise 都已经<code>fulfilled</code>或<code>rejected</code>后的 promise，并带有一个对象数组，每个对象表示对应的 promise 结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="title function_">allSettled</span>(<span class="params">promiseList</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      promiseList.<span class="title function_">forEach</span>(<span class="function">(<span class="params">promise, index</span>) =&gt;</span> &#123;</span><br><span class="line">        promise.<span class="title function_">then</span>(</span><br><span class="line">          <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">            result.<span class="title function_">push</span>(&#123; <span class="attr">data</span>: value, <span class="attr">status</span>: <span class="string">&quot;Fulfilled&quot;</span> &#125;);</span><br><span class="line">            <span class="keyword">if</span> (result.<span class="property">length</span> === promiseList.<span class="property">length</span>) &#123;</span><br><span class="line">              <span class="title function_">resolve</span>(result);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">            result.<span class="title function_">push</span>(&#123; <span class="attr">data</span>: reason, <span class="attr">status</span>: <span class="string">&quot;Rejected&quot;</span> &#125;);</span><br><span class="line">            <span class="keyword">if</span> (result.<span class="property">length</span> === promiseList.<span class="property">length</span>) &#123;</span><br><span class="line">              <span class="title function_">resolve</span>(result);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>到此为止，我们较为完整地实现了一个<code>Promise</code>对象，源码如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LyPromise</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">    <span class="comment">// console.log(&quot;constructor执行&quot;);</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reason</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">status</span> = <span class="string">&quot;pending&quot;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onResolvedCallback</span> = [];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onRejectedCallback</span> = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> executor !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Promise resolver undefined is not a function&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">resolve</span> = (<span class="params">value</span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">status</span> = <span class="string">&quot;resolved&quot;</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">onResolvedCallback</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">callback</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">callback</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">reject</span> = (<span class="params">reason</span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">status</span> = <span class="string">&quot;rejected&quot;</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">reason</span> = reason;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">onRejectedCallback</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">callback</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">callback</span>(<span class="variable language_">this</span>.<span class="property">reason</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// console.log(&quot;现在执行executor&quot;);</span></span><br><span class="line">      <span class="title function_">executor</span>(resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="title function_">reject</span>(err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">then</span>(<span class="params">onResolved, onRejected</span>) &#123;</span><br><span class="line">    onResolved =</span><br><span class="line">      <span class="keyword">typeof</span> onResolved === <span class="string">&quot;function&quot;</span></span><br><span class="line">        ? onResolved</span><br><span class="line">        : <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">          &#125;;</span><br><span class="line">    onRejected =</span><br><span class="line">      <span class="keyword">typeof</span> onRejected === <span class="string">&quot;function&quot;</span></span><br><span class="line">        ? onRejected</span><br><span class="line">        : <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> reason;</span><br><span class="line">          &#125;;</span><br><span class="line">    <span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="title class_">LyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="string">&quot;resolved&quot;</span>) &#123;</span><br><span class="line">        process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = <span class="title function_">onResolved</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">            <span class="title function_">resolvePromise</span>(promise2, x, resolve, reject);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(err);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="string">&quot;rejected&quot;</span>) &#123;</span><br><span class="line">        process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>);</span><br><span class="line">            <span class="title function_">resolvePromise</span>(promise2, x, resolve, reject);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(err);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">onResolvedCallback</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">let</span> x = <span class="title function_">onResolved</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">              <span class="title function_">resolvePromise</span>(promise2, x, resolve, reject);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">              <span class="title function_">reject</span>(err);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">onRejectedCallback</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">let</span> x = <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>);</span><br><span class="line">              <span class="title function_">resolvePromise</span>(promise2, x, resolve, reject);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">              <span class="title function_">reject</span>(err);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> promise2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">catch</span>(onRejected) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(<span class="literal">null</span>, onRejected);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">finally</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(callback, callback);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">resolve</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(val);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">reject</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">reject</span>(val);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">all</span>(<span class="params">promiseList</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> result = [];</span><br><span class="line">      <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">      promiseList.<span class="title function_">forEach</span>(<span class="function">(<span class="params">promise, index</span>) =&gt;</span> &#123;</span><br><span class="line">        promise.<span class="title function_">then</span>(</span><br><span class="line">          <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">            result[index] = data;</span><br><span class="line">            <span class="keyword">if</span> (++count === promiseList.<span class="property">length</span>) &#123;</span><br><span class="line">              <span class="title function_">resolve</span>(result);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">reject</span>(err);</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">race</span>(<span class="params">promiseList</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      promiseList.<span class="title function_">forEach</span>(<span class="function">(<span class="params">promise</span>) =&gt;</span> &#123;</span><br><span class="line">        promise.<span class="title function_">then</span>(resolve, reject);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">allSettled</span>(<span class="params">promiseList</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      promiseList.<span class="title function_">forEach</span>(<span class="function">(<span class="params">promise, index</span>) =&gt;</span> &#123;</span><br><span class="line">        promise.<span class="title function_">then</span>(</span><br><span class="line">          <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">            result.<span class="title function_">push</span>(&#123; <span class="attr">data</span>: value, <span class="attr">status</span>: <span class="string">&quot;Fulfilled&quot;</span> &#125;);</span><br><span class="line">            <span class="keyword">if</span> (result.<span class="property">length</span> === promiseList.<span class="property">length</span>) &#123;</span><br><span class="line">              <span class="title function_">resolve</span>(result);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">            result.<span class="title function_">push</span>(&#123; <span class="attr">data</span>: reason, <span class="attr">status</span>: <span class="string">&quot;Rejected&quot;</span> &#125;);</span><br><span class="line">            <span class="keyword">if</span> (result.<span class="property">length</span> === promiseList.<span class="property">length</span>) &#123;</span><br><span class="line">              <span class="title function_">resolve</span>(result);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">resolvePromise</span> = (<span class="params">promise2, x, resolve, reject</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> used = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (x === promise2) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Chaining cycle detected for promise!&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (x != <span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> x === <span class="string">&quot;function&quot;</span> || <span class="keyword">typeof</span> x === <span class="string">&quot;object&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> then = x.<span class="property">then</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        then.<span class="title function_">call</span>(</span><br><span class="line">          x,</span><br><span class="line">          <span class="function">(<span class="params">y</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (used) &#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            used = <span class="literal">true</span>;</span><br><span class="line">            <span class="title function_">resolvePromise</span>(promise2, y, resolve, reject);</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="function">(<span class="params">r</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (used) &#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            used = <span class="literal">true</span>;</span><br><span class="line">            <span class="title function_">reject</span>(r);</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(x);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="keyword">if</span> (used) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      used = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">      <span class="title function_">reject</span>(err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">LyPromise</span>.<span class="property">deferred</span> = <span class="title class_">LyPromise</span>.<span class="property">defer</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> dfd = &#123;&#125;;</span><br><span class="line">  dfd.<span class="property">promise</span> = <span class="keyword">new</span> <span class="title class_">LyPromise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    dfd.<span class="property">resolve</span> = resolve;</span><br><span class="line">    dfd.<span class="property">reject</span> = reject;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> dfd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title class_">LyPromise</span>;</span><br></pre></td></tr></table></figure>

<h3 id="chapter3-相关知识"><a href="#chapter3-相关知识" class="headerlink" title="chapter3 相关知识"></a>chapter3 相关知识</h3><h4 id="同步？异步？"><a href="#同步？异步？" class="headerlink" title="同步？异步？"></a>同步？异步？</h4><p>考虑一下，下面的代码会输出什么？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;3&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>会是123吗，运行一下，结果是132，为什么呢？</p>
<p>事实上这是因为<code>setTimeout</code>是一种异步操作。那什么是异步呢？</p>
<p>首先，JavaScript是一门单线程语言，它无法像多线程语言那样采用开启多个线程的方式同时处理多个任务。也就是说，代码是从上到下依次执行下去的，但如果所有的代码都是这样从上往下依次执行的话，必然会导致一些代码阻塞的问题，如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//非常耗时的任务</span></span><br><span class="line">&#125;,<span class="number">1000000000</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;其他任务&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>如果代码都是从上往下进行的话，必须要等上面非常耗时的任务完成之后才能执行其他工作，这显然是不合理的，因为其他任务很可能不依赖这些耗时任务是否完成。为了解决这个问题，JavaScript引入了异步的概念，并把一些耗时的操作归于异步操作。</p>
<h4 id="宏任务？微任务？"><a href="#宏任务？微任务？" class="headerlink" title="宏任务？微任务？"></a>宏任务？微任务？</h4><p>我们在实现Promise时还提到了要把then中的方法包装成微任务去执行，那么什么是微任务呢？他和我们所说的任务（宏任务）有哪些区别呢？先看下面的代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;宏任务完成&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p1=<span class="keyword">new</span> <span class="title class_">LyPromise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">  <span class="title function_">resolve</span>()</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;微任务完成&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>我们知道Promise中的函数会立即执行，所以先输出ok，那么接下来呢，<code>then</code>和<code>setTimeout</code>都是异步的，所以就先输出<code>setTimeout</code>中的内容吗，运行一下代码，我们发现输出顺序为<code>ok</code>-&gt;<code>微任务完成</code>-&gt;<code>宏任务完成</code>，与我们的经验不一样。很明显这是因为我们给<code>then</code>中的函数设定为了一个微任务，那么微任务是在什么条件下会执行呢？</p>
<h4 id="异步的原理：事件循环"><a href="#异步的原理：事件循环" class="headerlink" title="异步的原理：事件循环"></a>异步的原理：事件循环</h4><p>引出了异步的概念，你可能还是不理解上面的代码为什么会输出132，明明没有为<code>setTimeout</code>设置时间呀？这里就要引出JavaScript的异步原理——事件循环了</p>
<p>首先先明确一下事件循环中的几个概念</p>
<ul>
<li>调用栈（call stack）</li>
<li>消息队列（message queue）</li>
<li>微任务队列（microtask queue）</li>
</ul>
<p>下面解释事件循环的过程</p>
<p>首先，js代码会从上往下执行，遇到函数时，会把函数压入调用栈中，根据函数的类型，js会选择是否执行函数体的内容，如果函数是同步的，直接执行函数体中的内容，执行完之后，函数出栈。如果是异步函数，例如<code>setTimeout</code>，会把其回调函数压入消息队列中，异步函数再出栈。如果是微任务函数，把回调压入微任务队列，出栈。这样一直下去，直到调用栈为空（不再有函数被压入栈），微任务队列中的回调函数会依次进入调用栈开始执行，这个过程中如果还有微任务被添加也会立即执行。微任务执行完之后，消息队列中的任务开始进入调用栈，依次调用。</p>
<p>这样就能解释上面代码的输出了</p>
<p>我们来看一下第一串代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;3&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>执行过程：</p>
<ul>
<li><code>console.log()</code>入栈</li>
<li>执行<code>console.log(&#39;1&#39;)</code>,输出1</li>
<li><code>console.log()</code>出栈</li>
<li><code>setTimeout()</code>入栈</li>
<li><code>setTimeout()</code>是异步函数，其中的回调<code>() =&gt; &#123; console.log(&#39;2&#39;) &#125;</code>进入消息队列</li>
<li><code>setTimeout</code>出栈</li>
<li><code>console.log()</code>入栈</li>
<li>执行<code>console.log(&#39;3&#39;)</code>,输出3</li>
<li><code>console.log()</code>出栈</li>
<li>没有函数再进入调用栈，微任务队列为空，将消息队列中的<code>() =&gt; &#123; console.log(&#39;2&#39;) &#125;</code>压入调用栈</li>
<li>执行<code>() =&gt; &#123; console.log(&#39;2&#39;) &#125;</code>，输出2</li>
</ul>
<p>再看第二串代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;宏任务完成&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p1=<span class="keyword">new</span> <span class="title class_">LyPromise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">  <span class="title function_">resolve</span>()</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;微任务完成&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>执行过程</p>
<ul>
<li><code>setTimeout()</code>入栈</li>
<li><code>setTimeout()</code>中的回调进入消息队列</li>
<li><code>setTimeout()</code>出栈</li>
<li><code>LyPromise</code>的<code>constructor()</code>入栈</li>
<li><code>constructor()</code>为同步内容，执行其中内容</li>
<li><code>constructor</code>中的<code>executor()</code>入栈</li>
<li>执行<code>executor()</code></li>
<li><code>console.log(&#39;ok&#39;)</code>入栈</li>
<li>执行<code>console.log(&quot;ok&quot;)</code>,输出ok</li>
<li><code>console.log(&#39;ok&#39;)</code>出栈</li>
<li><code>resolve()</code>入栈</li>
<li>执行<code>resolve()</code></li>
<li><code>resolve()</code>出栈</li>
<li><code>excutor()</code>出栈</li>
<li><code>constructor()</code>出栈</li>
<li><code>p1.then()</code>入栈</li>
<li><code>then()</code>中回调进入微任务队列</li>
<li><code>p1.then()</code>出栈</li>
<li>此时调用栈为空，先查看微任务队列，将函数压入调用栈中</li>
<li>执行函数，输出<code>微任务完成</code></li>
<li>没有微任务再被添加，查看消息队列，将函数压入调用栈</li>
<li>执行函数，输出<code>宏任务完成</code></li>
</ul>
<p>相信你一定能够自己分析出下面代码的输出吧！</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="number">5</span>)</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">        </span><br><span class="line">        <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">6</span>)</span><br><span class="line">        &#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">7</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">8</span>)</span><br><span class="line">            &#125;, <span class="number">0</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">9</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>();</span><br></pre></td></tr></table></figure>

<p>执行结果是：1,4,10,5,6,7,2,3,9,8</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>异步</tag>
      </tags>
  </entry>
  <entry>
    <title>React入门笔记</title>
    <url>/2022/10/16/React%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="React入门笔记"><a href="#React入门笔记" class="headerlink" title="React入门笔记"></a>React入门笔记</h3><p>这篇笔记对应React官方文档中&#x3D;&#x3D;核心概念&#x3D;&#x3D;部分内容，网址：<a href="https://zh-hans.reactjs.org/docs/hello-world.html">https://zh-hans.reactjs.org/docs/hello-world.html</a></p>
<h4 id="引入React和JSX"><a href="#引入React和JSX" class="headerlink" title="引入React和JSX"></a>引入React和JSX</h4><p>入门时直接使用<code>script</code>标签的方式引入，但在React开发中使用JSX语法在编写模板时会方便很多，因此可以使用babel对JSX语法进行解析，同样使用<code>script</code>标签引入</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span></span></span><br><span class="line"><span class="tag">     <span class="attr">crossorigin</span></span></span><br><span class="line"><span class="tag">     <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react@18/umd/react.development.js&quot;</span></span></span><br><span class="line"><span class="tag">   &gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">script</span></span></span><br><span class="line"><span class="tag">     <span class="attr">crossorigin</span></span></span><br><span class="line"><span class="tag">     <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react-dom@18/umd/react-dom.development.js&quot;</span></span></span><br><span class="line"><span class="tag">   &gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/babel-standalone@6/babel.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>引入编写的script标签时要添加type属性</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;index.js&quot;</span> <span class="attr">async</span> <span class="attr">defer</span> <span class="attr">type</span>=<span class="string">&quot;text/babel&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>JSX语法<ul>
<li>入门的话只需要了解<code>&#123;&#125;</code>引入表达式</li>
</ul>
</li>
</ul>
<h4 id="创建一个根元素"><a href="#创建一个根元素" class="headerlink" title="创建一个根元素"></a>创建一个根元素</h4><p>首先我们需要在HTML模板中创建一个根标签</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后设置根元素</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> root = <span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>然后可以为根元素声明渲染的模板</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root.render(&lt;div&gt;helloworld&lt;div&gt;)</span><br></pre></td></tr></table></figure>

<p>这样在根标签下就渲染出了一个以helloworld为内容的div</p>
<p>如果想要更新渲染的内容的话，可以重新渲染，但不推荐这么做，有更好的处理方式</p>
<h4 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h4><p>vue和react组件具有相似之处</p>
<h5 id="声明组件"><a href="#声明组件" class="headerlink" title="声明组件"></a>声明组件</h5><p>声明组件可以用函数形式也可以用创建类的形式，下面演示后者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class HelloWorld extends React.Component &#123;</span><br><span class="line"> render() &#123;</span><br><span class="line">     return (</span><br><span class="line">         &lt;h1&gt;hello world&lt;/h1&gt;</span><br><span class="line">     )</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们需要让声明的类继承<code>React.Component</code>,它便是一个有效的react组件</p>
<p>然后通过<code>render</code>方法声明组件要渲染的html模板</p>
<p>然后我们可以把组件挂载到根元素上</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="language-xml"><span class="tag">&lt;<span class="name">HelloWorld</span>&gt;</span><span class="tag">&lt;/<span class="name">HelloWorld</span>&gt;</span></span>;</span><br><span class="line">root.<span class="title function_">render</span>(element);</span><br></pre></td></tr></table></figure>

<h5 id="使用props"><a href="#使用props" class="headerlink" title="使用props"></a>使用props</h5><p>和vue组件一样，react组件也可以使用props,在class式声明中使用<code>this.props.&lt;name&gt;</code>使用props,如</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HelloWorld</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line"> <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> (</span><br><span class="line">         <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;this.props.title&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">     )</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后使用时指定属性值就行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="language-xml"><span class="tag">&lt;<span class="name">HelloWorld</span> <span class="attr">title</span>=<span class="string">&quot;helloworld&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">HelloWorld</span>&gt;</span></span>;</span><br><span class="line">root.<span class="title function_">render</span>(element);</span><br></pre></td></tr></table></figure>

<p>hellowrold将显示在屏幕上</p>
<p>和vue一样，react组件也不能修改props的值</p>
<h4 id="state"><a href="#state" class="headerlink" title="state"></a>state</h4><p>react使用<code>state</code>来更新组件</p>
<h5 id="设置一个初始state"><a href="#设置一个初始state" class="headerlink" title="设置一个初始state"></a>设置一个初始state</h5><p>我们引入构造函数来初始化state</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">date</span>: <span class="keyword">new</span> <span class="title class_">Date</span>(),</span><br><span class="line">      <span class="attr">title</span>: <span class="string">&quot;YEAH!!&quot;</span>,</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>类似于vue中的data,这里定义了date和title的初始值</p>
<h5 id="使用state"><a href="#使用state" class="headerlink" title="使用state"></a>使用state</h5><p>和props的用法类似，我们使用<code>this.state.&lt;name&gt;</code>来使用state</p>
<h5 id="修改state"><a href="#修改state" class="headerlink" title="修改state"></a>修改state</h5><p>和小程序中的<code>setdata</code>类似，我们可以使用<code>this.setState</code>来修改state的值，但和vue中不同的是，不能直接通过<code>this.state</code>来修改。修改state可以用对象式和函数式（当要用到props等参数时）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">    <span class="attr">title</span>:<span class="string">&quot;hello&quot;</span>,</span><br><span class="line">&#125;)<span class="comment">//对象式</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function">(<span class="params">state,props</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">title</span>:props.<span class="property">title</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)<span class="comment">//函数式</span></span><br></pre></td></tr></table></figure>

<h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>react中也有生命周期的概念，这里介绍两个生命周期函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;&#125;<span class="comment">//在组件渲染到dom后运行</span></span><br><span class="line"><span class="title function_">componentWillUnmount</span>(<span class="params"></span>) &#123;&#125;<span class="comment">//当组件发生更改或被销毁取消挂载时使用</span></span><br></pre></td></tr></table></figure>

<h4 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h4><h5 id="注册事件"><a href="#注册事件" class="headerlink" title="注册事件"></a>注册事件</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;事件处理函数&#125;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>事件处理函数中编写要处理的内容</p>
<p>事件处理函数默认可以传入一个参数e,和传统网页开发中的用法相同</p>
<p>react事件中只能通过<code>e.preventDefault</code>来禁止默认行为</p>
<p>定义好的事件处理函数还要在构造函数中改变this指向才可以正常使用this,按照下面这种模板即可</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">changeTitle</span> = <span class="variable language_">this</span>.<span class="property">changeTitle</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br></pre></td></tr></table></figure>

<h4 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h4><p>和vue使用v-if在html中实现条件渲染不同，在react中仍使用if等条件控制语句控制render方法的返回值实现条件渲染</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">islogin</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Login</span>&gt;</span><span class="tag">&lt;/<span class="name">Login</span>&gt;</span></span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Greet</span>&gt;</span><span class="tag">&lt;/<span class="name">Greet</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之间返回null可以起到阻止渲染的作用</p>
<h4 id="列表渲染和key"><a href="#列表渲染和key" class="headerlink" title="列表渲染和key"></a>列表渲染和key</h4><p>可以使用数组的map方法定义出一个“模板数组”，和vue一样最好指定唯一的key值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> list = numList.<span class="title function_">map</span>(<span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;num.toString()&#125;</span>&gt;</span>&#123;num&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>;</span><br><span class="line">          &#125;);</span><br><span class="line">          <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                &#123;list&#125;</span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>当然JSX也可以直接嵌入map</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123;numList.map((num) =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">            return <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;num.toString()&#125;</span>&gt;</span>&#123;num&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span>;</span></span><br><span class="line"><span class="language-xml">          &#125;)&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="表单控件处理"><a href="#表单控件处理" class="headerlink" title="表单控件处理"></a>表单控件处理</h4><p>通过指定表单的value为state里的变量，再监听表单的change事件改变这个变量实现一种双向绑定</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">value</span>=<span class="string">&#123;this.state.value&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;this.handleChange&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">handleChange</span>(<span class="params">e</span>) &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">            <span class="attr">value</span>:e.<span class="property">target</span>.<span class="property">value</span>,</span><br><span class="line">          &#125;)</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">value</span>)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h4 id="向子组件传入模板"><a href="#向子组件传入模板" class="headerlink" title="向子组件传入模板"></a>向子组件传入模板</h4><p>和vue中的插槽类似，在react也可以向子组件传入模板</p>
<p>在子组件中使用<code>this.props.children</code>定义模板所在的位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">          return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">              &#123;this.props.children&#125;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>然后父组件在渲染子组件时可以传入模板</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">          return (</span><br><span class="line">            &lt;Child&gt;</span><br><span class="line">              &lt;h1&gt;HELLO&lt;/h1&gt;</span><br><span class="line">            &lt;/Child&gt;</span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>如果需要在不同地方使用多个模板呢，我们可以不使用children而使用自己定义的内容是JSX的props传递给子组件</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL入门笔记</title>
    <url>/2022/10/15/SQL/</url>
    <content><![CDATA[<h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><h4 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--从某个表中查询所有数据</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="operator">&lt;</span>tablename<span class="operator">&gt;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--条件查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="operator">&lt;</span>tablename<span class="operator">&gt;</span> <span class="keyword">WHERE</span> <span class="operator">&lt;</span><span class="keyword">condition</span><span class="operator">&gt;</span></span><br><span class="line"><span class="comment">--并条件</span></span><br><span class="line"><span class="operator">&lt;</span>condition1<span class="operator">&gt;</span> <span class="keyword">AND</span> <span class="operator">&lt;</span>condition2<span class="operator">&gt;</span></span><br><span class="line"><span class="comment">--或条件</span></span><br><span class="line"><span class="operator">&lt;</span>condition1<span class="operator">&gt;</span> <span class="keyword">OR</span> <span class="operator">&lt;</span>condition2<span class="operator">&gt;</span></span><br><span class="line"><span class="comment">--非条件</span></span><br><span class="line"><span class="keyword">NOT</span> <span class="operator">&lt;</span><span class="keyword">condition</span><span class="operator">&gt;</span></span><br><span class="line"><span class="comment">--多条件混用</span></span><br><span class="line">(<span class="operator">&lt;</span>condition1<span class="operator">&gt;</span> <span class="keyword">AND</span> <span class="operator">&lt;</span>condition2<span class="operator">&gt;</span>) <span class="keyword">OR</span> <span class="operator">&lt;</span>condition3<span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--投影查询</span></span><br><span class="line"><span class="keyword">SELECT</span> column1,column2... <span class="keyword">FROM</span> <span class="operator">&lt;</span>tablename<span class="operator">&gt;</span></span><br><span class="line"><span class="comment">--投影查询并起别名</span></span><br><span class="line"><span class="keyword">SELECT</span> column1 shortname1,column2... <span class="keyword">FROM</span> <span class="operator">&lt;</span>tablename<span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--排序</span></span><br><span class="line"><span class="comment">--根据某列的值排序</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="operator">&lt;</span>tablename<span class="operator">&gt;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">&lt;</span><span class="keyword">column</span><span class="operator">&gt;</span> </span><br><span class="line"><span class="comment">--升序/降序排列</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="operator">&lt;</span>tablename<span class="operator">&gt;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">&lt;</span><span class="keyword">COLUMN</span><span class="operator">&gt;</span> <span class="operator">&lt;</span><span class="keyword">DESC</span><span class="operator">/</span><span class="keyword">ASC</span><span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--分页查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="operator">&lt;</span>tablename<span class="operator">&gt;</span> LIMIT <span class="operator">&lt;</span>num<span class="operator">&gt;</span> <span class="keyword">OFFSET</span> <span class="operator">&lt;</span>num<span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--聚合查询</span></span><br><span class="line"><span class="comment">--查询记录数目</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> <span class="operator">&lt;</span>tablename<span class="operator">&gt;</span>;</span><br><span class="line"><span class="comment">--设置别名</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&lt;</span>SHORTNAME<span class="operator">&gt;</span> <span class="keyword">FROM</span> <span class="operator">&lt;</span>tablename<span class="operator">&gt;</span>;</span><br><span class="line"><span class="comment">--查询合计值</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> <span class="operator">&lt;</span>tablename<span class="operator">&gt;</span> ;</span><br><span class="line"><span class="comment">--查询平均值</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> <span class="operator">&lt;</span>tablename<span class="operator">&gt;</span>;</span><br><span class="line"><span class="comment">--查询最大值</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> <span class="operator">&lt;</span>tablename<span class="operator">&gt;</span>;</span><br><span class="line"><span class="comment">--查询最小值</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MIN</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> <span class="operator">&lt;</span>tablename<span class="operator">&gt;</span>;</span><br><span class="line"><span class="comment">--分组聚合</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> <span class="operator">&lt;</span>tablename<span class="operator">&gt;</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>COLUMN1<span class="operator">&gt;</span>,<span class="operator">&lt;</span>column2<span class="operator">&gt;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--多表查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="operator">&lt;</span>tablename1<span class="operator">&gt;</span>,<span class="operator">&lt;</span>tablename2<span class="operator">&gt;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--连接查询</span></span><br><span class="line"><span class="comment">--符合condition的行被连接起来</span></span><br><span class="line"><span class="keyword">SELECT</span> shortname.colunmname <span class="keyword">from</span> <span class="operator">&lt;</span>table1<span class="operator">&gt;</span> shortname <span class="keyword">inner</span> <span class="keyword">join</span> <span class="operator">&lt;</span>table2<span class="operator">&gt;</span> <span class="keyword">on</span> <span class="operator">&lt;</span><span class="keyword">condition</span><span class="operator">&gt;</span>;</span><br><span class="line"><span class="comment">--显示右表全部</span></span><br><span class="line"><span class="keyword">SELECT</span> shortname.colunmname <span class="keyword">from</span> <span class="operator">&lt;</span>table1<span class="operator">&gt;</span> shortname <span class="keyword">right</span> <span class="keyword">outer</span> <span class="keyword">join</span> <span class="operator">&lt;</span>table2<span class="operator">&gt;</span> <span class="keyword">on</span> <span class="operator">&lt;</span><span class="keyword">condition</span><span class="operator">&gt;</span>;</span><br><span class="line"><span class="comment">--显示左表全部</span></span><br><span class="line"><span class="keyword">SELECT</span> shortname.colunmname <span class="keyword">from</span> <span class="operator">&lt;</span>table1<span class="operator">&gt;</span> shortname <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> <span class="operator">&lt;</span>table2<span class="operator">&gt;</span> <span class="keyword">on</span> <span class="operator">&lt;</span><span class="keyword">condition</span><span class="operator">&gt;</span>;</span><br><span class="line"><span class="comment">--显示全部</span></span><br><span class="line"><span class="keyword">SELECT</span> shortname.colunmname <span class="keyword">from</span> <span class="operator">&lt;</span>table1<span class="operator">&gt;</span> shortname <span class="keyword">full</span> <span class="keyword">outer</span> <span class="keyword">join</span> <span class="operator">&lt;</span>table2<span class="operator">&gt;</span> <span class="keyword">on</span> <span class="operator">&lt;</span><span class="keyword">condition</span><span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> INFO <span class="operator">&lt;</span>TABLENAME<span class="operator">&gt;</span> (<span class="operator">&lt;</span>COLUMN1<span class="operator">&gt;</span>,<span class="operator">&lt;</span>COLUMN2<span class="operator">&gt;</span>...) <span class="keyword">VALUES</span> (<span class="operator">&lt;</span>INFO1<span class="operator">&gt;</span>,<span class="operator">&lt;</span>INFO2<span class="operator">&gt;</span>...)...;</span><br></pre></td></tr></table></figure>

<h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="operator">&lt;</span>TABLENAME<span class="operator">&gt;</span> <span class="keyword">SET</span> <span class="operator">&lt;</span>NAME1<span class="operator">&gt;=</span><span class="operator">&lt;</span>VLAUE1<span class="operator">&gt;</span>,<span class="operator">&lt;</span>NAME2<span class="operator">&gt;=</span><span class="operator">&lt;</span>VALUE2<span class="operator">&gt;</span>...<span class="keyword">WHERE</span> <span class="operator">&lt;</span><span class="keyword">CONDITION</span><span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="operator">&lt;</span>TABLENAME<span class="operator">&gt;</span> <span class="keyword">WHERE</span> <span class="operator">&lt;</span><span class="keyword">CONDITION</span><span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>速查</tag>
        <tag>入门</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP/IP知识点总结</title>
    <url>/2022/10/12/TCP_IP/</url>
    <content><![CDATA[<h1 id="TCP-x2F-IP"><a href="#TCP-x2F-IP" class="headerlink" title="TCP&#x2F;IP"></a>TCP&#x2F;IP</h1><h2 id="第一章-网络基础知识"><a href="#第一章-网络基础知识" class="headerlink" title="第一章 网络基础知识"></a>第一章 网络基础知识</h2><h3 id="1-1-计算机网络出现的背景"><a href="#1-1-计算机网络出现的背景" class="headerlink" title="1.1 计算机网络出现的背景"></a>1.1 计算机网络出现的背景</h3><h4 id="1-1-1-计算机的普及及多样化"><a href="#1-1-1-计算机的普及及多样化" class="headerlink" title="1.1.1 计算机的普及及多样化"></a>1.1.1 计算机的普及及多样化</h4><p>如题</p>
<h4 id="1-1-2-从独立模式到网络互连模式"><a href="#1-1-2-从独立模式到网络互连模式" class="headerlink" title="1.1.2 从独立模式到网络互连模式"></a>1.1.2 从独立模式到网络互连模式</h4><ul>
<li>独立模式（单机模式）：计算机未接入网络，各自独立使用的模式</li>
<li>网络互联模式：<ul>
<li>WAN: 广域网</li>
<li>MAN: 城域网</li>
<li>LAN: 局域网</li>
</ul>
</li>
</ul>
<h3 id="1-2-计算机与网络发展的七个阶段"><a href="#1-2-计算机与网络发展的七个阶段" class="headerlink" title="1.2 计算机与网络发展的七个阶段"></a>1.2 计算机与网络发展的七个阶段</h3><h4 id="1-2-1-批处理"><a href="#1-2-1-批处理" class="headerlink" title="1.2.1 批处理"></a>1.2.1 批处理</h4><p>事先将用户程序和数据装入卡带或磁带，并由计算机按照一定的顺序读取，使程序和数据能够批量得到处理的方式</p>
<p>此时计算机还不是普通人使用的工具</p>
<h4 id="1-2-2-分时系统"><a href="#1-2-2-分时系统" class="headerlink" title="1.2.2 分时系统"></a>1.2.2 分时系统</h4><p>分时系统（TSS）指多台终端与同一个计算机相连，允许多个用户同时使用一台计算机系统</p>
<h4 id="1-2-3-计算机间的通信"><a href="#1-2-3-计算机间的通信" class="headerlink" title="1.2.3 计算机间的通信"></a>1.2.3 计算机间的通信</h4><p>分时系统中，一台计算机与多个终端相连，但计算机之间是不能相连的，这时候如果需要转移数据，需要将数据保存在软盘，磁带等介质中，再将介质送到目的计算机，相当繁琐</p>
<p>计算机间的通信技术（计算机与计算机之间由通信链路相连）使人们能很轻松的读取另一台计算机中的数据，极大的缩短了传送数据的时间</p>
<h3 id="1-3-协议"><a href="#1-3-协议" class="headerlink" title="1.3 协议"></a>1.3 协议</h3><p>在计算机通信中，实现达成一个详细的约定，并遵循这一约定进行处理。这种约定就是”协议“</p>
<h4 id="1-3-5-分组交换协议"><a href="#1-3-5-分组交换协议" class="headerlink" title="1.3.5 分组交换协议"></a>1.3.5 分组交换协议</h4><p>分组交换是指将大数据分割成一个个交包（packet）的较小单位进行传输的方法。</p>
<h3 id="1-5-协议分层与OSI参考模型"><a href="#1-5-协议分层与OSI参考模型" class="headerlink" title="1.5 协议分层与OSI参考模型"></a>1.5 协议分层与OSI参考模型</h3><h4 id="1-5-1-协议的分层"><a href="#1-5-1-协议的分层" class="headerlink" title="1.5.1 协议的分层"></a>1.5.1 协议的分层</h4><p>ISO制定标准化OSI之前，提出了作为通信协议设计指标的OSI参考模型,这一模型将通信协议中必要的功能分为了七层</p>
<p>每一分层接收由它下一分层提供的特定服务，并为自己的上一层提供特定服务。上下层之间交互时遵循的约定叫”接口“，同一层之间交互所遵循的约定叫”协议“</p>
<h4 id="1-5-3-OSI参考模型"><a href="#1-5-3-OSI参考模型" class="headerlink" title="1.5.3 OSI参考模型"></a>1.5.3 OSI参考模型</h4><p>OSI参考模型将分组通信协议整理并分为了易于理解的七个分层</p>
<ul>
<li>7.应用层：针对特定应用的协议</li>
<li>6.表示层：设备固有数据格式和网络标准数据格式的转换</li>
<li>5.会话层：通信管理。负责建立和断开通信连接。管理传输层以下的分层</li>
<li>4.传输层：管理两个节点之间的数据传输，负责可靠传输</li>
<li>3.网络层：地址管理和路由选择</li>
<li>2.数据链路层：互连设备之间传送和识别数据帧</li>
<li>1.物理层：以”0“，”1“代表电压的高低，灯光的闪灭。界定连接器和网线的规格</li>
</ul>
<h3 id="1-7-传输方式的分类"><a href="#1-7-传输方式的分类" class="headerlink" title="1.7 传输方式的分类"></a>1.7 传输方式的分类</h3><h4 id="1-7-1-面向有连接型和无连接型"><a href="#1-7-1-面向有连接型和无连接型" class="headerlink" title="1.7.1 面向有连接型和无连接型"></a>1.7.1 面向有连接型和无连接型</h4><ul>
<li>面向有连接型：在发送数据前，需要在收发主机之间连接一条通信链路</li>
<li>面向无连接型：不要求建立和断开连接，发送端可于任何时候自由发送数据。接收端不知道会在何时从哪里收到数据</li>
</ul>
<h4 id="1-7-2-电路交换和分组交换"><a href="#1-7-2-电路交换和分组交换" class="headerlink" title="1.7.2 电路交换和分组交换"></a>1.7.2 电路交换和分组交换</h4><ul>
<li>电路交换：两个计算机独占一条电路，其他计算机无法使用</li>
<li>分组交换：将数据分为一个个分组，多台计算机可以同时通信</li>
</ul>
<h4 id="1-7-3-根据接收端数量分类"><a href="#1-7-3-根据接收端数量分类" class="headerlink" title="1.7.3 根据接收端数量分类"></a>1.7.3 根据接收端数量分类</h4><ul>
<li>单播：一对一通信</li>
<li>广播：一台主机发送到与之相连的所有其他主机</li>
<li>多播：一台主机发送到与之相连的特定一组主机</li>
<li>任播：从特定的多台主机中选出一台进行通信</li>
</ul>
<h3 id="1-8-地址"><a href="#1-8-地址" class="headerlink" title="1.8 地址"></a>1.8 地址</h3><h4 id="1-8-1-地址的唯一性"><a href="#1-8-1-地址的唯一性" class="headerlink" title="1.8.1 地址的唯一性"></a>1.8.1 地址的唯一性</h4><p>同一个通信网络中不允许有两个相同地址的通信主体存在</p>
<h4 id="1-8-2-地址的层次性"><a href="#1-8-2-地址的层次性" class="headerlink" title="1.8.2 地址的层次性"></a>1.8.2 地址的层次性</h4><p>将地址分层从而实现更快速的定位</p>
<p>IP地址是分层的，MAC地址不分层</p>
<h3 id="1-9-网络构成要素"><a href="#1-9-网络构成要素" class="headerlink" title="1.9 网络构成要素"></a>1.9 网络构成要素</h3><h4 id="1-9-1-通信媒介与数据链路"><a href="#1-9-1-通信媒介与数据链路" class="headerlink" title="1.9.1 通信媒介与数据链路"></a>1.9.1 通信媒介与数据链路</h4><p>计算机之间通过电缆相互连接</p>
<p>根据数据链路（相互直连的设备之间进行通信所涉及的协议及网络）不同而选用的电缆类型也不尽相同</p>
<h4 id="1-9-2-网卡"><a href="#1-9-2-网卡" class="headerlink" title="1.9.2 网卡"></a>1.9.2 网卡</h4><p>任何一台计算机连接网络都必须使用网卡</p>
<h4 id="1-9-3-中继器"><a href="#1-9-3-中继器" class="headerlink" title="1.9.3 中继器"></a>1.9.3 中继器</h4><p>中继器是在OSI模型的第一层——物理层面延长网络的设备</p>
<p>由电缆传来的电信号或光信号通过中继器的波形调整和放大传给另一个电缆</p>
<p>中继器不能改变传输速率，是对减弱的信号进行放大的设备</p>
<p>中继器进行的网络延长并不能无限放大</p>
<p>有的中继器提供多个端口服务，也被成为集线器。集线器每个端口都可以看作一个中继器</p>
<h4 id="1-9-4-网桥-x2F-2层交换机"><a href="#1-9-4-网桥-x2F-2层交换机" class="headerlink" title="1.9.4 网桥&#x2F;2层交换机"></a>1.9.4 网桥&#x2F;2层交换机</h4><p>网桥是在OSI模型第二层——数据链路层面连接两个网络的设备</p>
<h4 id="1-9-5-路由器-x2F-3层交换机"><a href="#1-9-5-路由器-x2F-3层交换机" class="headerlink" title="1.9.5 路由器&#x2F;3层交换机"></a>1.9.5 路由器&#x2F;3层交换机</h4><p>路由器是在OSI模型的第三层——网络层面上连接两个网络，并对分组报文进行转发的设备</p>
<p>网桥根据MAC地址处理，而路由器根据IP地址处理</p>
<p>路由器还具有分担网络负荷的作用，有些路由器具有一定的网络安全功能</p>
<h4 id="1-9-6-4-7层交换机"><a href="#1-9-6-4-7层交换机" class="headerlink" title="1.9.6 4-7层交换机"></a>1.9.6 4-7层交换机</h4><p>4-7层交换机负责处理OSI模型中从传输层到应用层的数据</p>
<h4 id="1-9-7-网关"><a href="#1-9-7-网关" class="headerlink" title="1.9.7 网关"></a>1.9.7 网关</h4><p>网关是OSI参考模型中负责将传输层到应用层的协议的转换和数据的转发的设备</p>
<p>只转发数据的网关被成为应用网关。代理服务器就是应用网关</p>
<h3 id="1-10-现代网络实态"><a href="#1-10-现代网络实态" class="headerlink" title="1.10 现代网络实态"></a>1.10 现代网络实态</h3><p>由骨干网和边缘网络组成</p>
<h4 id="1-10-2-互联网通信"><a href="#1-10-2-互联网通信" class="headerlink" title="1.10.2 互联网通信"></a>1.10.2 互联网通信</h4><p>联网之后，汇集到无线局域网路由器和最近交换机的通信再次被连接到“接入层”。甚至通过“边缘网络”或“主干网”实现与目标地址之间的通信</p>
<h4 id="1-10-3-移动通信"><a href="#1-10-3-移动通信" class="headerlink" title="1.10.3 移动通信"></a>1.10.3 移动通信</h4><p>手机一开机就会自动与最近的基站进行无线通信。基站本身相当于网络中的“接入层”</p>
<p>手机终端之间的通信通过基站通信</p>
<hr>
<h2 id="第二章-TCP-x2F-IP基础知识"><a href="#第二章-TCP-x2F-IP基础知识" class="headerlink" title="第二章 TCP&#x2F;IP基础知识"></a>第二章 TCP&#x2F;IP基础知识</h2><h3 id="2-1-TCP-x2F-IP出现的背景及历史"><a href="#2-1-TCP-x2F-IP出现的背景及历史" class="headerlink" title="2.1 TCP&#x2F;IP出现的背景及历史"></a>2.1 TCP&#x2F;IP出现的背景及历史</h3><p>略</p>
<h3 id="2-2-TCP-x2F-IP的标准化"><a href="#2-2-TCP-x2F-IP的标准化" class="headerlink" title="2.2 TCP&#x2F;IP的标准化"></a>2.2 TCP&#x2F;IP的标准化</h3><h4 id="2-2-1-TCP-x2F-IP的具体含义"><a href="#2-2-1-TCP-x2F-IP的具体含义" class="headerlink" title="2.2.1 TCP&#x2F;IP的具体含义"></a>2.2.1 TCP&#x2F;IP的具体含义</h4><p>很多情况下，TCP&#x2F;IP协议指的是利用IP通信时所必须用到的协议群的统称</p>
<h4 id="2-2-2-TCP-x2F-IP标准化精髓"><a href="#2-2-2-TCP-x2F-IP标准化精髓" class="headerlink" title="2.2.2 TCP&#x2F;IP标准化精髓"></a>2.2.2 TCP&#x2F;IP标准化精髓</h4><ul>
<li>具有开放性</li>
<li>注重实用性</li>
</ul>
<h4 id="2-2-3-TCP-x2F-IP规范——RFC"><a href="#2-2-3-TCP-x2F-IP规范——RFC" class="headerlink" title="2.2.3 TCP&#x2F;IP规范——RFC"></a>2.2.3 TCP&#x2F;IP规范——RFC</h4><h3 id="2-3-互联网基础知识"><a href="#2-3-互联网基础知识" class="headerlink" title="2.3 互联网基础知识"></a>2.3 互联网基础知识</h3><h4 id="2-3-1-互联网定义"><a href="#2-3-1-互联网定义" class="headerlink" title="2.3.1 互联网定义"></a>2.3.1 互联网定义</h4><p>从字面上来看internet是将多个网络连接形成一个更大的网络，意为“国际网”</p>
<p>互联网是指由阿帕网发展而来，互联全世界的计算机网络</p>
<h4 id="2-3-2-互联网与TCP-x2F-IP的关系"><a href="#2-3-2-互联网与TCP-x2F-IP的关系" class="headerlink" title="2.3.2 互联网与TCP&#x2F;IP的关系"></a>2.3.2 互联网与TCP&#x2F;IP的关系</h4><p>互联网的协议就是TCP&#x2F;IP，TCP&#x2F;IP就是互联网的协议</p>
<h4 id="2-3-3-互联网的结构"><a href="#2-3-3-互联网的结构" class="headerlink" title="2.3.3 互联网的结构"></a>2.3.3 互联网的结构</h4><p>互联网中的每个网络都是由骨干网和末端网组成的。每个网络之间通过NOC（网络操作中心）相连。如果网络的运营商不同，网络连接方式和使用方法也有不同，连接这种异构网络需要IX（网络交换中心）的支持</p>
<p>互联网就是众多异构网络通过IX互连的巨型网络</p>
<h4 id="2-3-4-ISP和区域网"><a href="#2-3-4-ISP和区域网" class="headerlink" title="2.3.4 ISP和区域网"></a>2.3.4 ISP和区域网</h4><p>连接互联网需要向ISP或区域网提出申请</p>
<h3 id="2-4-TCP-x2F-IP协议分层模型"><a href="#2-4-TCP-x2F-IP协议分层模型" class="headerlink" title="2.4 TCP&#x2F;IP协议分层模型"></a>2.4 TCP&#x2F;IP协议分层模型</h3><h4 id="2-4-1-TCP-x2F-IP与OSI参考模型"><a href="#2-4-1-TCP-x2F-IP与OSI参考模型" class="headerlink" title="2.4.1 TCP&#x2F;IP与OSI参考模型"></a>2.4.1 TCP&#x2F;IP与OSI参考模型</h4><ul>
<li>应用层：对应OSI应用层，表示层，会话层</li>
<li>传输层：对应OSI传输层</li>
<li>互联网层：对应OSI网络层</li>
<li>网卡层：对应OSI数据链路层</li>
<li>硬件（物理层）：对应OSI物理层</li>
</ul>
<h4 id="2-4-2-硬件（物理层）"><a href="#2-4-2-硬件（物理层）" class="headerlink" title="2.4.2 硬件（物理层）"></a>2.4.2 硬件（物理层）</h4><p>TCP&#x2F;IP底层是负责数据传输的硬件（相当于电话线路等物理设备）</p>
<h4 id="2-4-3-网络接口层"><a href="#2-4-3-网络接口层" class="headerlink" title="2.4.3 网络接口层"></a>2.4.3 网络接口层</h4><p>网络接口层利用以太网中的数据链路进行通信，属于接口层。它可以被当作让网卡起作用的“驱动程序”（驱动程序是在操作系统与硬件之间起桥梁作用的软件）</p>
<h4 id="2-4-4-互联网层（网络层）"><a href="#2-4-4-互联网层（网络层）" class="headerlink" title="2.4.4 互联网层（网络层）"></a>2.4.4 互联网层（网络层）</h4><p>互联网层使用IP协议。IP协议基于IP地址转发分包数据</p>
<ul>
<li><p>IP</p>
<p>IP是跨越网络传送数据包，使整个互联网都能收到数据的协议。这期间它使用IP地址作为主机的标识</p>
<p>IP还隐含着数据链路层的功能。通过IP，互相通信的主机无论经过怎样的底层数据链路都能实现通信</p>
<p>IP不具有重发机制，属于非可靠传输协议</p>
</li>
<li><p>ICMP</p>
<p>IP数据包在发送途中一旦发生异常导致无法到达目标地址时，需要给发送端发送一个异常通知。ICMP就是为实现这一功能制定的</p>
</li>
<li><p>ARP</p>
<p>从分组数据包的IP地址中解析出MAC地址的一种协议</p>
</li>
</ul>
<h4 id="2-4-5-传输层"><a href="#2-4-5-传输层" class="headerlink" title="2.4.5 传输层"></a>2.4.5 传输层</h4><p>传输层的主要功能是让应用程序间实现通信</p>
<ul>
<li>TCP：面向有连接的传输层协议。保证两端通信主机之间的通信可达。为了建立和断开连接，有时会造成网络流量的浪费。不利于视频会议等场合使用</li>
<li>UDP：面向无连接的传输层协议。不会关注对端是否真收到了传送过去的数据，多用于分组较少或多播，广播通信以及视频通信等多媒体领域</li>
</ul>
<h4 id="2-4-6-应用层"><a href="#2-4-6-应用层" class="headerlink" title="2.4.6 应用层"></a>2.4.6 应用层</h4><p>TCP&#x2F;IP的应用的架构绝大多数属于客户端&#x2F;服务端模型</p>
<ul>
<li><p>WWW</p>
<p>中文叫万维网，是一种互联网上数据读取的规范，也叫Web，W3。用户在一种叫做Web浏览器的软件上借助鼠标和键盘进行网络冲浪</p>
<p>浏览器与服务器端之间的通信使用的协议是HTTP，传输协议的主要格式是HTML</p>
</li>
<li><p>电子邮件</p>
<p>发送电子邮件使用的协议叫做SMTP</p>
<p>经MIME协议拓展后，可以发送声音，图像等各种各样的信息</p>
</li>
<li><p>文件传输（FTP）</p>
<p>在FTP中进行文件传播时会创建两个TCP连接，分别是发送请求时用到的控制连接和实际传输时用到的数据连接</p>
</li>
<li><p>远程登陆</p>
<p>使用TELNET和SSH两种协议</p>
</li>
<li><p>网络管理</p>
<p>使用SNMP协议。被管理的路由器，网桥等被称作SNMP代理，进行管理的叫做管理器。SNMP是管理器和代理需要用到的协议</p>
</li>
</ul>
<h3 id="2-5-TCP-x2F-IP-分层模型和通讯示例"><a href="#2-5-TCP-x2F-IP-分层模型和通讯示例" class="headerlink" title="2.5 TCP&#x2F;IP 分层模型和通讯示例"></a>2.5 TCP&#x2F;IP 分层模型和通讯示例</h3>]]></content>
      <categories>
        <category>技术</category>
        <category>更新中</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>自学Vue第一章笔记</title>
    <url>/2022/10/12/VUE-chapter3/</url>
    <content><![CDATA[<h1 id="VUE"><a href="#VUE" class="headerlink" title="VUE"></a>VUE</h1><p>创建Vue应用:<code>Vue.createApp().mount(&quot;&quot;)</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app=<span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">        <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">name</span>:<span class="string">&quot;世界&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="使用data-绑定html元素"><a href="#使用data-绑定html元素" class="headerlink" title="使用data()绑定html元素"></a>使用data()绑定html元素</h4><ul>
<li>要渲染的元素用<code>&#123;&#123;&#125;&#125;</code>括起来，如<code>&#123;&#123;name&#125;&#125;</code></li>
<li>data是一个函数，返回一个类，类中声明需要渲染的元素和对应的值，如上述代码</li>
</ul>
<h4 id="使用v-bind绑定属性元素"><a href="#使用v-bind绑定属性元素" class="headerlink" title="使用v-bind绑定属性元素"></a>使用v-bind绑定属性元素</h4><p>对于html标签中的属性，不能通过直接用<code>&#123;&#123;&#125;&#125;</code>绑定，这时候需要使用v-bind</p>
<p>在html中使用v-bind</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;link&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>也可以省略v-bind只保留：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">&quot;link&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后在data中添加</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app=<span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">        <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">link</span>:<span class="string">&quot;https://website.com&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="使用v-for绑定列表元素"><a href="#使用v-for绑定列表元素" class="headerlink" title="使用v-for绑定列表元素"></a>使用v-for绑定列表元素</h4><p>对于多个列表元素可以用数组控制</p>
<p>在JavaScript中添加</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app=<span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">        <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">todos</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                  	<span class="attr">content</span>:<span class="string">&quot;goal1&quot;</span>,</span><br><span class="line">                    <span class="attr">complete</span>:<span class="literal">true</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                  	<span class="attr">content</span>:<span class="string">&quot;goal2&quot;</span>,</span><br><span class="line">                    <span class="attr">complete</span>:<span class="literal">true</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                  	<span class="attr">content</span>:<span class="string">&quot;goal3&quot;</span>,</span><br><span class="line">                    <span class="attr">complete</span>:<span class="literal">false</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">                </span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>使用v-for遍历数组只需要在html中加入一行li</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(todo,index) in todos&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">:checked</span>=<span class="string">&quot;todo.complete&quot;</span>&gt;</span>&#123;&#123;index+1&#125;&#125;:&#123;&#123;todo.content&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>v-for采用类似js中for-in的遍历方式，（）中第一个值是访问的数组元素，第二个是数组元素对应下标</p>
<p>采用js访问对象属性相同的方法访问数组中对象元素中的属性</p>
<h4 id="v-if和v-show"><a href="#v-if和v-show" class="headerlink" title="v-if和v-show"></a>v-if和v-show</h4><p>v-if可以通过js判断语句返回的值条件渲染html，使用<code>v-if,v-else-if,v-else</code>是要紧挨着</p>
<p>v-show则通过给元素设置display：none来实现显示与否</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app=<span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">        <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">books</span>:[<span class="string">&quot;js权威指南&quot;</span>,<span class="string">&quot;css权威指南&quot;</span>,<span class="string">&quot;js高级编程&quot;</span>],</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-show</span>=<span class="string">&quot;books.length===0&quot;</span>&gt;</span>没有图书<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">v-show</span>=<span class="string">&quot;books.length&gt;0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;book in books&quot;</span>&gt;</span>&#123;&#123;book&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="使用-注册事件"><a href="#使用-注册事件" class="headerlink" title="使用@注册事件"></a>使用@注册事件</h4><p>在html中使用@来注册事件及其响应</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;showAnswer=!showAnswer&quot;</span>&gt;</span>&#123;&#123;showAnswer?&quot;隐藏答案&quot;:&quot;显示答案&quot;&#125;&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="使用computed计算方法"><a href="#使用computed计算方法" class="headerlink" title="使用computed计算方法"></a>使用computed计算方法</h4><p>使用computed计算方法把一些需要重复执行的内容写入函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app=<span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;val=<span class="literal">false</span>&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">computed</span>:&#123;</span><br><span class="line">        <span class="title function_">label</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">val</span>=!<span class="variable language_">this</span>.<span class="property">val</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">val</span>?<span class="string">&quot;1&quot;</span>:<span class="string">&quot;2&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&quot;#div&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在html加入计算函数</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">app</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        &#123;&#123;label&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="使用methods方法"><a href="#使用methods方法" class="headerlink" title="使用methods方法"></a>使用methods方法</h4><p>使用methods方法处理事件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app=<span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">judgement</span>:<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>:&#123;</span><br><span class="line">        <span class="title function_">change</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">judgement</span>=!<span class="variable language_">this</span>.<span class="property">judgement</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>html中使用</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;change&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123;judgement&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="使用watch注册监听器"><a href="#使用watch注册监听器" class="headerlink" title="使用watch注册监听器"></a>使用watch注册监听器</h4><p>使用watch可以监听变量值的变化</p>
<p>watch中的函数名必须为需要监听的变量名,它有两个参数，分别是新值和旧值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app=<span class="title class_">Vue</span>.<span class="title function_">ccreateApp</span>(&#123;</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">judgement</span>:<span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>:&#123;</span><br><span class="line">        <span class="title function_">change</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">judgement</span>=!<span class="variable language_">this</span>.<span class="property">judgement</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attr">watch</span>:&#123;</span><br><span class="line">        <span class="title function_">judgement</span>(<span class="params">newVal,oldVal</span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(newVal)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;change&quot;</span>&gt;</span>judgement<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>点击按钮时会控制台输出改变后的值</p>
<h4 id="computed和methods的区别"><a href="#computed和methods的区别" class="headerlink" title="computed和methods的区别"></a>computed和methods的区别</h4><ul>
<li>计算属性缓存结果，多次使用计算属性或组件刷新时，如果计算属性使用的data属性无变化，computed会直接从缓存中读取</li>
<li>methods不缓存结果，任何属性变化都会导致methods重新执行，执行大量运算时比较慢。方法也可以作为普通的js函数被computed调用</li>
</ul>
<h4 id="computed-和-watch的区别"><a href="#computed-和-watch的区别" class="headerlink" title="computed 和 watch的区别"></a>computed 和 watch的区别</h4><ul>
<li>computed一般不直接修改data中属性，而是经过计算返回一个新值，使用时能像data中属性一样使用，data中的属性被修改后，计算属性也立即更新</li>
<li>watch监听到属性变化时直接修改data中数据值，不会返回计算结果，不能直接使用，需要在data中额外维护一个属性供watch使用</li>
</ul>
<p><img src="/image/img.png" alt="computed和watch的区别"></p>
<h4 id="methods和watch的区别"><a href="#methods和watch的区别" class="headerlink" title="methods和watch的区别"></a>methods和watch的区别</h4><ul>
<li>methods定义的方法可以在watch中调用，适合做一些更复杂的计算</li>
</ul>
<h4 id="使用事件监听处理表单输入数据"><a href="#使用事件监听处理表单输入数据" class="headerlink" title="使用事件监听处理表单输入数据"></a>使用事件监听处理表单输入数据</h4><p>使用methods方法定义事件处理函数，@input监听事件</p>
<h4 id="使用双向绑定，v-model处理表单输入数据"><a href="#使用双向绑定，v-model处理表单输入数据" class="headerlink" title="使用双向绑定，v-model处理表单输入数据"></a>使用双向绑定，v-model处理表单输入数据</h4><p><img src="/image/img_1.png" alt="双向绑定是什么"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app=<span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">        <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">username</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">methods</span>: &#123;</span><br><span class="line">            <span class="title function_">calculate</span>(<span class="params">e</span>) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">username</span>=e.<span class="property">target</span>.<span class="property">value</span>;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="title function_">clear</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">username</span>=<span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>html部分：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;username&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;calculate&quot;</span>&gt;</span>&#123;&#123;username&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;clear&quot;</span>&gt;</span>清空<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="其他表单控件的处理"><a href="#其他表单控件的处理" class="headerlink" title="其他表单控件的处理"></a>其他表单控件的处理</h4><p>其他表单控件的双向绑定绑定的为其value值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app=<span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">       <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> &#123;</span><br><span class="line">               <span class="attr">username</span>:<span class="string">&quot;&quot;</span>,</span><br><span class="line">               <span class="attr">gender</span>:<span class="string">&quot;&quot;</span>,</span><br><span class="line">               <span class="attr">checkbox</span>:[],</span><br><span class="line">               <span class="attr">introduction</span>:<span class="string">&quot;&quot;</span></span><br><span class="line">           &#125;;</span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="attr">methods</span>: &#123;</span><br><span class="line">           <span class="title function_">clear</span>(<span class="params"></span>) &#123;</span><br><span class="line">               <span class="variable language_">this</span>.<span class="property">username</span>=<span class="string">&quot;&quot;</span>;</span><br><span class="line">               <span class="variable language_">this</span>.<span class="property">gender</span>=<span class="string">&quot;&quot;</span>;</span><br><span class="line">               <span class="variable language_">this</span>.<span class="property">checkbox</span>=[];</span><br><span class="line">               <span class="variable language_">this</span>.<span class="property">introduction</span>=<span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">   app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;username&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;姓名&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;clear&quot;</span>&gt;</span>清除<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;male&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;gender&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>男<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;female&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;gender&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>女<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;interest&quot;</span> <span class="attr">value</span>=<span class="string">&quot;answer1&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>选项一<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;interest&quot;</span> <span class="attr">value</span>=<span class="string">&quot;answer2&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>选项二<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;interest&quot;</span> <span class="attr">value</span>=<span class="string">&quot;answer3&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>选项三<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">rows</span>=<span class="string">&quot;10&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;introduction&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;自我介绍&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;username&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;gender&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;checkbox&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;introduction&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="表单事件提交处理和事件修饰符"><a href="#表单事件提交处理和事件修饰符" class="headerlink" title="表单事件提交处理和事件修饰符"></a>表单事件提交处理和事件修饰符</h4><p>表单事件处理函数使用@submit绑定，使用.绑定事件修饰符，如<code>@submit.prevent</code>绑定禁止默认行为（e.preventDefault）</p>
<h4 id="根据条件控制class"><a href="#根据条件控制class" class="headerlink" title="根据条件控制class"></a>根据条件控制class</h4><p>使用v-bind:绑定class属性，在data中定义要使用的样式，使用数组设置多个class，使用对象形式完成根据条件修改样式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app=<span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">        <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">blue</span>: <span class="string">&quot;blue&quot;</span>,</span><br><span class="line">                <span class="attr">red</span>: <span class="string">&quot;red&quot;</span>,</span><br><span class="line">                <span class="attr">isHidden</span>:<span class="literal">false</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">methods</span>: &#123;</span><br><span class="line">            <span class="title function_">clear</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">isHidden</span>=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">:class</span>=<span class="string">&quot;[blue,red,&#123;hide: isHidden&#125;]&quot;</span>&gt;</span>A paragraph<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;clear&quot;</span>&gt;</span>清除<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>自学Vue第二章笔记</title>
    <url>/2022/10/12/VUE-chapter4/</url>
    <content><![CDATA[<h4 id="v-html在模板中输出html"><a href="#v-html在模板中输出html" class="headerlink" title="v-html在模板中输出html"></a>v-html在模板中输出html</h4><p>使用v-html在标签内输出html，为防止恶意代码，最好使用自己定义的html，对于用户输入要做过滤处理</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app=<span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">        <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">content</span>:<span class="string">&quot;&lt;p&gt;用v-html输出html&lt;/p&gt;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-html</span>=<span class="string">&quot;content&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="v-once只渲染一次模板"><a href="#v-once只渲染一次模板" class="headerlink" title="v-once只渲染一次模板"></a>v-once只渲染一次模板</h4><p>如果只需要显示原始数据，当数据发生改变时不重新渲染，可以使用v-once</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app=<span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">       <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> &#123;</span><br><span class="line">               <span class="attr">list</span>:[],</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">   app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-once</span>&gt;</span>原始长度:&#123;&#123;list.length&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>当前长度:&#123;&#123;list.length&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;this.list.push(this.list.length)&quot;</span>&gt;</span>添加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="v-bind和v-on绑定动态参数"><a href="#v-bind和v-on绑定动态参数" class="headerlink" title="v-bind和v-on绑定动态参数"></a>v-bind和v-on绑定动态参数</h4><p>在：或@后加上中括号[]，在中括号中加入js代码，就可以为v-bind和v-on绑定动态参数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app=<span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">        <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">attr</span>:<span class="string">&quot;placeholder&quot;</span>,</span><br><span class="line">                <span class="attr">event</span>:<span class="string">&quot;change&quot;</span>,</span><br><span class="line">                <span class="attr">value</span>:<span class="string">&quot;请输入内容&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">methods</span>:&#123;</span><br><span class="line">            <span class="title function_">handleInput</span>(<span class="params"></span>)&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;changed!&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">:</span>[<span class="attr">attr</span>]=<span class="string">&quot;value&quot;</span> @[<span class="attr">event</span>]=<span class="string">&quot;handleInput&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="v-for高级用法"><a href="#v-for高级用法" class="headerlink" title="v-for高级用法"></a>v-for高级用法</h4><ul>
<li>v-for循环除了可以遍历数组外还可以遍历对象，形式与遍历数组基本一致</li>
<li>v-for循环中可以为循环变量增添一个key值，当数组或对象中的元素顺序改变时，vue也会做出顺序的改变而不是直接修改值</li>
<li>v-for还可以直接指定一个数，如n in 5,结果输出12345</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app=<span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">        <span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">todo_list</span>:&#123;</span><br><span class="line">                    <span class="attr">todo1</span>:&#123;</span><br><span class="line">                        <span class="attr">id</span>:<span class="number">1</span>,</span><br><span class="line">                        <span class="attr">content</span>:<span class="string">&quot;代办1&quot;</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="attr">todo2</span>:&#123;</span><br><span class="line">                        <span class="attr">id</span>:<span class="number">2</span>,</span><br><span class="line">                        <span class="attr">content</span>:<span class="string">&quot;代办2&quot;</span>,</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="attr">todo3</span>:&#123;</span><br><span class="line">                        <span class="attr">id</span>:<span class="number">3</span>,</span><br><span class="line">                        <span class="attr">content</span>:<span class="string">&quot;代办3&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;todo in todo_list&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;todo.id&quot;</span>&gt;</span>&#123;&#123;todo.content&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;n in 5&quot;</span>&gt;</span>&#123;&#123;n&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="template标签"><a href="#template标签" class="headerlink" title="template标签"></a>template标签</h4><p>使用<code>&lt;template&gt;</code>标签可以只渲染里面的内容而不渲染外层的template标签</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app=<span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">        <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="number">10</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">&quot;value&gt;0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>不会渲染出外层template标签<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="事件传参和多事件处理"><a href="#事件传参和多事件处理" class="headerlink" title="事件传参和多事件处理"></a>事件传参和多事件处理</h4><p>可以在@绑定的事件函数中直接调用函数并传入参数，事件参数固定为$event，想绑定多个事件函数可以用<code>,</code>，事件函数会依次执行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app=<span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">        <span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">todos</span>:[&#123;</span><br><span class="line">                    <span class="attr">content</span>:<span class="string">&quot;代办1&quot;</span>,</span><br><span class="line">                    <span class="attr">id</span>:<span class="number">1</span>,</span><br><span class="line">                &#125;,&#123;</span><br><span class="line">                    <span class="attr">content</span>:<span class="string">&quot;代办2&quot;</span>,</span><br><span class="line">                    <span class="attr">id</span>:<span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">                &#125;,&#123;</span><br><span class="line">                    <span class="attr">content</span>:<span class="string">&quot;代办3&quot;</span>,</span><br><span class="line">                    <span class="attr">id</span>:<span class="number">3</span>,</span><br><span class="line">                &#125;]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">methods</span>:&#123;</span><br><span class="line">            <span class="title function_">calculate</span>(<span class="params">msg,e</span>)&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(msg);</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">clientX</span>+<span class="string">&quot; &quot;</span>+e.<span class="property">clientY</span>);</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="title function_">output</span>(<span class="params">msg</span>)&#123;</span><br><span class="line">                <span class="title function_">alert</span>(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;todo in todos&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;todo.id&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;calculate(todo.content,$event), output(todo.id)&quot;</span>&gt;</span>&#123;&#123;todo.content&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="事件相关修饰符"><a href="#事件相关修饰符" class="headerlink" title="事件相关修饰符"></a>事件相关修饰符</h4><ul>
<li>.prevent:阻止浏览器默认行为</li>
<li>.stop：阻止事件冒泡</li>
<li>.capture:捕获触发，从父元素触发至子元素</li>
<li>.self:当元素自身触发事件时才执行函数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app=<span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">        <span class="attr">methods</span>:&#123;</span><br><span class="line">            <span class="title function_">handleFather</span>(<span class="params"></span>)&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;触发父事件&#x27;</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="title function_">handleChild</span>(<span class="params"></span>)&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;触发子事件&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> @<span class="attr">click</span>=<span class="string">&quot;handleFather&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> @<span class="attr">click.prevent</span>&gt;</span>.prevent阻止默认行为，点击链接不会跳转<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> @<span class="attr">click.stop</span>=<span class="string">&quot;handleChild&quot;</span>&gt;</span>.stop阻止事件冒泡<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> @<span class="attr">click</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> @<span class="attr">click.capture</span>=<span class="string">&quot;handleFather&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> @<span class="attr">click</span>=<span class="string">&quot;handleChild&quot;</span>&gt;</span>capture会让事件的触发变为捕获触发，即会先捕获父元素，再触发子元素<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> @<span class="attr">click.self</span>=<span class="string">&quot;handleFather&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> @<span class="attr">click</span>=<span class="string">&quot;handleChild&quot;</span>&gt;</span>self使只有当元素自身触发事件时才会执行函数<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="处理键盘和鼠标事件"><a href="#处理键盘和鼠标事件" class="headerlink" title="处理键盘和鼠标事件"></a>处理键盘和鼠标事件</h4><p>使用.+按键名来绑定特定键位</p>
<p>使用.exact使只有特定按键被按下且其他按键没有被按下时才触发事件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app=<span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">list</span>:[<span class="string">&quot;好&quot;</span>,<span class="string">&quot;非常好&quot;</span>,<span class="string">&quot;很好&quot;</span>],</span><br><span class="line">            <span class="attr">content</span>:<span class="string">&quot;&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>:&#123;</span><br><span class="line">        <span class="title function_">submitlist</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">list</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">content</span>);</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">content</span>=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;comment in list&quot;</span>&gt;</span>&#123;&#123;comment&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;content&quot;</span> @<span class="attr">keyup.ctrl.enter.exact</span>=<span class="string">&quot;submitlist&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>查询按键的网址：</p>
<h4 id="与表单相关的修饰符"><a href="#与表单相关的修饰符" class="headerlink" title="与表单相关的修饰符"></a>与表单相关的修饰符</h4><ul>
<li>.lazy：当用户输入完，取消聚焦之后才触发双向绑定</li>
<li>.number：把用户输入的字段转换成num类型</li>
<li>.trim：去除用户输入的前后空格</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app=<span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">        <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">username</span>:<span class="string">&quot;&quot;</span>,</span><br><span class="line">                <span class="attr">year</span>:<span class="number">2000</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model.lazy.trim</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model.number</span>=<span class="string">&quot;year&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    &#123;&#123;username&#125;&#125;</span><br><span class="line">    &#123;&#123;year&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="通过vue实例访问和修改应用配置"><a href="#通过vue实例访问和修改应用配置" class="headerlink" title="通过vue实例访问和修改应用配置"></a>通过vue实例访问和修改应用配置</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vm=app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>然后可以访问vm的属性值或者做修改，是得可以使用外部js修改vue内部的值</p>
<h4 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h4><p>生命周期钩子是一个函数，会在合适的时期自动调用</p>
<ul>
<li><p><img src="/image/img_2.png" alt="image-20220709171124439"></p>
</li>
<li><p><img src="/image/img_3.png" alt="image-20220709171145368"></p>
</li>
<li><p><img src="/image/img_4.png" alt="image-20220709171208373"></p>
</li>
<li><p><img src="/image/img_5.png" alt="image-20220709171232027"></p>
</li>
<li><p><img src="/image/img_6.png" alt="image-20220709171335571"></p>
</li>
<li><p><img src="/image/img_7.png" alt="image-20220709171349173"></p>
</li>
<li><p><img src="/image/img_8.png" alt="image-20220709171400830"></p>
</li>
<li><p><img src="/image/img_9.png" alt="image-20220709171417499"></p>
</li>
</ul>
<p>常用的为created和mounted钩子</p>
<p><img src="/image/img_10.png" alt="image-20220709171500826"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app=<span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">        <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">posts</span>: [],</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">methods</span>:&#123;</span><br><span class="line">            <span class="keyword">async</span> <span class="title function_">getPosts</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> res=<span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&quot;./posts.json&quot;</span>);</span><br><span class="line">                <span class="keyword">const</span> data=<span class="keyword">await</span> res.<span class="title function_">json</span>();</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">posts</span>=data;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">getPosts</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">const</span> vm=app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;post in posts&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;post.id&quot;</span>&gt;</span>&#123;&#123;post.content&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>自学Vue第三章笔记</title>
    <url>/2022/10/12/VUE-chapter5/</url>
    <content><![CDATA[<h4 id="如何创建VUE组件"><a href="#如何创建VUE组件" class="headerlink" title="如何创建VUE组件"></a>如何创建VUE组件</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app=<span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;&#125;);</span><br><span class="line">    app.<span class="title function_">component</span>(<span class="string">&quot;word-counter&quot;</span>,&#123;</span><br><span class="line">        <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;input v-model=&quot;word&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;p&gt;一共有&#123;&#123;dataCounter&#125;&#125;个字符&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">        `</span>,</span><br><span class="line">        <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">word</span>:<span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">computed</span>: &#123;</span><br><span class="line">            <span class="title function_">dataCounter</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">word</span>.<span class="property">length</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">const</span> vm=app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">word-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">word-counter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>html代码配置在template配置项中</p>
<p>这种注册方式为全局注册</p>
<h4 id="脚手架"><a href="#脚手架" class="headerlink" title="脚手架"></a>脚手架</h4><p>脚手架是一组封装好的工具箱，用于快速生成一个项目，预置了常用的插件和依赖，能快速上手开发</p>
<p>大部分脚手架基于node开发</p>
<h4 id="使用vite创建vue项目"><a href="#使用vite创建vue项目" class="headerlink" title="使用vite创建vue项目"></a>使用vite创建vue项目</h4><p><code>yarn create vite</code>创建vite</p>
<p>随后设置项目名称，选择vue项目，选择vue</p>
<p>创建好项目后，在项目根目录下运行<code>npm install</code>安装依赖</p>
<p>安装好依赖后，运行<code>npm run dev</code>运行项目</p>
<h4 id="创建和使用单一文件组件"><a href="#创建和使用单一文件组件" class="headerlink" title="创建和使用单一文件组件"></a>创建和使用单一文件组件</h4><p>创建vue项目之后，修改components中vue文件的名字（默认为HelloWorld.vue）</p>
<p>如：<img src="/image/img_13.png" alt="image-20220807163007414"></p>
<p>这里面的wordCounter.vue就是我们的组件了</p>
<p>随后编辑wordCounter.vue：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;content&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>一共输入了&#123;&#123;count&#125;&#125;个字符<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">content</span>: <span class="string">&quot;&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">computed</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">count</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">content</span>.<span class="property">length</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="language-css"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"> <span class="selector-tag">input</span> &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">   <span class="attribute">border</span>: <span class="number">#535bf2</span> <span class="number">1px</span> solid;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"> &#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>组件由三部分构成</p>
<p><code>template</code>标签编写组件的html模板</p>
<p><code>script</code>标签编写脚本代码</p>
<p><code>style</code>标签编写css样式</p>
<p>编写后需要修改App.vue文件，App.vue文件是整个项目的入口组件，index.html中直接引入的是App.vue，所以我们需要在App.vue中引入wordCounter组件</p>
<p>代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> wordCounter <span class="keyword">from</span> <span class="string">&#x27;./components/wordCounter.vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">components</span>:&#123; wordCounter &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>字符串统计应用<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">word-counter</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>在<code>script</code>标签中通过<code>import</code>引入wordCounter，再在export default中添加，就可以在template中使用wordCounter组件了！</p>
<p>完成修改后，运行项目，如下图</p>
<p><img src="/image/img_14.png" alt="image-20220807163749603"></p>
<h4 id="props自定义组件内容"><a href="#props自定义组件内容" class="headerlink" title="props自定义组件内容"></a>props自定义组件内容</h4><p>给组件里添加props属性可以自定义组件中的内容</p>
<p>props的形式是一个数组，里面的元素均为字符串，如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">props</span>:[<span class="string">&#x27;username&#x27;</span>,<span class="string">&#x27;time&#x27;</span>,<span class="string">&#x27;content&#x27;</span>],</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>然后在template模板中就可以直接使用props中的内容了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;username&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;time&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;content&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>在App.vue中使用组件时可以对其传值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">message-item</span> <span class="attr">username</span>=<span class="string">&quot;demo&quot;</span> <span class="attr">time</span>=<span class="string">&quot;19:48&quot;</span> <span class="attr">content</span>=<span class="string">&quot;测试数据&quot;</span>/&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="/image/img_15.png" alt="image-20220807171234078"></p>
<h4 id="组件动态属性值绑定"><a href="#组件动态属性值绑定" class="headerlink" title="组件动态属性值绑定"></a>组件动态属性值绑定</h4><p>除了直接将要传入的值写死外，还可以通过script动态绑定</p>
<p>仍以上述为例，想要动态绑定，首先在data中声明一个数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">messageList</span>:[&#123;<span class="attr">id</span>:<span class="number">1</span>,<span class="attr">username</span>:<span class="string">&quot;demo1&quot;</span>,<span class="attr">time</span>:<span class="string">&quot;19:48&quot;</span>,<span class="attr">content</span>:<span class="string">&quot;测试数据1&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">id</span>:<span class="number">2</span>,<span class="attr">username</span>:<span class="string">&quot;demo2&quot;</span>,<span class="attr">time</span>:<span class="string">&quot;19:28&quot;</span>,<span class="attr">content</span>:<span class="string">&quot;测试数据2&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">id</span>:<span class="number">3</span>,<span class="attr">username</span>:<span class="string">&quot;demo3&quot;</span>,<span class="attr">time</span>:<span class="string">&quot;19:38&quot;</span>,<span class="attr">content</span>:<span class="string">&quot;测试数据3&quot;</span>&#125;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>然后在使用组件时通过v-for引入</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;message-item v-<span class="keyword">for</span>=<span class="string">&quot;message in messageList&quot;</span> v-bind=<span class="string">&quot;message&quot;</span> :key=<span class="string">&quot;message.id&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>

<p>这里的v-bind会自动识别message中和组件props中相同的属性并忽略掉无关属性，也可以使用下面的方法绑定</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;message-item v-<span class="keyword">for</span>=<span class="string">&quot;message in messageList&quot;</span> :username=<span class="string">&quot;message.username&quot;</span> :time=<span class="string">&quot;message.name&quot;</span> :content=<span class="string">&quot;message.content&quot;</span> :key=<span class="string">&quot;message.id&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p><img src="/image/img_16.png" alt="image-20220807173105491"></p>
<h4 id="组件属性验证和默认值"><a href="#组件属性验证和默认值" class="headerlink" title="组件属性验证和默认值"></a>组件属性验证和默认值</h4><p>在为组件传入值时，如果不使用v-bind,传入的都为字符串，使用v-bind传入的为js表达式，可以有多个类型</p>
<p>组件props的声明除了可以用数组外，还可以用对象，用来指定类型，如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="title class_">String</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="title class_">Number</span>,</span><br><span class="line">    <span class="attr">isStudent</span>: <span class="title class_">Boolean</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个属性有多个类型，可以用数组，如<code>name:[Number,String]</code></p>
<p>对于自定义类型，可以用构造函数定义，vue会通过instanceof判断如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="title class_">String</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="title class_">Number</span>,</span><br><span class="line">    <span class="attr">isStudent</span>: <span class="title class_">Boolean</span>,</span><br><span class="line">    <span class="attr">address</span>: <span class="title class_">Address</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Address</span>(<span class="params">province,city</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">province</span>=province;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">city</span>=city;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>vue还可以进行值验证，如判断属性是否为必传项，因此在定义类型时可以声明一个对象，如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>:<span class="title class_">String</span>,</span><br><span class="line">        <span class="attr">required</span>:<span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">age</span>: <span class="title class_">Number</span>,</span><br><span class="line">    <span class="attr">isStudent</span>: <span class="title class_">Boolean</span>,</span><br><span class="line">    <span class="attr">address</span>: <span class="title class_">Address</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还可以声明自定义的验证器,返回true则验证成功，返回false则验证失败</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">name</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>:<span class="title class_">String</span>,</span><br><span class="line">        <span class="title function_">validator</span>(<span class="params">value</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> value&gt;<span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<p>vue对验证失败的值并不会阻止其显示，而是会采用警告的形式提示</p>
<p>vue还可以为属性设置一个默认值，如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">name</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>:<span class="title class_">String</span>,</span><br><span class="line">        <span class="attr">default</span>: <span class="string">&#x27;text&#x27;</span>,</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<p>当未传入值时，将默认传入default中的内容</p>
<p>如果类型是对象或者数组，那么default要为一个函数，返回对象或数组</p>
<p>如果类型是函数，default也要为函数，但default本身作为用来判断的函数</p>
<h4 id="传递未定义属性"><a href="#传递未定义属性" class="headerlink" title="传递未定义属性"></a>传递未定义属性</h4><p>一般来说传递未定义属性传递的是class或者style，这时候会默认传给template最外层元素，传递未定义属性也可以做到穿透传递，即App中引入组件A，组件A引入组件B，B中声明了一个属性，这时候从App中向组件A传递这个属性和对应值，会直接在组件B中应用</p>
<h4 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h4><p>如果需要向组件传递HTML代码，使用props是不行的，这个时候可以使用slot标签。</p>
<p>在组件的template标签中加入solt：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123;title&#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span>默认内容<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>在App.vue中使用组件时在组件标签里添加slot的内容</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">hello-world</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是slot中的内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>如果没有则显示slot中默认内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">hello-world</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果没有内容，则会显示slot标签中默认的内容</p>
<p>效果如图：</p>
<p><img src="/image/img_17.png" alt="image-20220808092722798"></p>
<h4 id="使用多个插槽占位"><a href="#使用多个插槽占位" class="headerlink" title="使用多个插槽占位"></a>使用多个插槽占位</h4><p>当在组件中使用多个slot时，需要给slot指定一个名字来加以区分</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;slot name=&quot;title&quot;&gt;默认标题&lt;/slot&gt;</span><br><span class="line">    &lt;slot name=&quot;content&quot;&gt;默认内容&lt;/slot&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>在App.vue中通过<code>v-slot</code>引入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;hello-world&gt;</span><br><span class="line">    &lt;template v-slot:title&gt;</span><br><span class="line">      &lt;h2&gt;这是标题&lt;/h2&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">    &lt;template v-slot:content&gt;</span><br><span class="line">      &lt;p&gt;这是内容&lt;/p&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">  &lt;/hello-world&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>效果如图：</p>
<p><img src="/image/img_18.png" alt="image-20220808093716726"></p>
<p>如果没有为slot指定名字，默认名字为default</p>
<h4 id="通过子组件事件向父组件传递数据"><a href="#通过子组件事件向父组件传递数据" class="headerlink" title="通过子组件事件向父组件传递数据"></a>通过子组件事件向父组件传递数据</h4><p>​	一般来说我们只能从父组件向子组件传递数据，那么如何让子组件向父组件传递数据呢？可以使用vue提供的emit属性，通过子组件事件向父组件传递数据</p>
<p>首先在子组件中定义emit</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">    props:[&#x27;id&#x27;,&quot;content&quot;],</span><br><span class="line">    emits:[&#x27;deleteContent&#x27;],</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里的emit和props一样为一个数组，接收自定义事件名作为参数</p>
<p>然后我们需要在子组件中触发事件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123;content&#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;button @click=&quot;$emit(&#x27;deleteContent&#x27;,id)&quot;&gt;删除&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>通过绑定click事件触发emit函数，emit函数接收一个或多个参数，第一个参数就是在emit数组中的事件名，后面的可选参数是要传递的值</p>
<p>然后就可以在App.vue中进行监听了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;hello-world v-for=&quot;post in list&quot; v-bind=&quot;post&quot; @deleteContent=&quot;deleteContent&quot;&gt;&lt;/hello-world&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>监听在emit中定义的事件并触发事件函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">    deleteContent(id)&#123;</span><br><span class="line">      this.list=this.list.filter((post)=&gt;&#123;</span><br><span class="line">        return post.id!==id;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>事件处理函数可以接收到子组件中监听的id</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>自学VUE第四章笔记</title>
    <url>/2022/10/12/VUE-chapter6/</url>
    <content><![CDATA[<h4 id="props响应式传递"><a href="#props响应式传递" class="headerlink" title="props响应式传递"></a>props响应式传递</h4><p>根据vue中的数据流通，子组件是不能修改父组件传进的props值的，因此，如果想从子组件修改传入的值，需要用到子组件的data，将props的值赋给data，修改data的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div v-for=&quot;n in pages&quot; @click=&quot;changePage(n)&quot;&gt;&#123;&#123;n&#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;p&gt;当前页：&#123;&#123;currentPage&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        currentPage:this.currentPageDefault,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    props:[&#x27;pages&#x27;,&#x27;currentPageDefault&#x27;],</span><br><span class="line">    methods:&#123;</span><br><span class="line">      changePage(n) &#123;</span><br><span class="line">        this.currentPage=n;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    watch:&#123;</span><br><span class="line">      pages(newVal,oldVal) &#123;</span><br><span class="line">        console.log(newVal)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>父组件传入<code>currentPageDefault</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;HelloWorld :pages=&quot;num&quot; :current-page-default=&quot;5&quot;&gt;&lt;/HelloWorld&gt;</span><br><span class="line">  &lt;button @click=&quot;num++&quot;&gt;增加页数&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>可以使用watch监听属性的变化，用法和watch监听data的变化一致</p>
<h4 id="组件数据的流向设计"><a href="#组件数据的流向设计" class="headerlink" title="组件数据的流向设计"></a>组件数据的流向设计</h4><p>vue中的组件数据流向设计是：父组件通过props向子组件传递数据，子组件通过emit事件向父组件传递数据</p>
<p>如，现在有两个组件<code>emitMode</code>和<code>propsMode</code></p>
<p><code>emitMode</code>通过emit向父组件传递事件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button @click=&quot;$emit(&#x27;handleEvents&#x27;,&#x27;点击了按钮&#x27;)&quot;&gt;点击按钮&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"> export default &#123;</span><br><span class="line">   emits:[&#x27;handleEvents&#x27;]</span><br><span class="line"> &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><code>propsMode</code>通过父组件传递的props触发事件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button @click=&quot;click(&#x27;点击了按钮&#x27;)&quot;&gt;点击按钮&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    props:[&#x27;click&#x27;],</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>在父组件中引入子组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">import emitMode from &#x27;./components/emitMode.vue&#x27;</span><br><span class="line">import propsMode from &quot;./components/propsMode.vue&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  components:&#123;emitMode,propsMode&#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    printMessage(mes) &#123;</span><br><span class="line">      console.log(mes)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;emit-mode @handleEvents=&quot;printMessage&quot;&gt;&lt;/emit-mode&gt;</span><br><span class="line">  &lt;props-mode :click=&quot;printMessage&quot;&gt;&lt;/props-mode&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>两种方法都能达到一样的效果，但区别是，当父组件没有向子组件传递props时，<code>propsMode</code>会提示异常但<code>emitMode</code>不会依赖父组件，因此当子组件需要用到父组件传入的事件处理函数时，使用emit向上传递事件，不要让父组件向下传递props</p>
<h4 id="组件生命周期"><a href="#组件生命周期" class="headerlink" title="组件生命周期"></a>组件生命周期</h4><p>组件的生命周期和之前的生命周期钩子是一样的，不过多介绍</p>
<h4 id="provide-x2F-inject传递深层组件"><a href="#provide-x2F-inject传递深层组件" class="headerlink" title="provide&#x2F;inject传递深层组件"></a>provide&#x2F;inject传递深层组件</h4><p>如果父组件引入了子组件，子组件又引入了更深层的组件，可以对父组件提供<code>Provide</code>配置项对更深层次的组件提供属性，用到这个属性的组件使用<code>Inject</code>配置项获取属性</p>
<p>父组件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">	<span class="attr">components</span>:&#123;</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line">	<span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;,</span><br><span class="line">    <span class="attr">provide</span>:&#123;</span><br><span class="line">        <span class="attr">title</span>:<span class="string">&quot;demo&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子组件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">inject</span>:[<span class="string">&#x27;title&#x27;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子组件将获得<code>&quot;demo&quot;</code></p>
<p>如果想用<code>provide</code>传递动态属性，需要将<code>provide</code>写成函数形式并返回对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">provide</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">title</span>:<span class="variable language_">this</span>.<span class="property">demo</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="在传递的slot模板中访问属性"><a href="#在传递的slot模板中访问属性" class="headerlink" title="在传递的slot模板中访问属性"></a>在传递的slot模板中访问属性</h4><p>我们可能需要在传递给子组件的slot模板中使用子组件中的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;li v-if=&quot;contact in contacts&quot; :key=&quot;contact.id&quot;&gt;</span><br><span class="line">        &lt;slot /&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>如果我们需要在父组件传递的slot模板中使用<code>contact</code>，就需要在子组件中声明想暴露的属性，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;li v-if=&quot;contact in contacts&quot; :key=&quot;contact.id&quot;&gt;</span><br><span class="line">        &lt;slot :contact=&#x27;contact&#x27;/&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>在父组件中使用<code>template</code>标签和之前介绍过的<code>v-slot</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template v-slot:default=&#x27;props&#x27;&gt;</span><br><span class="line">	&lt;p&gt;</span><br><span class="line">        &#123;&#123;props.contact.name&#125;&#125;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p><code>default</code>是因为子组件中没有给slot命名,<code>props</code>就是子组件暴露出来的属性集合</p>
<h4 id="为组件设置样式"><a href="#为组件设置样式" class="headerlink" title="为组件设置样式"></a>为组件设置样式</h4><ul>
<li><p>直接在<code>style</code>标签中设置：对全局生效</p>
</li>
<li><p>带有<code>scope</code>的<code>style</code>标签：对本身生效</p>
</li>
<li><p>直接导入css文件：对全局生效，适合在入口组件处设置一些基础样式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;/style.css&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>CSS module:在</code>style<code>标签中加上</code>modules<code>，在想要引入的标签中使用</code>$style&#96;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style module&gt;</span><br><span class="line">    .p &#123;</span><br><span class="line">        width:200px;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p :class=&#x27;$style.p&#x27;&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<p>不会影响其他组件</p>
</li>
</ul>
<h4 id="在带有scope的style标签中修改子组件样式"><a href="#在带有scope的style标签中修改子组件样式" class="headerlink" title="在带有scope的style标签中修改子组件样式"></a>在带有scope的style标签中修改子组件样式</h4><p>可以在父组件的带有scope的style标签中修改子组件根元素样式</p>
<p>子组件中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&#x27;text&#x27;&gt;</span><br><span class="line">    text</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>父组件中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style scope&gt;</span><br><span class="line">    .text &#123;</span><br><span class="line">        color:&#x27;blue&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>就可以修改子组件的样式</p>
<p>如果想要修改非根元素的元素，可以使用<code>:deep()</code>选择器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style scope&gt;</span><br><span class="line">    .text :deep(a) &#123;</span><br><span class="line">        color:&quot;red&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>如果子组件想要修改传递给子组件的slot模板的样式，可以使用<code>:slotted()</code>来修改</p>
<p>父组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;childComponent&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        这是slot中的内容</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/childComponent&gt;</span><br></pre></td></tr></table></figure>

<p>子组件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style scope&gt;</span><br><span class="line">    :slotted(div) &#123;</span><br><span class="line">        color:&quot;azure&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h4 id="在样式中绑定响应式数据"><a href="#在样式中绑定响应式数据" class="headerlink" title="在样式中绑定响应式数据"></a>在样式中绑定响应式数据</h4><p>在vue3.2版本之后可以使用v-bind指令为样式绑定响应式数据</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>:<span class="built_in">rotate</span>(<span class="built_in">v-bind</span>(degree+<span class="string">&#x27;deg&#x27;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果v-bind中的表达式太长，可以定义为<code>computed</code>计算属性</p>
<h4 id="为组件设置v-model"><a href="#为组件设置v-model" class="headerlink" title="为组件设置v-model"></a>为组件设置v-model</h4><p>日常开发中可能会有将表单封装成组件的需求，这时候需要为组件设置v-model</p>
<p>父组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;childComponent  v-model=&#x27;textvalue&#x27;&gt;&lt;/childComponent&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">    &#123;&#123;textvalue&#125;&#125;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">data() &#123;</span><br><span class="line">	return &#123;</span><br><span class="line">		textvalue:&quot;&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子组件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input :value=&#x27;modelValue&#x27; @input=&#x27;$emit(&quot;update:modelValue&quot;,$event.target.value)&#x27;&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">props</span>:[<span class="string">&#x27;modelValue&#x27;</span>],</span><br><span class="line">    <span class="attr">emits</span>:[<span class="string">&#x27;update:modelValue&#x27;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>modelValue,update:modelValue</code>都是固定写法</p>
<p>但这种方式设置的v-model只能绑定一个值</p>
<h4 id="使用多个v-model指令"><a href="#使用多个v-model指令" class="headerlink" title="使用多个v-model指令"></a>使用多个v-model指令</h4><p>如果子组件中有多个input或者其他表单控件，在父组件中需要使用带参数的v-model指令，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;childComponent v-model:text1=&#x27;content1&#x27; v-model:text2=&quot;content2&quot;&gt;&lt;/childComponent&gt;</span><br></pre></td></tr></table></figure>

<p>这是父组件的写法</p>
<p>子组件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        props:[&#x27;text1&#x27;,&#x27;text2&#x27;],//名字要与v-model后的参数保持一致</span><br><span class="line">        emits:[&#x27;update:text1&#x27;,&#x27;update:text2&#x27;]//也要保持一致</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input :value=&#x27;text1&#x27; @input=&#x27;$emits(&quot;text1&quot;,$event.target.value)&#x27;&gt;</span><br><span class="line">&lt;input :value=&#x27;text2&#x27; @input=&#x27;$emits(&quot;text2&quot;,$event.target.value)&#x27;&gt;</span><br></pre></td></tr></table></figure>

<h4 id="ref获取DOM和子组件实例"><a href="#ref获取DOM和子组件实例" class="headerlink" title="ref获取DOM和子组件实例"></a>ref获取DOM和子组件实例</h4><p><code>ref</code>可以获取DOM实例和子组件实例，但这种方式会破坏单向数据流，应该尽量少使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;input type=&#x27;text&#x27; ref=&quot;inputControl&quot;&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        mounted() &#123;</span><br><span class="line">            this.$refs.inputControl.focus();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>这里的<code>$refs</code>是组件里所有的实例对象，获取到的实例和<code>$event.target</code>相同</p>
<p>父组件可以获取子组件实例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;childComponent ref=&#x27;child&#x27;&gt;&lt;/childComponent&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">child</span>.<span class="title function_">method</span>();</span><br><span class="line">&#125;,<span class="number">3000</span>) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就做到了父组件获取子组件属性，方法等</p>
<p><code>this.$refs</code>只能在组件完全加载之后使用</p>
<h4 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h4><p>我们也可以自己定义<code>v-if</code>这样的指令，但这样会操作DOM，可能造成数据不一致等问题，实际中尽量少使用，尽量多使用组件来拓展功能</p>
<p>定义指令实际上是给其一系列生命周期钩子定义函数。一般定义全局指令</p>
<p>引入自定义指令可以用<code>directives</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">directives</span>: &#123;</span><br><span class="line">    fsize</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p v-fsize=&#x27;fontsize&#x27;&gt;</span><br><span class="line">    text</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<p>下面介绍全局定义自定义指令方法</p>
<p>打开<code>main.js</code>，调用<code>app</code>的<code>directive</code>方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.<span class="title function_">directive</span>(<span class="string">&#x27;fsize&#x27;</span>,&#123;</span><br><span class="line">    <span class="title function_">mounted</span>(<span class="params">el,binding</span>) &#123;</span><br><span class="line">        el.<span class="property">style</span>.<span class="property">fontSize</span>=binding.<span class="property">value</span>+<span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">updating</span>(<span class="params">el,binding</span>) &#123;</span><br><span class="line">        el.<span class="property">style</span>.<span class="property">fontSize</span>=binding.<span class="property">value</span>+<span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>el</code>是DOM实例，<code>binding.value</code>是传入的数据</p>
<p>常用的钩子是<code>mounted</code>和<code>updated</code>，用于初始化和响应式</p>
<p>如果只是用了这两个钩子且定义的方法相同，可以简写</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.<span class="title function_">directive</span>(<span class="string">&#x27;fsize&#x27;</span>,<span class="function">(<span class="params">el,binding</span>)=&gt;</span>&#123;</span><br><span class="line">    el.<span class="property">style</span>.<span class="property">fontSize</span>=binding.<span class="property">value</span>+<span class="string">&#x27;px&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>也可以为自定义的指令传递参数，写法如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p v-fsize:[unit]=&#x27;fontsize&#x27;&gt;</span><br><span class="line">    text</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<p>在定义中使用<code>binding.args</code>获取参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.<span class="title function_">directive</span>(<span class="string">&#x27;fsize&#x27;</span>,<span class="function">(<span class="params">el,binding</span>)=&gt;</span>&#123;</span><br><span class="line">    el.<span class="property">style</span>.<span class="property">fontSize</span>=binding.<span class="property">value</span>+(binding.<span class="property">arg</span>||<span class="string">&#x27;px&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="is动态组件"><a href="#is动态组件" class="headerlink" title=":is动态组件"></a>:is动态组件</h4><p>使用<code>:is</code>可以为组件绑定动态html，需要使用<code>Component</code>标签，如</p>
<p>子组件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Component :is=&#x27;heading&#x27;&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/Component&gt;</span><br></pre></td></tr></table></figure>

<p>然后可以为<code>heading</code>定义计算属性或数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">computed</span>:&#123;</span><br><span class="line">    <span class="title function_">heading</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`h<span class="subst">$&#123;<span class="variable language_">this</span>.level&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>父组件引入子组件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;childComponent :level=1&gt;一级标题&lt;/childComponent&gt;</span><br><span class="line">&lt;childComponent :level=2&gt;二级标题&lt;/childComponent&gt;</span><br></pre></td></tr></table></figure>

<p>这样就起到了动态绑定HTML的作用</p>
<p><code>:is</code>还能动态绑定组件，将值换为组件名即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Component :is=&#x27;child1&#x27;&gt;&lt;/Component&gt;</span><br><span class="line">&lt;Component :is=&#x27;child2&#x27;&gt;&lt;/Component&gt;</span><br></pre></td></tr></table></figure>

<h4 id="KeepAlive解决动态组件数据丢失"><a href="#KeepAlive解决动态组件数据丢失" class="headerlink" title="KeepAlive解决动态组件数据丢失"></a><code>KeepAlive</code>解决动态组件数据丢失</h4><p>使用<code>:is</code>动态切换组件时，每一次切换组件组件都会重新渲染，组件中输入的数据（表单等）会丢失。解决的方法很简单，在组件外部套一个<code>KeepAlive</code>标签即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;KeepAlive&gt;</span><br><span class="line">    &lt;childComponent&gt;&lt;/childComponent&gt;</span><br><span class="line">&lt;/KeepAlive&gt;</span><br></pre></td></tr></table></figure>

<h4 id="组件传送"><a href="#组件传送" class="headerlink" title="组件传送"></a>组件传送</h4><p>有时候组件在逻辑上不属于任何父组件，使用<code>teleport</code>可以将组件挂载到dom元素上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Teleport to=&#x27;body&#x27;&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/Teleport&gt;</span><br></pre></td></tr></table></figure>

<p>这样<code>Teleport</code>中的代码就会传送到body下了</p>
<h4 id="多次传送"><a href="#多次传送" class="headerlink" title="多次传送"></a>多次传送</h4><p>多次传送相同的组件，它们会在节点中顺序追加到节点中</p>
<h4 id="异步加载组件"><a href="#异步加载组件" class="headerlink" title="异步加载组件"></a>异步加载组件</h4><p>使用异步加载组件，只有当组件第一次被挂载时代码才会加载，能起到减少客户端代码体积的作用</p>
<p>vue提供了一种异步加载组件的方式</p>
<p>先导入<code>defineAsyncComponent</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineAsyncComponent &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>然后调用<code>defineAsyncComponent</code>引入组件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> childComponentName=<span class="title function_">defineAsyncComponent</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">	<span class="title function_">import</span>(<span class="string">&#x27;./child.vue&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="全局处理组件错误"><a href="#全局处理组件错误" class="headerlink" title="全局处理组件错误"></a>全局处理组件错误</h4><p>子组件的错误会一层层上传，最终到达最顶层组件并报错，可以在全局注册错误处理</p>
<p>打开<code>main.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app=<span class="title function_">createApp</span>(<span class="title class_">App</span>);</span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>);</span><br><span class="line">app.<span class="property">config</span>.<span class="property">errorHandler</span>=<span class="function">(<span class="params">err,vm,info</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);<span class="comment">//发生的错误</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(vm);<span class="comment">//发生错误的vue实例</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(info)<span class="comment">//发生错误的位置信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给<code>app.config.errorHandler</code>注册成一个函数用于处理函数</p>
<h4 id="在组件中处理错误"><a href="#在组件中处理错误" class="headerlink" title="在组件中处理错误"></a>在组件中处理错误</h4><p>当在组件中处理了错误，就相当于声明了一个错误边界，边界内的组件的错误不会再向边界外冒泡</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">errorCaptured</span>(<span class="params">err,instance,info</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>声明<code>errorCaptured</code>方法，它的返回值可以控制错误是否继续向上传播（false是不传播）</p>
<p>参数和全局处理错误类似</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>组件</tag>
      </tags>
  </entry>
  <entry>
    <title>自学VUE第五章笔记</title>
    <url>/2022/10/12/VUE-chapter7/</url>
    <content><![CDATA[<h3 id="Composition-API"><a href="#Composition-API" class="headerlink" title="Composition API"></a>Composition API</h3><h4 id="setup-：入口"><a href="#setup-：入口" class="headerlink" title="setup()：入口"></a><code>setup()</code>：入口</h4><p>要使用组合式API，我们需要在组件中增加<code>setup</code>配置项，这是一个函数，返回一个对象，返回的对象可以像<code>data</code>中返回对象那样，其中的属性可以调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  import &#123;ref&#125; from &quot;vue&quot;;</span><br><span class="line">  export default &#123;</span><br><span class="line">    setup() &#123;</span><br><span class="line">      let list=ref([&#x27;listNode1&#x27;]);</span><br><span class="line">      console.log(list.value)</span><br><span class="line">      return &#123;</span><br><span class="line">        list:list,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>但像<code>components</code>这样的配置项还是得在<code>setup</code>外配置</p>
<h4 id="ref-定义响应式数据"><a href="#ref-定义响应式数据" class="headerlink" title="ref()定义响应式数据"></a><code>ref()</code>定义响应式数据</h4><p>直接在<code>setup</code>中返回的数据是非响应式的，如果想要转成响应式的，可以使用vue提供的<code>ref</code>函数</p>
<p><code>ref</code>函数接受多种类型的数据，并返回一个对象，在<code>setup</code>中要获取到值需要调用<code>value</code>，在标签中访问不需要</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  import &#123;ref&#125; from &quot;vue&quot;;</span><br><span class="line"></span><br><span class="line">  export default &#123;</span><br><span class="line">    setup() &#123;</span><br><span class="line">      let list=ref([&#x27;listNode1&#x27;]);</span><br><span class="line">      console.log(list.value)</span><br><span class="line">      return &#123;</span><br><span class="line">        list:list,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p v-for=&quot;node in list&quot;&gt;&#123;&#123;node&#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;button @click=&quot;list=[]&quot;&gt;删除&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<h4 id="reactive-另一种转换响应式数据的方法"><a href="#reactive-另一种转换响应式数据的方法" class="headerlink" title="reactive():另一种转换响应式数据的方法"></a><code>reactive()</code>:另一种转换响应式数据的方法</h4><p><code>reactive()</code>与<code>ref()</code>类似，但只接受对象类型的数据，直接返回一个代理，在<code>setup()</code>中不需要再使用<code>.value</code>访问</p>
<p>大部分情况直接使用<code>ref()</code>即可，但当要处理含有多个数据的对象为响应式时，可以使用<code>reactive()</code></p>
<h4 id="computed-监听响应式数据的变化"><a href="#computed-监听响应式数据的变化" class="headerlink" title="computed()监听响应式数据的变化"></a><code>computed()</code>监听响应式数据的变化</h4><p>使用vue提供的<code>computed()</code>可以监听响应式数据的变化，它接受一个回调函数，返回回调函数返回的值</p>
<p>下面是实现过滤列表的方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  import &#123;computed, ref&#125; from &quot;vue&quot;;</span><br><span class="line">  export default &#123;</span><br><span class="line">    setup() &#123;</span><br><span class="line">      let inputContent=ref(&#x27;&#x27;);//定义成响应式数据</span><br><span class="line">      let list=ref([&#x27;listNode1&#x27;,&#x27;listNode2&#x27;,&quot;listNode3&quot;,&quot;listNode4&quot;]);</span><br><span class="line">      let listFilter=computed(()=&gt;&#123;</span><br><span class="line">        if(inputContent.value===&#x27;&#x27;) &#123;</span><br><span class="line">          return list.value;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          return list.value.filter((node)=&gt;&#123;</span><br><span class="line">            return node.includes(inputContent.value)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      return &#123;</span><br><span class="line">        list:list,</span><br><span class="line">        inputContent:inputContent,</span><br><span class="line">        listFilter:listFilter</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p v-for=&quot;node in listFilter&quot;&gt;&#123;&#123;node&#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; v-model=&quot;inputContent&quot;&gt;</span><br><span class="line">  &lt;button @click=&quot;list=[]&quot;&gt;删除&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<h4 id="watch-监听响应式数据的变化"><a href="#watch-监听响应式数据的变化" class="headerlink" title="watch()监听响应式数据的变化"></a><code>watch()</code>监听响应式数据的变化</h4><p>和<code>options API</code>中一样，我们也可以使用<code>watch()</code>来监听响应式数据的变化</p>
<ul>
<li><p>监听基本数据类型</p>
<p>基本数据类型的响应性变量只能由<code>ref()</code>创建</p>
<ul>
<li><p>监听<code>ref()</code>本身，使用方式和<code>options API</code>中类似</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">watch</span>(inputContent,<span class="function">(<span class="params">newVal,oldVal</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(newVal+<span class="string">&quot;   &quot;</span>+oldVal);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>监听<code>ref().value</code>，不能直接替换，需要将第一个参数改为函数形式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">watch</span>(<span class="function">()=&gt;</span>&#123;<span class="keyword">return</span> inputContent.<span class="property">value</span>&#125;</span><br><span class="line">,<span class="function">(<span class="params">newVal,oldVal</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(newVal+<span class="string">&quot;   &quot;</span>+oldVal);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>监听对象中的基本数据类型的响应式数据</p>
<p>和监听<code>ref().value</code>一样</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">watch</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> title.<span class="property">value</span>.<span class="property">name</span></span><br><span class="line">&#125;,<span class="function">(<span class="params">newVal,oldVal</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(newVal+<span class="string">&#x27;,&#x27;</span>+oldVal)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>监听对象类型的响应式数据</p>
<p>直接用<code>watch</code>监听对象的响应性数据会失败，因为并没有比较对象中的每一个属性</p>
<ul>
<li><p>使用<code>deep</code></p>
<p>可以给<code>watch()</code>传递第三个参数，形式是一个对象，对象中可以配置deep属性为<code>ture</code>，这样就可以比较对象中的属性是否改变了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">watch</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> title.<span class="property">value</span></span><br><span class="line">&#125;,<span class="function">(<span class="params">newVal,oldVal</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(newVal+<span class="string">&#x27;,&#x27;</span>+oldVal)</span><br><span class="line">&#125;,&#123;</span><br><span class="line">  <span class="attr">deep</span>:<span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这种方法的缺点是只能获取到新值，因为旧值和新值的引用一样</p>
</li>
<li><p>对对象进行深度克隆</p>
<p>即在第一个参数的回调函数中返回对象的深克隆</p>
</li>
</ul>
</li>
<li><p>监听多个响应式数据</p>
<p>给第一个参数传递一个数组即可</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">watch</span>([inputContent,<span class="function">()=&gt;</span>title.<span class="property">value</span>.<span class="property">name</span>],<span class="function">(<span class="params">newVal,oldVal</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(newVal)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(oldVal)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="watchEffect-：变体的watch"><a href="#watchEffect-：变体的watch" class="headerlink" title="watchEffect()：变体的watch()"></a><code>watchEffect()</code>：变体的<code>watch()</code></h4><p><code>watchEffect()</code>接收一个回调函数，函数内涉及到的响应式数据一旦发生变化，就会重新执行一次<code>watchEffect()</code>。与<code>watch()</code>的区别是，它不管数据是否变化，声明后都会执行一次，相当于<code>do...while</code>,<code>watch</code>相当于<code>while</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">watchEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(inputContent.<span class="property">value</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>传递的函数也可以是<code>async</code>的</p>
<h4 id="watch-和watchEffect-清理操作"><a href="#watch-和watchEffect-清理操作" class="headerlink" title="watch()和watchEffect()清理操作"></a><code>watch()</code>和<code>watchEffect()</code>清理操作</h4><p>在<code>watch()</code>的第二个参数的回调函数中传入第三个参数<code>onInvalidate</code>然后调用即可</p>
<p>在<code>watchEffect()</code>传入的回调函数中传入参数<code>onInvalidate</code>然后调用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">watch</span>([inputContent,<span class="function">()=&gt;</span>title.<span class="property">value</span>.<span class="property">name</span>],<span class="function">(<span class="params">newVal,oldVal,onInvalidate</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(newVal)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(oldVal)</span><br><span class="line">  <span class="title function_">onInvalidate</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;一些清理操作&quot;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="title function_">watchEffect</span>(<span class="function">(<span class="params">onInvalidate</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(inputContent.<span class="property">value</span>)</span><br><span class="line">  <span class="title function_">onInvalidate</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;清理操作&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="传递和访问props"><a href="#传递和访问props" class="headerlink" title="传递和访问props"></a>传递和访问<code>props</code></h4><p>组件的<code>props</code>属性和<code>optionsAPI</code>一样定义成数组，在<code>setup</code>中传入第一个参数表示接收到的props对象，调用即可</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">props</span>:[<span class="string">&#x27;text&#x27;</span>,<span class="string">&#x27;message&#x27;</span>],</span><br><span class="line"><span class="title function_">setup</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(props.<span class="property">text</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="转换非响应性props为响应性"><a href="#转换非响应性props为响应性" class="headerlink" title="转换非响应性props为响应性"></a>转换非响应性props为响应性</h4><p>子组件接收到的<code>props</code>本身是响应性的，是一个<code>proxy</code>。</p>
<p>如果父组件传递的属性是响应性的，那么子组件接收到的也是响应性的</p>
<p>如果父组件传递的属性是普通的数据，子组件接收到的属性被解构出来就不是响应性的，需要转化成响应性的</p>
<p>使用<code>toRefs()</code>使解构后的对象为响应性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;msg&#125; = <span class="title function_">toRefs</span>(props);<span class="comment">//msg成为响应性数据</span></span><br></pre></td></tr></table></figure>

<h4 id="在setup-中使用methods"><a href="#在setup-中使用methods" class="headerlink" title="在setup()中使用methods"></a>在<code>setup()</code>中使用<code>methods</code></h4><p>直接在<code>setup()</code>中定义函数，要使用的话要在<code>return</code>语句中返回</p>
<h4 id="emit自定义事件"><a href="#emit自定义事件" class="headerlink" title="emit自定义事件"></a>emit自定义事件</h4><p><code>setup()</code>中接收第二个参数<code>context</code>，context对象有个<code>emit</code>属性，可以直接解构出来用于emit自定义事件</p>
<p>也可以和<code>optionsAPI</code>采取相同的方式<code>emit</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button @click=&quot;removeList(1)&quot;&gt;删除列表1&lt;/button&gt;</span><br><span class="line">  &lt;button @click=&quot;$emit(&#x27;remove2&#x27;)&quot;&gt;删除2&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    props:[],</span><br><span class="line">    emits:[&#x27;remove&#x27;,&#x27;remove2&#x27;],</span><br><span class="line">    setup(props,&#123;emit&#125;) &#123;</span><br><span class="line">      function removeList(id) &#123;</span><br><span class="line">        emit(&#x27;remove&#x27;,id);</span><br><span class="line">      &#125;</span><br><span class="line">      return &#123;removeList&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="使用生命周期钩子"><a href="#使用生命周期钩子" class="headerlink" title="使用生命周期钩子"></a>使用生命周期钩子</h4><p>在<code>compositionAPI</code>中生命周期钩子变成了函数形式，接收一个回调函数，所有的生命周期钩子函数名都是<code>on</code>+钩子名</p>
<p>没有<code>beforeCreate</code>和<code>created</code>钩子</p>
<h4 id="provide和inject"><a href="#provide和inject" class="headerlink" title="provide和inject"></a><code>provide</code>和<code>inject</code></h4><p>在<code>compositionAPI</code>中<code>provide</code>和<code>inject</code>变成了函数形式</p>
<p>在<code>setup()</code>中使用<code>provide()</code>,它接收两个参数，参数名和参数值</p>
<p>在<code>inject()</code>传入参数名，赋值给变量即可使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">provide</span>(<span class="string">&#x27;title&#x27;</span>,movie.<span class="property">title</span>)</span><br><span class="line"><span class="title function_">inject</span>(<span class="string">&#x27;title&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>如果要传递响应性数据，可以使用<code>toRef</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">provide</span>(<span class="string">&#x27;title&#x27;</span>,<span class="title function_">toRef</span>(movie.<span class="property">value</span>,<span class="string">&#x27;title&#x27;</span>))</span><br></pre></td></tr></table></figure>

<h4 id="组件功能逻辑复用"><a href="#组件功能逻辑复用" class="headerlink" title="组件功能逻辑复用"></a>组件功能逻辑复用</h4><h4 id="script-setup简化组件代码"><a href="#script-setup简化组件代码" class="headerlink" title="script setup简化组件代码"></a><code>script setup</code>简化组件代码</h4><p>使用<code>script setup</code>可以进一步简化组件内的代码</p>
<p>import的组件可以直接使用无需配置</p>
<p>定义的函数，变量也可以直接在模板中使用，无需返回</p>
<p>使用<code>defineProps()</code>定义props，接收一个数组，定义之后就可以直接在模板中使用，在<code>script</code>中使用可以接收它的返回值</p>
<p>使用<code>defineEmits()</code>定义emits，接收一个数组，定义之后就可以直接在模板中使用，在函数中调用<code>emit()</code>函数上传事件</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>VUE</tag>
        <tag>compositionAPI</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2022/12/10/VUEchapter5/</url>
    <content><![CDATA[<h3 id="Vue与HTTP"><a href="#Vue与HTTP" class="headerlink" title="Vue与HTTP"></a>Vue与HTTP</h3><h4 id="使用axios"><a href="#使用axios" class="headerlink" title="使用axios"></a>使用axios</h4><p>使用yarn添加axios</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn add axios</span><br></pre></td></tr></table></figure>

<p>在<code>script setup</code>中引入</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span> </span><br></pre></td></tr></table></figure>

<p>在生命周期钩子中使用axios</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">onMounted</span>(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">&quot;url&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>添加查询参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">onMounted</span>(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">&quot;url&quot;</span>,&#123;</span><br><span class="line">        <span class="attr">params</span>:&#123;</span><br><span class="line">            <span class="attr">term</span>:<span class="string">&quot;term&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>添加headers</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">onMounted</span>(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">&quot;url&quot;</span>,&#123;&#125;,&#123;</span><br><span class="line">        <span class="attr">headers</span>:&#123;</span><br><span class="line">            <span class="string">&quot;Authorization&quot;</span>: <span class="string">&quot;jwttoken&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="Loading加载状态展示"><a href="#Loading加载状态展示" class="headerlink" title="Loading加载状态展示"></a>Loading加载状态展示</h4><p>思路是设置一个变量，在加载开始和结束时设置不同的值，根据这个值来控制UI</p>
<p>例如在<code>script setup</code>中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Loading</span> = <span class="title function_">ref</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="title function_">onMounted</span>(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="title class_">Loading</span>.<span class="property">value</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">    <span class="title class_">Loading</span>.<span class="property">value</span> = <span class="literal">false</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>然后在模板中加入</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;Loading&quot;</span>&gt;</span></span><br><span class="line">    加载中</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="配置代理解决跨域"><a href="#配置代理解决跨域" class="headerlink" title="配置代理解决跨域"></a>配置代理解决跨域</h4><p>在<code>vite.config.js</code>中配置代理</p>
<p>在<code>defineConfig</code>中添加如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">server</span>:&#123;</span><br><span class="line">  <span class="attr">proxy</span>:&#123;</span><br><span class="line">    <span class="string">&quot;/api&quot;</span>:&#123;</span><br><span class="line">      <span class="attr">target</span>:<span class="string">&quot;http://localhost:3000&quot;</span>,</span><br><span class="line">      <span class="attr">changeOrigin</span>:<span class="literal">true</span>,</span><br><span class="line">      <span class="attr">rewrite</span>:<span class="function">(<span class="params">path</span>)=&gt;</span> &#123;path.<span class="title function_">replace</span>(<span class="string">&quot;/^\/api/&quot;</span>,<span class="string">&quot;&quot;</span>)&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再把需要跨域的请求url加上<code>/api</code>前缀即可</p>
<h4 id="取消请求"><a href="#取消请求" class="headerlink" title="取消请求"></a>取消请求</h4><p>在若干秒后取消请求</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> controller = <span class="keyword">new</span> <span class="title class_">AbortController</span>()</span><br><span class="line">axios.<span class="title function_">get</span>(<span class="string">&quot;url&quot;</span>,&#123;</span><br><span class="line">    <span class="attr">signal</span>:controller.<span class="property">signal</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    controller.<span class="title function_">abort</span>();</span><br><span class="line">&#125;,<span class="number">500</span>)</span><br></pre></td></tr></table></figure>

<p>如果请求被终止了会触发一个错误，可以用try…catch做处理</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2022/12/11/Vue-Router/</url>
    <content><![CDATA[<h3 id="Vue-Router"><a href="#Vue-Router" class="headerlink" title="Vue-Router"></a>Vue-Router</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>使用yarn安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn add vue-router@4</span><br></pre></td></tr></table></figure>

<h4 id="入门使用vue-router"><a href="#入门使用vue-router" class="headerlink" title="入门使用vue-router"></a>入门使用vue-router</h4><ul>
<li><p>在src下创建<code>routes.js</code>文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">PageOne</span> <span class="keyword">from</span> <span class="string">&#x27;./components/PageOne.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">PageTwo</span> <span class="keyword">from</span> <span class="string">&#x27;./components/PageTwo.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">PageThree</span> <span class="keyword">from</span> <span class="string">&#x27;./components/PageThree.vue&#x27;</span></span><br><span class="line"><span class="comment">//导入需要的页面组件</span></span><br><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHistory &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [<span class="comment">//设置路由，接收一个对象数组，配置页面url和要展示的组件</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>:<span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>:<span class="title class_">PageOne</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>:<span class="string">&#x27;/1&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>:<span class="title class_">PageTwo</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>:<span class="string">&#x27;/2&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>:<span class="title class_">PageThree</span>,</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;<span class="comment">//创建路由，必须指定history和routes</span></span><br><span class="line">  <span class="attr">history</span>:<span class="title function_">createWebHistory</span>(),</span><br><span class="line">  routes,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router;<span class="comment">//导出</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>然后在<code>main.js</code>下导入</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./style.css&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./routes&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(router);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>app.vue</code>中设置跳转</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;nav&gt;</span><br><span class="line">    &lt;router-link to=&quot;/&quot;&gt;page one&lt;/router-link&gt;</span><br><span class="line">    &lt;router-link to=&quot;/1&quot;&gt;page two&lt;/router-link&gt;</span><br><span class="line">    &lt;router-link to=&quot;/2&quot;&gt;page three&lt;/router-link&gt;</span><br><span class="line">  &lt;/nav&gt;</span><br><span class="line">  &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line"></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p><code>router-link</code>和<code>router-view</code>是非常重要的标签，一个用于跳转一个用于展示</p>
</li>
</ul>
<h4 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h4><p>在<code>routes.js</code>中配置<code>children</code>参数用于设置嵌套路由</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>:<span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>:<span class="title class_">PageOne</span>,</span><br><span class="line">    <span class="attr">children</span>:[</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">path</span>:<span class="string">&#x27;child1&#x27;</span>,</span><br><span class="line">        <span class="attr">component</span>:<span class="title class_">Child1</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>:<span class="string">&#x27;/1&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>:<span class="title class_">PageTwo</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>:<span class="string">&#x27;/2&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>:<span class="title class_">PageThree</span>,</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>然后在需要用到嵌套路由的组件中配置<code>router-link</code>和<code>router-view</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    page1</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;router-link to=&quot;/child1&quot;&gt;child&lt;/router-link&gt;</span><br><span class="line">  &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h4 id="配置动态路由"><a href="#配置动态路由" class="headerlink" title="配置动态路由"></a>配置动态路由</h4><p>在很多网页应用中某个页面的模板是一样的，但内容根据url变化，这个时候可以使用动态路由</p>
<p>首先在<code>routes.js</code>中配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">path</span>:<span class="string">&#x27;/:id&#x27;</span>,</span><br><span class="line">        <span class="attr">component</span>:<span class="title class_">Page</span>,</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>这样配置表示只要是&#x2F;后有内容的url都会用Page组件渲染</p>
<p>然后我们可以通过获取路由参数来动态获取内容</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//optionsAPI</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">content</span>:<span class="string">&quot;&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> id = <span class="variable language_">this</span>.<span class="property">$route</span>.<span class="property">params</span>.<span class="property">id</span>;<span class="comment">//和routes.js中配置的一样</span></span><br><span class="line">        <span class="comment">//根据id获取内容</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在生命周期中获取动态路由参数，当从固定url跳转到动态url时是没有问题的，但当从动态url跳转到动态url时，vue不会重新渲染组件，因此created钩子不会生效。解决办法是添加watch监听</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="string">&quot;$route.params&quot;</span>:&#123;</span><br><span class="line">      <span class="title function_">handler</span>(<span class="params">params,oldParams</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">id</span> = params.<span class="property">id</span>;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">immediate</span>:<span class="literal">true</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>因为watch不会检测第一次加载的值，因此我们需要使用对象的形式添加<code>immediate:true</code>来让watch监听初次加载的值</p>
<h4 id="访问query"><a href="#访问query" class="headerlink" title="访问query"></a>访问query</h4><p>使用<code>this.$route.query</code>访问</p>
<h4 id="使用命名路由精确控制导航"><a href="#使用命名路由精确控制导航" class="headerlink" title="使用命名路由精确控制导航"></a>使用命名路由精确控制导航</h4><p>当使用动态路由匹配时难免因为优先级等问题出错，这个时候可以为路由命名</p>
<p>在<code>routes.js</code>中设置<code>name</code>属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>:<span class="string">&#x27;/:id&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>:<span class="title class_">PageOne</span>,</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;main&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>:<span class="string">&#x27;/:id&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>:<span class="title class_">PageTwo</span>,</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;other&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>然后在<code>router-link</code>中对<code>name</code>进行匹配</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;router-link :to=&quot;&#123;name:&#x27;main&#x27;, params:&#123;id:1&#125;, &#125;&quot;&gt;child&lt;/router-link&gt;</span><br></pre></td></tr></table></figure>

<p>这样只会跳转到PageOne而不会到PageTwo</p>
<h4 id="路由别名"><a href="#路由别名" class="headerlink" title="路由别名"></a>路由别名</h4><p>在<code>routes.js</code>中设置<code>alias</code>属性设置别名</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>:<span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>:<span class="title class_">PageOne</span>,</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;main&#x27;</span>,</span><br><span class="line">    <span class="attr">alias</span>:[<span class="string">&#x27;/home&#x27;</span>,<span class="string">&#x27;/index&#x27;</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>:<span class="string">&#x27;/:id&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>:<span class="title class_">PageTwo</span>,</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">    <span class="attr">alias</span>:[<span class="string">&#x27;post/:id&#x27;</span>,<span class="string">&#x27;blog/:id&#x27;</span>]</span><br><span class="line">  &#125;, </span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>有动态路由的也要加上动态路由参数</p>
<h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><p>在<code>routes.js</code>中配置<code>redirect</code>属性</p>
<ul>
<li><p>直接重定向到指定url</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">path</span>:<span class="string">&#x27;/post&#x27;</span>,</span><br><span class="line">    <span class="attr">redirect</span>:<span class="string">&#x27;/&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>跳转到指定name的url</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">path</span>:<span class="string">&#x27;/post&#x27;</span>,</span><br><span class="line">    <span class="attr">redirect</span>:&#123;</span><br><span class="line">      <span class="attr">name</span>:<span class="string">&#x27;blog&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>跳转到含有动态参数的url</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>:<span class="string">&#x27;/blog/:id&#x27;</span>,</span><br><span class="line">  <span class="attr">redirect</span>:<span class="function">(<span class="params">to</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">path</span>:<span class="string">`/<span class="subst">$&#123;to.params.id&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以使用name和params的形式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>:<span class="string">&#x27;/blog/:id&#x27;</span>,</span><br><span class="line">  <span class="attr">redirect</span>:<span class="function">(<span class="params">to</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">name</span>:<span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">      <span class="attr">params</span>:&#123;</span><br><span class="line">          <span class="attr">id</span>:to.<span class="property">params</span>.<span class="property">id</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="编程式控制导航"><a href="#编程式控制导航" class="headerlink" title="编程式控制导航"></a>编程式控制导航</h4><p>给按钮添加点击跳转：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;button @click=&quot;$router.push(&#x27;/&#x27;)&quot;&gt;return&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<p>也可以使用对象形式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;button @click=&quot;$router.push(&#123;name:&#x27;home&#x27;,params:&quot;1&quot;&#125;)&quot;&gt;return&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<p>push会将要跳转的页面加入页面栈中</p>
<p>使用replace则是用跳转的页面替换当前页面</p>
<p><code>$router</code>还有一个<code>go</code>方法，用于前进或者后退若干页</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;button @click=&quot;$router.go(1)&gt;return&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<h4 id="为当前导航设置样式"><a href="#为当前导航设置样式" class="headerlink" title="为当前导航设置样式"></a>为当前导航设置样式</h4><p>当<code>router-link</code>对应的url为当前url时，vue会为<code>router-link</code>自动添加一个<code>router-link-active</code>的class,可以为其设置样式</p>
<p>这种设置样式会将父导航也设置上样式。如果想要精确设置，可以设置<code>router-link-exact-active</code>的样式</p>
<h4 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h4><h5 id="全局导航守卫"><a href="#全局导航守卫" class="headerlink" title="全局导航守卫"></a>全局导航守卫</h5><p>全局导航守卫包含<code>beforeEach</code>,<code>beforeResolve</code>,<code>afterEach</code></p>
<p>在<code>router.js</code>中添加全局导航守卫</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to,<span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(to);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">from</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>to</code>包含了要跳转的url的信息，<code>from</code>包含了原url信息</p>
<p>可以通过全局导航守卫控制跳转，如</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to,<span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(to.<span class="property">path</span>.<span class="title function_">startsWith</span>(<span class="string">&quot;/child&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;/2&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这代表当要跳转到的url以<code>/child</code>开始（如<code>/child</code>，<code>/child/1</code>等）时会重定向到<code>/2</code></p>
<p>return的值除了具体路径外，还可以为<code>false</code>，代表不跳转，或者为对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to,<span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(to.<span class="property">path</span>.<span class="title function_">startsWith</span>(<span class="string">&quot;/child&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="title class_">PageTwo</span>,</span><br><span class="line">      <span class="attr">query</span>:&#123;</span><br><span class="line">        <span class="attr">a</span>:<span class="number">2</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>同理有<code>beforeResolve</code>，<code>afterEach</code></p>
<h5 id="路由导航守卫"><a href="#路由导航守卫" class="headerlink" title="路由导航守卫"></a>路由导航守卫</h5><p>路由导航守卫支持设置<code>beforeEnter</code>导航守卫，在<code>routes</code>数组中配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>:<span class="string">&#x27;/2&#x27;</span>,</span><br><span class="line">  <span class="title function_">beforeEnter</span>(<span class="params">to,<span class="keyword">from</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/1&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">component</span>:<span class="title class_">PageThree</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>也可以把函数抽离出来，使用数组形式配置，使得多个路由可以公用一个导航守卫</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>:<span class="string">&#x27;/2&#x27;</span>,</span><br><span class="line">  <span class="attr">beforeEnter</span>: [check]</span><br><span class="line">  <span class="attr">component</span>:<span class="title class_">PageThree</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>对于动态路由之间跳转不会生效，因为是在同一个对象下跳转</p>
<h5 id="组件导航守卫"><a href="#组件导航守卫" class="headerlink" title="组件导航守卫"></a>组件导航守卫</h5><p>这里的导航守卫只能在<code>routes</code>数组中配置的组件中使用，正常的组件无法使用</p>
<p>组件导航守卫有<code>beforeRouteEnter</code>，<code>beforeRouteUpdate</code>，<code>beforeRouteLeave</code></p>
<p><code>beforeRouteEnter</code>是在第一次渲染组件时执行，如果是动态参数切换时无法触发，此时可以使用<code>beforeRouteUpdate</code></p>
<h4 id="路由meta元数据"><a href="#路由meta元数据" class="headerlink" title="路由meta元数据"></a>路由meta元数据</h4><p>在<code>routes</code>配置中添加meta配置项添加属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>:<span class="string">&#x27;/1&#x27;</span>,</span><br><span class="line">  <span class="attr">component</span>:<span class="title class_">PageTwo</span>,</span><br><span class="line">  <span class="attr">name</span>:<span class="title class_">PageTwo</span>,</span><br><span class="line">  <span class="attr">meta</span>:&#123;<span class="attr">private</span>:<span class="literal">true</span>&#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>这样就可以在导航守卫中获取到元数据并根据数据值进行相关操作（比如判断页面是否需要登陆）</p>
<h4 id="控制滚动行为"><a href="#控制滚动行为" class="headerlink" title="控制滚动行为"></a>控制滚动行为</h4><p>在createRouter函数传入的配置项中加入<code>scrollBehavior()</code>配置项</p>
<p>如要让滚动条在跳转时回到顶部</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="attr">history</span>:<span class="title function_">createWebHistory</span>(),</span><br><span class="line">  routes,</span><br><span class="line">  <span class="title function_">scrollBehavior</span>(<span class="params">to,<span class="keyword">from</span>,savedPosition</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">top</span>:<span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>top的值，正数表示向下偏移，负数表示向上偏移</p>
<p>也可以设置平滑滚动</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="attr">history</span>:<span class="title function_">createWebHistory</span>(),</span><br><span class="line">  routes,</span><br><span class="line">  <span class="title function_">scrollBehavior</span>(<span class="params">to,<span class="keyword">from</span>,savedPosition</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">top</span>:<span class="number">0</span>,</span><br><span class="line">      <span class="attr">behavior</span>:<span class="string">&#x27;smooth&#x27;</span>  </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>savedPosition</code>表示原有位置</p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
  </entry>
  <entry>
    <title>js进阶：call，apply，bind</title>
    <url>/2022/10/12/call%EF%BC%8Capply%EF%BC%8Cbind/</url>
    <content><![CDATA[<h3 id="call，apply，bind"><a href="#call，apply，bind" class="headerlink" title="call，apply，bind"></a>call，apply，bind</h3><p>​	call，apply，bind的作用是改变函数执行时的上下文，简单来说就是改变this的指向</p>
<ul>
<li><code>apply()</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">...args</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>,args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">myname</span>:<span class="string">&quot;张三&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn.<span class="title function_">apply</span>(obj,[<span class="number">1</span>,<span class="number">2</span>]); <span class="comment">// this会变成传入的obj，传入的参数必须是一个数组；</span></span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">// this指向window</span></span><br></pre></td></tr></table></figure>

<p><code>apply()</code>接收两个参数，第一个参数为this的指向，第二个参数为一个数组，指要传入的参数</p>
<p>改变<code>this</code>指向后原函数会立即执行，且此方法只是临时改变<code>this</code>指向一次</p>
<p>如果没有第一个参数默认指向window</p>
<ul>
<li><code>call()</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">...args</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>,args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">myname</span>:<span class="string">&quot;张三&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn.<span class="title function_">call</span>(obj,<span class="number">1</span>,<span class="number">2</span>); <span class="comment">// this会变成传入的obj，传入参数列表；</span></span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">// this指向window</span></span><br></pre></td></tr></table></figure>

<p>与<code>apply()</code>相似，但传入的参数不再是数组而是一个列表</p>
<p>如果没有第一个参数默认指向window</p>
<ul>
<li><code>bind()</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">...args</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>,args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">myname</span>:<span class="string">&quot;张三&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bindFn = fn.<span class="title function_">bind</span>(obj); <span class="comment">// this 也会变成传入的obj ，bind不是立即执行需要执行一次</span></span><br><span class="line"><span class="title function_">bindFn</span>(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">// this指向obj</span></span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">// this指向window</span></span><br></pre></td></tr></table></figure>

<p>返回一个函数，可以多次使用</p>
<p>如果没有第一个参数默认指向window</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>js进阶</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>js进阶</tag>
        <tag>this指向</tag>
        <tag>call</tag>
        <tag>apply</tag>
        <tag>bind</tag>
      </tags>
  </entry>
  <entry>
    <title>git常用指令</title>
    <url>/2022/10/13/git/</url>
    <content><![CDATA[<h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><ul>
<li><p>初始化一个仓库</p>
<p><code>git init</code></p>
</li>
<li><p>追踪&#x2F;暂存仓库中的文件</p>
<p><code>git add *</code></p>
</li>
<li><p>查看文件状态</p>
<p><code>git status</code></p>
</li>
<li><p>提交</p>
<p><code>git commit</code></p>
<p><code>git commit -m &#39;commitWord&#39;</code></p>
<p><code>git commit -a -m &#39;commitWord&#39;//暂存并提交</code></p>
</li>
<li><p>克隆</p>
<p><code>git clone URL projectName//克隆仓库并给本地项目命名</code></p>
</li>
<li><p>查看文件区别</p>
<p><code>git diff</code>:当前文件和暂存区域快照之间的差异。 也就是修改之后还没有暂存起来的变化内容。</p>
<p><code>git diff --staged</code>:比对已暂存文件与最后一次提交的文件差异</p>
</li>
<li><p>移除文件</p>
<p><code>git rm fileName</code></p>
<p><code>git rm -f fileName</code>:强制删除已经添加到暂存区和提交的文件</p>
<p><code>git rm --cached fileName</code>:取消对文件的追踪（不删除文件）</p>
<p><code>git mv fileName1 fileName2</code>:文件重命名</p>
</li>
<li><p>查看提交历史</p>
<p><code>git log</code></p>
<p><code>git log -p -num</code>:打印每次提交的差异并限制涉及到的提交数目（最近num次提交）</p>
<p><code>git log --stat</code>:打印提交的简洁信息</p>
<p><code>git log --graph</code>:以图形界面显示</p>
<p><code>git log --oneline</code>:<code>--pretty=oneline和--abbrev-commit</code>合用</p>
<p><code>git log --abnrev-commit</code>:显示较短的校验字符</p>
<p><code>git log --pretty</code>:使用其他格式显示</p>
<ul>
<li><code>oneline</code>:每个提交放在一行显示</li>
<li><code>format</code>:定制显示格式</li>
</ul>
<p><code>git log --since</code>:从时间上限制某时间之后的提交显示如<code>git log --since=2.weeks</code>限制两周内的提交</p>
<p><code>git log -S string</code>:打印添加或删除了某字符串的提交</p>
<p><code>git log --author name</code> :显示包含指定作者名的提交</p>
<p><code>git log --grep string</code> :显示说明中包含指定字符串</p>
<p><code>git log --committer string</code>显示包含指定提交者的提交</p>
<p><code>git log --util</code>:从时间上限制某时间之前的提交</p>
</li>
<li><p>撤销操作</p>
<p><code>git commit --amend</code> :重新进行一次提交</p>
<p><code>git reset HEAD filename</code>:取消对某文件的暂存</p>
<p><code>git checkout -- filename</code>:撤销对某文件的修改（还原成上次提交的样子）</p>
</li>
<li><p>查看远程仓库</p>
<p><code>git remote</code></p>
<p><code>git remote -v</code>:会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL</p>
</li>
<li><p>添加远程仓库</p>
<p><code>git clone</code>会自行添加远程仓库</p>
<p><code>git remote add &lt;shortName&gt; &lt;URL&gt;</code>:添加远程仓库并给定一个简写名称</p>
</li>
<li><p>抓取与拉取</p>
<p><code>git fetch &lt;remote&gt;</code>:从远程仓库中拉取还没有的数据，不会改变当前工作，抓取到的内容需要手动合并</p>
<p><code>git pull</code>抓取并合并</p>
</li>
<li><p>推送</p>
<p><code>git push &lt;remote&gt; &lt;branch&gt;</code>把branch分支推送到remote上</p>
</li>
<li><p>重命名远程仓库</p>
<p><code>git remote rename &lt;originName&gt; &lt;nowName&gt;</code></p>
</li>
<li><p>移除一个远程仓库</p>
<p><code>git remote rm</code></p>
</li>
<li><p>查看标签</p>
<p><code>git tag </code></p>
<p><code>git tag -l &lt;string&gt;</code>查看含有某字符串的标签</p>
</li>
<li><p>创建标签</p>
<p><code>git tag -a &lt;tagName&gt; -m &lt;tagInfo&gt;</code>创建标签并附加信息</p>
<p><code>git tag &lt;tagName&gt;</code>创建轻量级标签（<code>git show</code>不显示）</p>
<p><code>git tag -a &lt;tagName&gt; &lt;hashCode&gt;</code>补标签，需要指定之前的某次提交的全部或部分校验和</p>
</li>
<li><p>推送标签</p>
<p><code>git push &lt;remote&gt; --tags</code></p>
</li>
<li><p>删除标签</p>
<p><code>git tag -d &lt;tagname&gt;//从本地删除标签</code></p>
<p><code>git push &lt;remote&gt; :ref/tag/&lt;tagName&gt;//从远程仓库中删除标签</code></p>
</li>
<li><p>别名</p>
<p><code>git config --global alias.&lt;shortName&gt; &lt;originName&gt;</code></p>
</li>
<li><p>创建分支</p>
<p><code>git branch &lt;branchName&gt;</code>:新建分支</p>
</li>
<li><p>切换分支</p>
<p><code>git checkout &lt;branchName&gt;</code></p>
<p><code>git checkout -b &lt;branchName&gt;</code>:创建并切换到创建的分支</p>
</li>
<li><p>合并分支</p>
<p><code>git merge &lt;branchName&gt;</code>将某分支合并到当前分</p>
</li>
<li><p>删除分支</p>
<p><code>git branch -d &lt;branchName&gt;</code></p>
<p><code>git branch -D &lt;branchName&gt;</code>强制删除某分支</p>
</li>
<li><p>查看分支列表</p>
<p><code>git branch</code></p>
<p><code>git branch -v</code>查看每个分支最后一次提交</p>
<p><code>git branch --merged</code>查看已经合并到当前分支的分支</p>
<p><code>git branch --no-merged</code>:查看未合并到当前分支的分支</p>
</li>
<li><p>删除远程分支</p>
<p><code>git push &lt;remote&gt; --delete &lt;branchName&gt;</code></p>
</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>参考</tag>
      </tags>
  </entry>
  <entry>
    <title>Welcome to my BLOG!</title>
    <url>/2022/10/12/hello-world/</url>
    <content><![CDATA[<p>欢迎来到我的博客<br>我会在这里记录自己的学习，生活<br>谢谢你的到来！！</p>
]]></content>
      <categories>
        <category>欢迎</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title>我的ppt制作经验</title>
    <url>/2022/10/12/ppt%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[<h2 id="我的PPT设计思路"><a href="#我的PPT设计思路" class="headerlink" title="我的PPT设计思路"></a>我的PPT设计思路</h2><h3 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h3><ol>
<li><p>尽量别用WPS！！！！WPS的使用体验较差，与PowerPoint相比卡顿明显，广告多，许多重要功能都被阉割或收费，现在购买的Windows系统笔记本电脑大多数都带有PowerPoint的较高版本，使用起来轻便自然，即使没有，也可以拼车购买365版本，因此建议不要使用WPS！优秀的ppt模板可以自己设计</p>
</li>
<li><p>可能需要的网站：</p>
<ul>
<li><a href="https://www.iconfont.cn/">iconfont-阿里巴巴矢量图标库</a>阿里巴巴矢量图标库里面提供了大量的免费图标，比PowerPoint提供的图标更多更广，可以选择颜色下载方便使用，当然若PowerPoint中的图标能满足需求也可以使用自带图标</li>
<li><a href="https://huaban.com/">花瓣网</a>花瓣网中有不少ppt精致模板，平面设计素材，当你不知道如何构思ppt排版，主题配色时可以参考然后实现</li>
<li>一个能够持续得到学习的（视频）网站。<a href="https://www.bilibili.com/">哔哩哔哩 (゜-゜)つロ 干杯~-bilibili</a>b站上有足够多的ppt制作up主，无论是通过主动学习还是被动被推送都可以获取到制作ppt的技巧视频，足够在同辈面前炫技了。视频资源能够以直观的形式看到制作的效果，你能够选择自己看中的特效进行学习</li>
<li>一个清晰的图片网，必应图片的筛选功能还可以使用，也可以去一些壁纸网站找背景图，如<a href="https://wallhaven.cc/">Awesome Wallpapers - wallhaven.cc</a></li>
<li>推荐几个B站up<ul>
<li><a href="https://space.bilibili.com/395619513/?spm_id_from=333.999.0.0">旁门左道PPT的个人空间_哔哩哔哩_bilibili</a>视频内容偏向实用化，模板化</li>
<li><a href="https://space.bilibili.com/76949949/?spm_id_from=333.999.0.0">黑白间设计的个人空间_哔哩哔哩_bilibili</a>视频内容有很多好看的特效</li>
<li><a href="https://space.bilibili.com/282229936/?spm_id_from=333.999.0.0">早晨PPT的个人空间_哔哩哔哩_bilibili</a>视频内容与黑白间设计较为相似</li>
<li>还有很多up，根据自己观看判断视频质量做出选择</li>
</ul>
</li>
</ul>
</li>
<li><p>入门PPT</p>
<p>你需要学习PPT的基础操作，直接去b站搜索ppt教程即可，有很多入门视频，学习一下基本操作</p>
</li>
<li><p>一些设计思路</p>
<p>了解一些设计风格，如拟物（skeuomorphism），扁平（flat design），物料（material design），新拟态（neumorphism），玻璃态（glassmorphism），泥陶态（claymorphism）</p>
</li>
</ol>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><ol>
<li>学习了ppt的基础操作之后，当你需要制作一个ppt时，区分一下使用场景</li>
</ol>
<ul>
<li><p>介绍，宣传类</p>
<p>介绍类往往可以把ppt制作的比较华丽，特效什么的可以尽量往里面加，但不能显得过于紊乱，最好挑选一个主题配色，在一个主体配色下对细节进行刻画</p>
</li>
<li><p>正式场景（如答辩）</p>
<p>学校答辩往往比较注重内容，在特效制作方面可以放弃一些，重点在于内容的排版，有时候白底黑字，配上合适图片即可，在静态视觉上做足功夫，动态视觉不能占主动。一般学校答辩选择一个模板就行</p>
</li>
<li><p>教师用</p>
<p>教师用ppt比较随意，毕竟大家从小到大看的教师ppt都是白板黑字，大量文字堆积，和word无异，没有美感，但能达到教学目的，便于学生课后学习，能服务于目的就是好ppt</p>
</li>
<li><p>一般来说，注意一些通用技巧就可以做出让人眼前一亮的ppt了！</p>
</li>
</ul>
<ol start="2">
<li>在制作ppt之前，还要特别注意一下演示时使用的版本，如PowerPoint2019加入了平滑切换功能，但如果在演示时要求的设备上使用的是2016版本，就无法运用了。因此使用自己的电脑投屏演示是最好的！</li>
</ol>
<h4 id="通用思路"><a href="#通用思路" class="headerlink" title="通用思路"></a>通用思路</h4><p>无论你需要做什么ppt，下面的思路基本上是通用的</p>
<ul>
<li><p>空白模板：如果你决定不使用模板，就新建一个空白模板</p>
<p><img src="/image/img_11.png" alt="image-20220804204614805"></p>
</li>
<li><p>文字占比不能过大：ppt的主要观感应该是图片，特效等迎合视觉的元素，过多的文字起不到效果</p>
</li>
<li><p>文字的位置：文字不能太靠边，文字太靠边会让人产生ppt页面过于拥挤等不良感受，下图的文字位置就很好(蓝框内写文字)</p>
<p><img src="/image/img_12.png" alt="image-20220804205116600"></p>
</li>
<li><p>动效时间不要太长！动效（页面动画，切换动画等）的时间一般不能太长（除非你是纯ppt动画），过长的时间不仅会导致观看者等待，感到视觉疲劳，也会使演示者在演示过程中陷入等待，尴尬。</p>
</li>
<li><p>选择的动画要贴合实际使用场景，比如两个页面之间的关系是递进的，则不能使用”破坏“相关的切换特效</p>
</li>
<li><p>平滑切换很强大很方便很有用！因此我极力推荐使用2019以上的ppt版本</p>
</li>
<li><p>ppt中也可以参考一些网页特效进行复刻，网页中使用的css特效在ppt中部分也有直接的使用按钮，如鼠标悬停，鼠标点击，结合平滑可以做到类似网页特效</p>
</li>
<li><p>图片选择也要合适，不能单纯凭借个人喜好而选择不符合主题的图片，如背景图要简单，颜色不能过多，如果必须要使用得加遮罩</p>
</li>
</ul>
<h3 id="具体思路"><a href="#具体思路" class="headerlink" title="具体思路"></a>具体思路</h3><ul>
<li><p>有关文字内容：面对大量的描述文字，需要先提取主干，如关键词。然后将关键词作为标题或小标题，小标题下面就是一句话长度的描述内容，不能太多，观众能明白大意即可。几个小标题之间通过图形进行联系（如箭头表示推进），每个标题可以配一个相关的图片暗示内容。文字占比不多但必不可少，如</p>
<p><img src="/image/img_12.png" alt="image-20220804205116600"></p>
<p>左边是图片提示主要内容，右边加粗黑字是标题，下面的是主要内容，讲述者根据主要内容的提示就可以进行讲解，观看者也能知道具体在讲什么，整个ppt观感体验也不错</p>
</li>
<li><p>利用平滑切换进行过渡</p>
<p>想要做出好看的过渡效果，平滑切换是必不可少的。学习过前端相关知识的同学可以很容易理解，平滑切换的原理就和css中的<code>transition</code>类似，只不过是在页面之间运用。想要制作令人眼前一亮的平滑切换效果，必要时还得修改元素名。平滑切换做出来的效果千奇百怪，视差动画这样很强的操作更是离不开平滑切换。下面展示几个平滑切换的应用实例</p>
<p><a href="https://www.bilibili.com/video/BV1mA41137Bo?spm_id_from=333.999.0.0&vd_source=ea0b821b0c66dd7f6257ac303626c797">这一波操作瞬间让PPT逼格提升数倍！【推荐必看】_哔哩哔哩_bilibili</a></p>
<p><a href="https://www.bilibili.com/video/BV1WV411x7v9?spm_id_from=333.999.0.0&vd_source=ea0b821b0c66dd7f6257ac303626c797">PPT过渡，竟能如此创意！_哔哩哔哩_bilibili</a></p>
<p><a href="https://www.bilibili.com/video/BV1cr4y1173r?spm_id_from=333.999.0.0&vd_source=ea0b821b0c66dd7f6257ac303626c797">不敢相信！外网这个PPT视差动画，让图片变3D版了【旁门左道】_哔哩哔哩_bilibili</a></p>
<p><a href="https://www.bilibili.com/video/BV1ub4y1U7EP?spm_id_from=333.999.0.0">余承东排面儿！华为发布会上用的平滑切换PPT，逼格…【旁门左道】_哔哩哔哩_bilibili</a></p>
<p>利用平滑切换也可以代替一些动画，但注意平滑时间不能太长，切换仅仅是一个让人眼前一亮的功能，占比不能大</p>
</li>
<li><p>如果你觉得自己的ppt背景过于单调，也可以选择使用视频作为背景</p>
</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>ppt</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell入门笔记</title>
    <url>/2022/10/15/shell/</url>
    <content><![CDATA[<h3 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h3><h4 id="声明和使用变量"><a href="#声明和使用变量" class="headerlink" title="声明和使用变量"></a>声明和使用变量</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">声明</span></span><br><span class="line">varName=&#x27;name&#x27;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用</span></span><br><span class="line">echo $&#123;varName&#125;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设为只读</span></span><br><span class="line">readonly varName</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除变量</span></span><br><span class="line">unset varName</span><br></pre></td></tr></table></figure>

<h4 id="字符串变量"><a href="#字符串变量" class="headerlink" title="字符串变量"></a>字符串变量</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">字符串拼接</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用双引号拼接</span></span><br><span class="line">greeting=&quot;hello, &quot;$your_name&quot; !&quot;</span><br><span class="line">greeting_1=&quot;hello, $&#123;your_name&#125; !&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用单引号拼接（greeting_3不会正常拼接）</span></span><br><span class="line">greeting_2=&#x27;hello, &#x27;$your_name&#x27; !&#x27;</span><br><span class="line">greeting_3=&#x27;hello, $&#123;your_name&#125; !&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">提取子字符串(如从第二个字符开始截取4个字符)</span></span><br><span class="line">echo $&#123;string:1:4&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查找子串(如匹配12则返回1的位置1)</span></span><br><span class="line">string=&quot;123456&quot;</span><br><span class="line">echo `expr index $&#123;string&#125; 12`</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">获取字符串长度</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;<span class="comment">#string&#125;</span></span></span><br></pre></td></tr></table></figure>

<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">定义数组</span></span><br><span class="line">array=(1 2 3 4 5)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">定义数组分量</span></span><br><span class="line">array[0]=value0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">读取数组某个元素</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;array[0]&#125;</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">读取数组所有元素</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;array[@]&#125;</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">获取数组长度</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;<span class="comment">#array[@]&#125;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">获取单个元素长度</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;<span class="comment">#array[num]&#125;</span></span></span><br></pre></td></tr></table></figure>

<h4 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h4><p>在命令行传参</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./text.sh 1 2 4</span><br></pre></td></tr></table></figure>

<p>shell中使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $0</span><br><span class="line">echo $1</span><br><span class="line">echo $2</span><br></pre></td></tr></table></figure>

<h4 id="test"><a href="#test" class="headerlink" title="test"></a>test</h4><p>test用于检测，可以进行数字字符文件三方面的检测</p>
<ul>
<li><p>数值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-eq #==</span><br><span class="line">-ne #!=</span><br><span class="line">-gt #&gt;</span><br><span class="line">-ge #&gt;=</span><br><span class="line">-lt #&lt;</span><br><span class="line">-le #&lt;=</span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=</span><br><span class="line">!=</span><br><span class="line">-z &lt;string&gt; #长度为0为真</span><br><span class="line">-n &lt;string&gt; #长度不为0为真</span><br></pre></td></tr></table></figure>
</li>
<li><p>文件测试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-e #存在</span><br><span class="line">-r #存在且可读</span><br><span class="line">-w #存在且可写</span><br><span class="line">-x #存在且可执行</span><br><span class="line">-s #存在且至少有一个字符</span><br><span class="line">-d #存在且为目录</span><br><span class="line">-f #存在且为普通文件</span><br><span class="line">-c #为字符特殊文件</span><br><span class="line">-b #为块特殊文件</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="if-x2F-else"><a href="#if-x2F-else" class="headerlink" title="if&#x2F;else"></a>if&#x2F;else</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if ((condition))</span><br><span class="line">then</span><br><span class="line">...</span><br><span class="line">else</span><br><span class="line">...</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>没有else内容时不能带上else</p>
<p>if&#x2F;else经常与test结合使用</p>
<h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for &lt;name&gt; in item1 item2...itemN</span><br><span class="line">do</span><br><span class="line">...</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">while &lt;condition&gt;</span><br><span class="line">do</span><br><span class="line">...</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h4 id="until"><a href="#until" class="headerlink" title="until"></a>until</h4><p>until循环判定条件为真时结束</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">until condition</span><br><span class="line">do</span><br><span class="line">...</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h4 id="case…esac"><a href="#case…esac" class="headerlink" title="case…esac"></a>case…esac</h4><p>相当于switch…case</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">case &lt;name&gt; in</span><br><span class="line">&lt;var1&gt;)</span><br><span class="line">...</span><br><span class="line">;;</span><br><span class="line">&lt;var2&gt;)</span><br><span class="line">...</span><br><span class="line">;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>

<h4 id="跳出循环"><a href="#跳出循环" class="headerlink" title="跳出循环"></a>跳出循环</h4><p>break和continue</p>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[function] &lt;name&gt;() &#123;</span><br><span class="line">...</span><br><span class="line">[return &lt;var&gt;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不写return就返回最后一条语句的返回值</p>
<p>传参直接在函数名后面写,函数获取按从1开始的顺序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">fun() &#123;</span><br><span class="line">echo $1</span><br><span class="line">echo $4</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun 1 2 3 4</span><br></pre></td></tr></table></figure>

<p>函数还可以获取一些特殊参数,如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="comment"># 参数个数</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">* 以字符串显示传递的参数</span></span><br></pre></td></tr></table></figure>

<h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">command &gt; file #将输出重定向到file</span><br><span class="line">command &lt; file #将输入从file定向过来</span><br><span class="line">command &gt;&gt; file #以追加模式重定向输入</span><br><span class="line">command &gt; /dev/null #执行命令但不显示</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>一个前端小实例：拖动选项卡（原生实现）</title>
    <url>/2022/10/12/%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E5%B0%8F%E5%AE%9E%E4%BE%8B%EF%BC%9A%E6%8B%96%E5%8A%A8%E9%80%89%E9%A1%B9%E5%8D%A1/</url>
    <content><![CDATA[<h3 id="一个前端小实例：拖动选项卡"><a href="#一个前端小实例：拖动选项卡" class="headerlink" title="一个前端小实例：拖动选项卡"></a>一个前端小实例：拖动选项卡</h3><ul>
<li><p>先看效果</p>
<p><img src="/image/img_24.png" alt="image-20220915202641713"></p>
<p><img src="/image/img_25.png" alt="image-20220915202908432"></p>
<p><img src="/image/img_26.png" alt="image-20220915203030395"></p>
<p><img src="/image/img_27.png" alt="image-20220915203108971"></p>
<p>鼠标可以点击选中并且拖拽卡片，卡片能够在合适地方插入</p>
</li>
<li><p>HTML部分</p>
<ul>
<li><p>先看代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;demo1.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;card card1&quot;</span>&gt;</span>card1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;card card2&quot;</span>&gt;</span>card2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;card card3&quot;</span>&gt;</span>card3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;card card4&quot;</span>&gt;</span>card4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;demo1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span>非常简单，四个`div`对应四个卡片，并链接JavaScript和CSS</span><br></pre></td></tr></table></figure>
</li>
<li><p>非常简单，四个<code>div</code>代表四个卡片</p>
</li>
</ul>
</li>
<li><p>CSS部分</p>
<ul>
<li><p>先看代码</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.card</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">25px</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>: lightgray <span class="number">0</span> <span class="number">0</span> <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">40px</span>;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&quot;Century Gothic&quot;</span>, serif;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">0.5s</span>;</span><br><span class="line">  <span class="attribute">cursor</span>: pointer;</span><br><span class="line">  <span class="attribute">left</span>: <span class="built_in">calc</span>(<span class="number">50%</span> - <span class="number">250px</span>);</span><br><span class="line">  user-select: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.card1</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(to bottom right,<span class="number">#91AD9E</span>,<span class="number">#979771</span>);</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.card2</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(to bottom right,<span class="number">#E8D3C0</span>, <span class="number">#D89C7A</span>);</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">190px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.card3</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(to bottom right,<span class="number">#C2CEDC</span>, <span class="number">#B0B1B6</span>);</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">360px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.card4</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(to bottom right,<span class="number">#ECCED0</span>, <span class="number">#B57C82</span>);</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">530px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.card_active</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">520px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">170px</span>;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">25px</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>: gray <span class="number">0</span> <span class="number">0</span> <span class="number">40px</span>;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">40px</span>;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&quot;Century Gothic&quot;</span>, serif;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">transition</span>: width <span class="number">0.3s</span>,height <span class="number">0.3s</span>;</span><br><span class="line">  <span class="attribute">cursor</span>: pointer;</span><br><span class="line">  <span class="attribute">left</span>: <span class="built_in">calc</span>(<span class="number">50%</span> - <span class="number">260px</span>);</span><br><span class="line">  user-select: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.card1_active</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(to bottom right,<span class="number">#91AD9E</span>,<span class="number">#979771</span>);</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.card2_active</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(to bottom right,<span class="number">#E8D3C0</span>, <span class="number">#D89C7A</span>);</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">180px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.card3_active</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(to bottom right,<span class="number">#C2CEDC</span>, <span class="number">#B0B1B6</span>);</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">350px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.card4_active</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(to bottom right,<span class="number">#ECCED0</span>, <span class="number">#B57C82</span>);</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">520px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>同样很简单，先对card选择来表示所有卡片的样式，这里我选择了绝对定位，这样可以使卡片在选中改变高度时不会影响到其他元素。然后对每个卡片做个性化调整，颜色我全部选择了莫兰迪色系加渐变。之后的card_active是指选中的卡片的样式，改变的宽高和left，top保证选中时能够居中。card的<code>transition</code>属性和card_active的略有不同,因为在拖拽时涉及到top的改变，card_active不能给top设置过渡，否则会卡顿</p>
</li>
</ul>
</li>
<li><p>JavaScript部分</p>
<ul>
<li><p>先看代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cardList=<span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;.card&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> isEmpty=&#123;</span><br><span class="line">  <span class="attr">card1</span>:<span class="literal">true</span>,</span><br><span class="line">  <span class="attr">card1_name</span>:<span class="literal">null</span>,</span><br><span class="line">  <span class="attr">card2</span>:<span class="literal">true</span>,</span><br><span class="line">  <span class="attr">card2_name</span>:<span class="literal">null</span>,</span><br><span class="line">  <span class="attr">card3</span>:<span class="literal">true</span>,</span><br><span class="line">  <span class="attr">card3_name</span>:<span class="literal">null</span>,</span><br><span class="line">  <span class="attr">card4</span>:<span class="literal">true</span>,</span><br><span class="line">  <span class="attr">card4_name</span>:<span class="literal">null</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; cardList.<span class="property">length</span>;i++) &#123;</span><br><span class="line">  cardList[i].<span class="property">onmousedown</span>=<span class="function">(<span class="params">e</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> originalTop=e.<span class="property">clientY</span>;</span><br><span class="line">    <span class="keyword">const</span> top=<span class="title function_">getTop</span>(i);</span><br><span class="line">    cardList[i].<span class="property">className</span>=<span class="string">`card_active card<span class="subst">$&#123;i+<span class="number">1</span>&#125;</span>_active`</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">onmousemove</span>=<span class="function">(<span class="params">e</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">const</span> y=e.<span class="property">clientY</span>;</span><br><span class="line">      cardList[i].<span class="property">style</span>.<span class="property">top</span>=<span class="string">`<span class="subst">$&#123;top - (originalTop - y)&#125;</span>px`</span>;</span><br><span class="line">      <span class="title function_">changeCard</span>(cardList[i].<span class="property">offsetTop</span>,i);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">onmouseup</span>=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      cardList[i].<span class="property">className</span>=<span class="string">`card card<span class="subst">$&#123;i+<span class="number">1</span>&#125;</span>`</span></span><br><span class="line">      <span class="keyword">const</span> topNow=cardList[i].<span class="property">offsetTop</span>;</span><br><span class="line">      <span class="title function_">layCard</span>(i,topNow);</span><br><span class="line">      <span class="variable language_">document</span>.<span class="property">onmousedown</span>=<span class="literal">null</span>;</span><br><span class="line">      <span class="variable language_">document</span>.<span class="property">onmousemove</span>=<span class="literal">null</span>;</span><br><span class="line">      <span class="variable language_">document</span>.<span class="property">onmouseup</span>=<span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getTop</span>(<span class="params">i</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(cardList[i].<span class="property">offsetTop</span>)</span><br><span class="line">  <span class="keyword">return</span> cardList[i].<span class="property">offsetTop</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">layCard</span>(<span class="params">i,topNow</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(topNow&lt;<span class="number">95</span>) &#123;</span><br><span class="line">    cardList[i].<span class="property">style</span>.<span class="property">top</span>=<span class="string">&#x27;20px&#x27;</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(topNow&gt;=<span class="number">95</span>&amp;&amp;topNow&lt;<span class="number">285</span>)&#123;</span><br><span class="line">    cardList[i].<span class="property">style</span>.<span class="property">top</span>=<span class="string">&#x27;190px&#x27;</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(topNow&gt;=<span class="number">285</span>&amp;&amp;topNow&lt;<span class="number">455</span>) &#123;</span><br><span class="line">    cardList[i].<span class="property">style</span>.<span class="property">top</span>=<span class="string">&#x27;360px&#x27;</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cardList[i].<span class="property">style</span>.<span class="property">top</span>=<span class="string">&#x27;530px&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">changeCard</span>(<span class="params">y,i</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> otherList=<span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;.card&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>;j&lt;otherList.<span class="property">length</span>;j++) &#123;</span><br><span class="line">    <span class="keyword">switch</span>(otherList[j].<span class="property">offsetTop</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">20</span>:</span><br><span class="line">        isEmpty.<span class="property">card1</span>=<span class="literal">false</span>;</span><br><span class="line">        isEmpty.<span class="property">card1_name</span>=otherList[j];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">190</span>:</span><br><span class="line">        isEmpty.<span class="property">card2</span>=<span class="literal">false</span>;</span><br><span class="line">        isEmpty.<span class="property">card2_name</span>=otherList[j];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">360</span>:</span><br><span class="line">        isEmpty.<span class="property">card3</span>=<span class="literal">false</span>;</span><br><span class="line">        isEmpty.<span class="property">card3_name</span>=otherList[j];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">530</span>:</span><br><span class="line">        isEmpty.<span class="property">card4_name</span>=otherList[j];</span><br><span class="line">        isEmpty.<span class="property">card4</span>=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(cardList[i].<span class="property">offsetTop</span>&lt;<span class="number">95</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty.<span class="property">card2</span>) &#123;</span><br><span class="line">      isEmpty.<span class="property">card1_name</span>.<span class="property">style</span>.<span class="property">top</span>=<span class="string">`190px`</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(cardList[i].<span class="property">offsetTop</span>&gt;=<span class="number">95</span>&amp;&amp;cardList[i].<span class="property">offsetTop</span>&lt;<span class="number">285</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty.<span class="property">card1</span>) &#123;</span><br><span class="line">      isEmpty.<span class="property">card2_name</span>.<span class="property">style</span>.<span class="property">top</span>=<span class="string">&#x27;20px&#x27;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(isEmpty.<span class="property">card3</span>) &#123;</span><br><span class="line">      isEmpty.<span class="property">card2_name</span>.<span class="property">style</span>.<span class="property">top</span>=<span class="string">&quot;360px&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(cardList[i].<span class="property">offsetTop</span>&gt;=<span class="number">285</span>&amp;&amp;cardList[i].<span class="property">offsetTop</span>&lt;<span class="number">455</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty.<span class="property">card2</span>) &#123;</span><br><span class="line">      isEmpty.<span class="property">card3_name</span>.<span class="property">style</span>.<span class="property">top</span>=<span class="string">&#x27;190px&#x27;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(isEmpty.<span class="property">card4</span>) &#123;</span><br><span class="line">      isEmpty.<span class="property">card3_name</span>.<span class="property">style</span>.<span class="property">top</span>=<span class="string">&quot;530px&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(cardList[i].<span class="property">offsetTop</span>&gt;=<span class="number">455</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty.<span class="property">card3</span>) &#123;</span><br><span class="line">      isEmpty.<span class="property">card4_name</span>.<span class="property">style</span>.<span class="property">top</span>=<span class="string">&#x27;360px&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">clearIsEmpty</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">clearIsEmpty</span>(<span class="params"></span>) &#123;</span><br><span class="line">  isEmpty.<span class="property">card1_name</span>=<span class="literal">null</span>;</span><br><span class="line">  isEmpty.<span class="property">card1</span>=<span class="literal">true</span>;</span><br><span class="line">  isEmpty.<span class="property">card2_name</span>=<span class="literal">null</span>;</span><br><span class="line">  isEmpty.<span class="property">card2</span>=<span class="literal">true</span>;</span><br><span class="line">  isEmpty.<span class="property">card3</span>=<span class="literal">true</span>;</span><br><span class="line">  isEmpty.<span class="property">card3_name</span>=<span class="literal">null</span>;</span><br><span class="line">  isEmpty.<span class="property">card4</span>=<span class="literal">true</span>;</span><br><span class="line">  isEmpty.<span class="property">card4_name</span>=<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>代码部分略微复杂，这部分是这个例子的核心</p>
<ul>
<li><p>首先我们将card全部选中便于后面处理事件</p>
</li>
<li><p>我还声明了一个<code>isEmpty</code>对象，这个对象顾名思义就是检测哪些位置是空的（四个卡片有四个位置，当移走一个卡片时就会产生空位）</p>
</li>
<li><p>然后我们实现拖拽</p>
<ul>
<li>实现拖拽的方法比较固定，第一步监听<code>mousedown</code>事件,接着在页面中监听<code>mousemove</code>事件，最后监听<code>mouseup</code>事件来结束拖拽（将其他事件设置为null）</li>
<li>在<code>mousedown</code>中我们先记录了选中卡片时的鼠标位置<code>clientY</code>和卡片的<code>offsetTop</code>，这是为了后面计算卡片的top值让卡片能完美跟随鼠标移动，</li>
<li>然后我们改变了选中元素的类名让它看起来更高</li>
<li>进入<code>mousemove</code>事件的处理函数，除了计算高度让卡片随着鼠标运动外，还有一个重要的<code>changeCard</code>函数，用于使其他卡片给选中的卡片让位</li>
<li>然后进入<code>mouseup</code>事件处理函数，除了把元素的类名修改回来之外还要根据卡片位置将其强行移到对应的位置上</li>
</ul>
</li>
<li><p>让其他卡片“让位”</p>
<p>重点看<code>changecard</code>函数，首先我们获取未被鼠标选中的其他静止卡片列表（class都是card），然后遍历它们的位置得出空缺的位置是位于哪张卡片，并把已被占用位置和卡片名对应起来（因为卡片经过移动后可能是乱序的），这个操作通过修改<code>isEmpty</code>对象实现。知道了哪个位置是空缺的，我们再检测选中卡片的位置来判断该让哪个静止卡片移动。如：现在被选中的卡片来到了位置2，如果位置3是空的，我们就让位置2的卡片区填补位置3的空白，如果位置1是空的，我们就让位置2的卡片填补位置1的空白。这样我们就实现了让其他卡片“让位”。当然<code>isEmpty</code>是全局对象，在函数结束后必须要清空</p>
</li>
<li><p>卡片归位</p>
<p>这个很简单，当鼠标不再选中时查看一下元素的位置，根据位置所在的范围再设置一下<code>top</code>值就可以实现，这就是<code>layCard</code>函数的原理</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>不足：如果很缓慢的移动卡片的话，是不存在任何问题的（当然这里没有做节流操作会比较吃性能），但如果快速移动的话，由于卡片top的改变需要时间，在静态卡片还在让出空位时再次判断可能会有bug，即卡片会重叠在一起，这个我目前还没找到优化方法</p>
</li>
<li><p>思路完全原创，代码比较臃肿！</p>
</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>js</tag>
        <tag>原生</tag>
      </tags>
  </entry>
  <entry>
    <title>关于内向和外向</title>
    <url>/2022/10/12/%E5%86%85%E5%90%91%E4%B8%8E%E5%A4%96%E5%90%91/</url>
    <content><![CDATA[<h3 id="内向与外向"><a href="#内向与外向" class="headerlink" title="内向与外向"></a>内向与外向</h3><p>​	内向的人可能表现出来是外向的，因为这里的内向是人内心深处的东西，更贴近于本质，而表现出来的外向是社会学上的宏观表现。一个内向的人甚至可能觉得自己非常非常外向，因为他们自己在社交上不怎么怯场，与很多人都能有话可说，但他们内心里是内向的，因为外在的表现可以认为是一种技能的习得，虽然能表现的外向，但背后可能是抗拒，疲惫的。一个外向的人用内向者的放松方式要求自己（如把自己关在房间里读书），或是一个内向的人用外向者的放松方式要求自己（如出门旅游），都会使自己的生活更加疲惫</p>
<p>​	区分内向者与外向者，要看他们与世界的联系。内向的人能接受世界的能力更弱，面对不断变化的世界，他们往往需要与世界保持一定的距离。而外向者正好相反，外向者擅长与世界融为一体，能积极接纳新事物。内向的人会在内心中建立一个世界，从而做到与真实的世界保持一定距离。理论上讲内心世界应该与真实世界是1：1的但事实并非如此，因此内向的人会在观察自己内心世界的基础上尽可能少的从外部世界获取新东西扩充自己。所以内向的人在心里为了获得安全感会更想去认识认识这个世界，而事实上他却尽可能少的认识，因此内向的人更需要安全感。外向的人则需要不断地从世界获取新事物，因为他总觉得自己还不够，他会认为世界与自己是一体的。</p>
<p>​	在此基础上，通过审查自己看待世界的方式，就可以知道自己是内向还是外向。比如内向者被亲密的人伤害之后，会因为这件事影响自己内心的世界，很可能会认为这个世界对自己太残忍了，既然亲密者对我都这样那么世界也不会对我温柔了等等想法。而外向者不同，外向者往往表现出我讨厌这个世界，我厌恶这个人。这两者有什么区别呢，区别在于内向者把自己与世界做了一个割舍，认为世界是危险的，完全融入进去就会被吞噬。而外向者则在最开始就是和世界站在一起的，他思考的前提就是自己处在世界之中。</p>
<p>​	内向者放松的方式，是要更加切断自己与世界探索性的联系，要做的是修补自己的内心世界。因此，他们更需要独处。</p>
]]></content>
      <categories>
        <category>生活</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>心理</tag>
      </tags>
  </entry>
  <entry>
    <title>css中list列表相关</title>
    <url>/2022/10/12/%E5%88%97%E8%A1%A8%E5%92%8C%E7%94%9F%E6%88%90%E7%9A%84%E5%86%85%E5%AE%B9/</url>
    <content><![CDATA[<h1 id="列表和生成的内容"><a href="#列表和生成的内容" class="headerlink" title="列表和生成的内容"></a>列表和生成的内容</h1><h3 id="改变记号类型"><a href="#改变记号类型" class="headerlink" title="改变记号类型"></a>改变记号类型</h3><p>使用<code>list-style-type</code>属性</p>
<p>与列表相关的属性只能应用到display属性为list-item的元素上，css并不区分有序列表和无序列表的项目。可以让有序列表使用圆点</p>
<p>如果不想要记号，可以设置none值，但none值只是让记号不显示，并没有阻断计数</p>
<p><code>list-style-type</code>的值是继承的，因此如果嵌套的列表需要使用不同的记号需要分别定义</p>
<p>除了默认提供的<code>list-style-type</code>值外，还可以使用字符串值作为记号</p>
<p>使用<code>list-style-image</code>属性</p>
<p>使用该属性可以将列表记号设置为图片</p>
<p>可以在声明图片记号之后再声明一个<code>list-style-type</code>作为后备记号类型</p>
<p>嵌套的列表同样会继承image属性</p>
<p>为嵌套的列表的image设置none阻止继承</p>
<p>但实际情况中用户代理可能会为列表设置一个list-style-type值，因此继承的list-style-type值可能不能生效</p>
<p>使用<code>list-style-position</code></p>
<p>该属性会改变列表记号的位置，设置为outside（默认值）时，记号显示在外部，设置为inside时，显示在内容内部</p>
<p>使用<code>list-style</code>简写属性</p>
<p><code>list-style:list-style-type list-style-image list-style-position</code></p>
<p>可以按任意顺序列出</p>
<p>列表项目本身是类似块级的元素，放在列表内容外部的记号对其他元素的布局没有影响，记号相对于列表内容类似于绝对定位</p>
<h3 id="生成的内容"><a href="#生成的内容" class="headerlink" title="生成的内容"></a>生成的内容</h3><p>生成的内容使用::before和::after伪元素插入文档。通过设置伪元素的content属性将指定的内容插入文档内容之前或之后</p>
<p>如果::before或::after选择符的目标是块级元素，那么display的值只能为none，inline，block，和marker，其他值都为block</p>
<p>如果是行内元素，那么display的值只能为none或inline，其他值都为inline</p>
<h5 id="content"><a href="#content" class="headerlink" title="content"></a>content</h5><p>content的值为字符串时，显示为字面当量，即使有特殊标签也直接显示出来</p>
<p>如果需要换行需要添加\A,如果需要将较长的字符串分多行书写需要\</p>
<p>content值为URI时，会将引入的资源插入合适的位置，如果是用户代理不支持的资源会完全忽略</p>
<p>如果想把属性值显示出来，可以使用<code>attr()</code>,如<code>content:attr(href)</code></p>
<p>如果属性不存在，将显示空字符串</p>
<h5 id="生成引号"><a href="#生成引号" class="headerlink" title="生成引号"></a>生成引号</h5><p>引号使用quote或open-quote等值生成</p>
<p><code>quote:&lt;string&gt; &lt;string&gt;</code></p>
<p>第一个字符定义开始引号，第二个字符定义结束引号</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>不常用</tag>
      </tags>
  </entry>
  <entry>
    <title>js数据结构：前置知识</title>
    <url>/2022/10/12/%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h2 id="学习数据结构与算法JS版本的前置知识（JS基础）"><a href="#学习数据结构与算法JS版本的前置知识（JS基础）" class="headerlink" title="学习数据结构与算法JS版本的前置知识（JS基础）"></a>学习数据结构与算法JS版本的前置知识（JS基础）</h2><h3 id="数组解析"><a href="#数组解析" class="headerlink" title="数组解析"></a>数组解析</h3><p><code>let [x,y]=[&quot;a&quot;,&quot;b&quot;]</code>,直接对x，y两个变量声明</p>
<p><code>[x,y]=[y,x]</code>直接对x，y交换</p>
<h3 id="属性简写"><a href="#属性简写" class="headerlink" title="属性简写"></a>属性简写</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, y] = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]; </span><br><span class="line"><span class="keyword">let</span> obj = &#123; x, y &#125;; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj); <span class="comment">// &#123; x: &quot;a&quot;, y: &quot;b&quot; &#125; </span></span><br></pre></td></tr></table></figure>

<p>可以直接声明对象属性</p>
<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><h4 id="声明类"><a href="#声明类" class="headerlink" title="声明类"></a>声明类</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">title,pages,isbn</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">title</span>=title;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">pages</span>=pages;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">isbn</span>=isbn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">printIsbn</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">isbn</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ITBook</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Book</span> &#123; <span class="comment">// &#123;1&#125; </span></span><br><span class="line"> <span class="title function_">constructor</span> (title, pages, isbn, technology) &#123; </span><br><span class="line"> <span class="variable language_">super</span>(title, pages, isbn); <span class="comment">// &#123;2&#125; </span></span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">technology</span> = technology; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="title function_">printTechnology</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">technology</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>extends</code>继承一个父类</li>
<li>使用<code>super</code>引入父类构造器</li>
</ul>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><ul>
<li><p>导出模块：<code>export &#123; circleArea, squareArea &#125;;</code></p>
</li>
<li><p>导入模块：<code>import &#123; circleArea, squareArea &#125; from &#39;./17-CalcArea&#39;;</code></p>
</li>
<li><p>导出模块时命名：<code>export &#123; circleArea as circle, squareArea as square &#125;;</code></p>
</li>
<li><p>导入模块时命名：<code>import &#123; circleArea as circle &#125; from &#39;./17-CalcArea&#39;; </code></p>
</li>
</ul>
<h3 id="数组常用方法"><a href="#数组常用方法" class="headerlink" title="数组常用方法"></a>数组常用方法</h3><p><code>push</code>:在数组末尾添加元素</p>
<p><code>unshift</code>:在数组开头添加元素</p>
<p><code>pop</code>:在数组末尾删除元素</p>
<p><code>shift</code>:在数组开头删除元素</p>
<p><code>splice</code>:在数组给定位置删除元素。如<code>splice(5,3)</code>在数组从索引5开始删除3个元素，即Array[5],Array[6],Array[7]。<code>splice(5,3,2,4)</code>是在删除三个元素后从索引5开始添加2和4两个数</p>
<p><code>concat</code>:连接 2 个或更多数组，并返回结果</p>
<p><code>every</code>:会迭代每一个元素直到返回false，传入一个函数</p>
<p><code>some</code>:与<code>every</code>相反，返回true结束</p>
<p><code>foeEach</code>:迭代整个数组，和for循环作用相同</p>
<p><code>map</code>:迭代整个数组，将每个数组元素带入函数得到的返回值构成一个新数组返回</p>
<p><code>filter</code>:和<code>map</code>类似，但返回的新数组由使函数返回 true 的元素组成</p>
<p><code>reduce</code>:返回一个将被叠加到累加器的值，reduce 方法停止执行后会返回 这个累加器.reduce 方法接收一个有如下四个参数的函数：previousValue、 currentValue、index 和 array。因为 index 和 array 是可选的参数，所以如果用不到它们 的话，可以不传。如：<code>numbers.reduce((previous, current) =&gt; previous + current);</code>是对数组求和</p>
<h3 id="ES6数组新语法"><a href="#ES6数组新语法" class="headerlink" title="ES6数组新语法"></a>ES6数组新语法</h3><ul>
<li><p><code>for...of</code>：更简化的循环迭代</p>
</li>
<li><p><code>@@iterator</code>:这是一个对象，通过<code>Symbol.iterator</code>访问。</p>
<p>如：<code>let iterator = numbers[Symbol.iterator]();</code></p>
<p>然后，不断调用迭代器的 next 方法，就能依次得到数组中的值</p>
<p>如：<code>console.log(iterator.next().value); // 1 </code></p>
<p>数组中的所有值都迭代完之后，<code>iterator.next().value</code> 会返回 undefined。</p>
</li>
<li><p><code>entries</code>:方法返回包含键值对的<code>@@iterator</code>,如<code>let aEntries = numbers.entries();</code></p>
<p><code>console.log(aEntries.next().value); // [0, 1] - 位置 0 的值为 1</code></p>
</li>
<li><p><code>keys</code>:返回包含数组索引的<code>@@iterator</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> aKeys = numbers.<span class="title function_">keys</span>(); <span class="comment">// 得到数组索引的迭代器</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(aKeys.<span class="title function_">next</span>()); <span class="comment">// &#123;value: 0, done: false &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(aKeys.<span class="title function_">next</span>()); <span class="comment">// &#123;value: 1, done: false &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(aKeys.<span class="title function_">next</span>()); <span class="comment">// &#123;value: 2, done: false &#125;</span></span><br></pre></td></tr></table></figure>

<p><code>done</code>的值为false意味着还有可迭代的值</p>
</li>
<li><p><code>values</code>:法返回的<code>@@iterator</code> 则包含数组的值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> aValues = numbers.<span class="title function_">values</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(aValues.<span class="title function_">next</span>()); <span class="comment">// &#123;value: 1, done: false &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(aValues.<span class="title function_">next</span>()); <span class="comment">// &#123;value: 2, done: false &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(aValues.<span class="title function_">next</span>()); <span class="comment">// &#123;value: 3, done: false &#125; </span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>from</code>:据已有的数组创建一个新数组</p>
<p><code>let numbers2 = Array.from(numbers);</code>复制了numbers数组</p>
<p>还可以传入一个用来过滤值的函数</p>
<p><code>let evens = Array.from(numbers, x =&gt; (x % 2 == 0));</code></p>
<p>上面的代码会创建一个 evens 数组，以及值 true（如果在原数组中为偶数）或 false（如 果在原数组中为奇数）。</p>
</li>
<li><p><code>fill</code>:填充元素</p>
</li>
<li><p><code>find</code>:查找第一个符合条件的元素</p>
</li>
<li><p><code>findindex</code>:查找第一个符合条件的元素的索引</p>
</li>
<li><p><code>includes</code>:如果数组里存在某个元素，includes 方法会返回 true，否则返回 false。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>数据结构</tag>
        <tag>数组</tag>
        <tag>对象</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>css动画</title>
    <url>/2022/10/12/%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<h1 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h1><h2 id="定义关键帧"><a href="#定义关键帧" class="headerlink" title="定义关键帧"></a>定义关键帧</h2><p>一个<code>@keyframes</code>规则有一个动画标识符（动画名称），以及一到多个关键帧块。</p>
<p>每个关键帧块有一到多个关键帧选择符（百分数或from&#x2F;to），声明属性及其值</p>
<p>关键帧没有指明动画的持续时间，在选择符中使用时间会使动画失效</p>
<p>0必须写成0%</p>
<p>选择符无需按照升序排序，但为了方便辨识建议从0%到100%</p>
<p>如果没有定义0%和100%的状态，默认到初始状态</p>
<p>如果定义了重复的关键帧选择符，那么会进行层叠（覆盖）</p>
<h2 id="把动画应用到元素上"><a href="#把动画应用到元素上" class="headerlink" title="把动画应用到元素上"></a>把动画应用到元素上</h2><p><code>animation-name</code>属性的值为一个逗号分隔的列表，指定想应用的关键帧动画的名称</p>
<p>如果列表中有标识符不存在，则会单个失效而不会全体失效</p>
<h3 id="定义时长"><a href="#定义时长" class="headerlink" title="定义时长"></a>定义时长</h3><p><code>animation-duration</code>用于定义动画时长，单位为秒或毫秒</p>
<p>必须带单位，且可以用逗号分隔来定义不同动画</p>
<p>如果时间比动画数少，那么缺少的值将成组复制</p>
<p>如果时间比动画数多或定义不存在的动画，动画和对应的时间都会被忽略</p>
<h3 id="声明迭代次数"><a href="#声明迭代次数" class="headerlink" title="声明迭代次数"></a>声明迭代次数</h3><p><code>animation-iteration-count</code>声明迭代次数</p>
<p>初始值为1，即动画只播放一次</p>
<p>如果值不是整数，动画会在最后一次迭代的中途停止</p>
<p>不允许设置负值，无效值会变成1</p>
<p>0是有效值，但动画迭代0次，仍会触发开始和结束事件</p>
<p>多出的值忽略，缺少的值根据现有的值重复</p>
<p>无效的值会使整个声明失效，受影响的动画只会播放一次</p>
<p>值为infinite无限次迭代播放</p>
<h3 id="设置播放方向"><a href="#设置播放方向" class="headerlink" title="设置播放方向"></a>设置播放方向</h3><p><code>animation-direction</code>属性可以控制动画播放的方向（从0%到100%还是从100%到0%）</p>
<p><code>animation-direction:normal/reverse/alternate/alternate-reverse</code></p>
<p>初始值：normal:动画每次都从0%到100%播放</p>
<p><code>reverse</code>:每次迭代都从100%到0%播放</p>
<p><code>alternate</code>:奇数次迭代从0%到100%，偶数次迭代从100%到0%</p>
<p><code>alternate-reverse</code>:奇数次迭代从100%到0%，偶数次迭代从0%到100%</p>
<h3 id="延迟播放"><a href="#延迟播放" class="headerlink" title="延迟播放"></a>延迟播放</h3><p><code>animation-delay</code>属性定义元素等待多久开始第一次迭代</p>
<p>单位为秒或毫秒</p>
<p>如果设置为负值，元素将立即开始播放，但是是从动画中途开始的</p>
<h3 id="动画事件"><a href="#动画事件" class="headerlink" title="动画事件"></a>动画事件</h3><p>与动画有关的事件有三个：<code>animationstart  animationiteration  animationend</code></p>
<p>每个事件都有三个只读属性：<code>animationName elapsedTime pseudoElement</code></p>
<p><code>animation-start</code>事件在动画开始时触发，如果delay为负值，则立即触发</p>
<p><code>animation-end</code>事件在动画结束时出啊发，如果迭代次数为infinite且duration值为正数，将永远不会触发animation-end事件，如果duration为0，<code>animationstart</code>和<code>animationend</code>将同时触发，而且按此顺序</p>
<p><code>animationiteration</code>事件在两次迭代之间触发，只要一次迭代后又发生迭代（不管是否完整），该事件都会触发</p>
<h3 id="改变动画的内部时序"><a href="#改变动画的内部时序" class="headerlink" title="改变动画的内部时序"></a>改变动画的内部时序</h3><p><code>animation-timing-function</code>指明动画在一次循环（或迭代）中如何演进</p>
<p>内容与<code>transition-timing-function</code>相同</p>
<p>如果将其应用到关键帧上，只对当前关键帧块上的元素有影响，且只有播放到包含那些属性的关键帧时时序函数才会生效</p>
<h3 id="设置动画的播放状态"><a href="#设置动画的播放状态" class="headerlink" title="设置动画的播放状态"></a>设置动画的播放状态</h3><p>使用<code>animation-play-state</code>属性定义动画的播放状态</p>
<p>值为running时动画播放，值为pause时动画暂停，在delay时pause也会使delay时钟暂停</p>
<h3 id="动画的填充模式"><a href="#动画的填充模式" class="headerlink" title="动画的填充模式"></a>动画的填充模式</h3><p><code>animation-fill-mode</code>属性定义动画播放结束后是否应用原来的属性值</p>
<p><code>animation-fill-mode:none/forwards/backwards/both</code></p>
<p><code>none</code>:动画不播放就没有效果，在delay结束前0%的效果不会应用到元素上</p>
<p><code>backwards</code>:0%定义的属性立即生效，而不用等待animation-delay属性结束</p>
<p><code>forwards</code>:动画触发<code>animationend</code>时的属性继续应用到元素上</p>
<p><code>both</code>:同时包含<code>backwards</code>和<code>forwards</code>两个值的作用</p>
<h2 id="写为一个属性"><a href="#写为一个属性" class="headerlink" title="写为一个属性"></a>写为一个属性</h2><p><code>animation</code></p>
<p>前面的时间是duration,后面的是delay</p>
<p>如果动画标识符的值和某个动画属性的值相同，<code>animation-name</code>应该放在最后</p>
<p>如果有多个动画为同一个属性指定了不同的值，最后一个应用的动画覆盖之前动画中声明的值</p>
<p>先把后声明的先走完，如果有多余时间再播放前面声明的动画</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>css中transform</title>
    <url>/2022/10/12/%E5%8F%98%E5%BD%A2/</url>
    <content><![CDATA[<h1 id="变形"><a href="#变形" class="headerlink" title="变形"></a>变形</h1><h2 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h2><p>笛卡尔坐标系：即xyz坐标系，x向右，y向下，z和z-index相同</p>
<p>球坐标系：显示3D效果所用的坐标系</p>
<h2 id="变形-1"><a href="#变形-1" class="headerlink" title="变形"></a>变形</h2><p>使用<code>transform:&lt;transform-list&gt;</code></p>
<p>变形的元素在视觉上可能会缩小或放大，但在页面中所占的空间是不变的</p>
<p>变形函数一次只处理一个，从左向右。如果顺序变了结果可能大变</p>
<p>有多个变形函数时，一旦有一个设置不正确导致失效，整个transform都会失效</p>
<p>变形通常不叠加</p>
<h3 id="平移函数"><a href="#平移函数" class="headerlink" title="平移函数"></a>平移函数</h3><p>平移函数是指沿一个轴或多个轴移动</p>
<p><code>translateX()和translateY()</code>通常称为2D平移函数</p>
<p>如果先进行旋转变形，那么xy轴也会对应旋转变换从而影响平移效果</p>
<p>如果值是百分数，那么移动距离相对于元素自身的尺寸计算</p>
<p>只移动XY轴方向时，可以使用<code>translate()</code>简写，第一个值是x轴移动量，第二个是y轴移动量，如果只有一个值，空缺的值视为0</p>
<p>使用<code>translateZ</code>沿z轴平移</p>
<p><code>translateZ()</code>只接受长度值</p>
<p><code>translate3d()</code>可以同时设置XYZ轴方向的平移量，如果赋值小于3个，视作无效</p>
<h3 id="缩放函数"><a href="#缩放函数" class="headerlink" title="缩放函数"></a>缩放函数</h3><p>缩放函数把元素放大或缩小，值始终为没有单位的正数</p>
<p><code>scaleX() scaleY() scaleZ()</code></p>
<p>赋值当作乘数，但缩放值不能为百分数</p>
<p>如果想在两个轴上同时缩放，可以使用<code>scale()</code>，第一个值是x，第二个值是y，如果只提供一个值，视作两个值相等</p>
<p><code>scaleZ()</code>仅在z轴上缩放，需要元素具有一定的深度，如沿x，y轴旋转</p>
<p><code>scale3d()</code>可以在三个轴方向缩放，不足三个值同样视为无效</p>
<h3 id="旋转函数"><a href="#旋转函数" class="headerlink" title="旋转函数"></a>旋转函数</h3><p><code>rotate() rotateX() rotateY() rotateZ()</code></p>
<p>只接受一种值，即角度（deg grad rad turn）,当不使用动画时，如果角度超过了常规范围，将转换为常规范围内的值</p>
<p><code>rotate</code>使用的是2d旋转，和<code>rotateZ()</code>功能相同</p>
<p><code>rotateX()</code>沿x轴旋转，<code>rotateY()</code>沿y轴旋转，使元素倾斜</p>
<p><code>rotate3d()</code>可以在3d空间内旋转元素，前三个值是xyz轴分量，第四个值是旋转角度</p>
<p>绕两个轴旋转和在绕3d空间中的向量旋转是有区别的</p>
<h3 id="倾斜函数"><a href="#倾斜函数" class="headerlink" title="倾斜函数"></a>倾斜函数</h3><p><code>skewX() skewY()</code>值为角度，z轴方向不允许倾斜</p>
<p><code>skew(a,b)</code>通过矩阵运算[ax,ay]实施2d倾斜，与分别设置的效果有所不同</p>
<h3 id="视域函数"><a href="#视域函数" class="headerlink" title="视域函数"></a>视域函数</h3><p>视域为元素赋予先后深度</p>
<p>使用<code>perspective(&lt;length&gt;)</code>设置</p>
<p>小于200px的值特别失真，2000px以上的值失真“特别温和”，500px-100px值产生“适中的视域”</p>
<p><code>perspective</code>函数在变形函数列表中的位置十分重要，一般将其放在首位</p>
<h3 id="矩阵函数"><a href="#矩阵函数" class="headerlink" title="矩阵函数"></a>矩阵函数</h3><p><code>martrix()</code>函数通过6个值确定的变换矩阵指定2d空间内的变形</p>
<p><code>martrix3d()</code>指定3d变形</p>
<p>可以使用多个变形函数达到matrix函数的最终状态</p>
<h2 id="其他变形属性"><a href="#其他变形属性" class="headerlink" title="其他变形属性"></a>其他变形属性</h2><h3 id="移动原点"><a href="#移动原点" class="headerlink" title="移动原点"></a>移动原点</h3><p>不设置移动原点，默认的移动原点是元素的绝对中心</p>
<p>可以使用<code>transform-origin</code>修改</p>
<p><code>transform-origin</code>的值为2个或三个关键字，用于指定相对于哪个点变形，第一个值指定横向，第二个值指定纵向，可选的第三个值是z轴长度。前两个值可以使用top和right，也可以使用百分数等，z轴只能使用长度</p>
<p>长度值设置的是距元素左上角的距离</p>
<p>百分数根据元素尺寸计算</p>
<h3 id="选择3D变形方式"><a href="#选择3D变形方式" class="headerlink" title="选择3D变形方式"></a>选择3D变形方式</h3><p>通过<code>transform-style:preserve-3d</code>修改3D变形方式</p>
<p>然而这样设定的3D变形方式可能被其他属性覆盖，因为那些属性必须要元素扁平才能发挥作用</p>
<p>如果修改CSS属性时发现3d元素被拍扁了，可能是</p>
<ul>
<li>overflow</li>
<li>filter</li>
<li>clip</li>
<li>clip-path</li>
<li>mask-image</li>
<li>mask-border-source</li>
<li>mix-blend-mode</li>
</ul>
<p>中的某些值发生了改变</p>
<h3 id="修改视域"><a href="#修改视域" class="headerlink" title="修改视域"></a>修改视域</h3><h4 id="定义视距"><a href="#定义视距" class="headerlink" title="定义视距"></a>定义视距</h4><p>使用perspective修改视域</p>
<p><code>perspective</code>与<code>perspective()</code>的区别：</p>
<p><code>perspective</code>运用到当前元素的所有子元素中，而<code>perspective()</code>只运用到当前元素上</p>
<p>多数时候应该使用perspective</p>
<h4 id="移动视距原点"><a href="#移动视距原点" class="headerlink" title="移动视距原点"></a>移动视距原点</h4><p>使用<code>perspective-origin</code>修改</p>
<p>初始值：50% 50%</p>
<p>和<code>transform-origin</code>用法类似</p>
<p><code>transform-origin</code>定义在哪点变形，<code>perspective-origin</code>定义视线汇聚于哪一点</p>
<h3 id="处理背面"><a href="#处理背面" class="headerlink" title="处理背面"></a>处理背面</h3><p>由<code>backface-visibility</code>属性决定</p>
<p>值：visible&#x2F;hidden</p>
<p>该属性仅仅决定当背面朝向我们时是否渲染背面</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>变形在二维和三维空间中改变元素形态，可以制作出很多引人注目的效果，利用3d变形还可以创造出交互界面，为设计开辟了新天地</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>js数据结构：字典</title>
    <url>/2022/10/12/%E5%AD%97%E5%85%B8/</url>
    <content><![CDATA[<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>字典是一个存储键值对的集合</p>
<p>键一般都是字符串，而值可以是任何数据类型</p>
<p>先声明字典的骨架类</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dictionary</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">toStrFn = defaultToString</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">toStrFn</span> = toStrFn;<span class="comment">//用于将键值转换为字符串</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">table</span>=&#123;&#125;<span class="comment">//;存放键值对,保存为table[key]=&#123;key,value&#125;,每一个键值都对应一个键值对属性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为键一般都是字符串，需要先对传入的键执行toStrFn（defaultToString）方法，用户也可以自己定义，默认的定义如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">defaultToString</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(key===<span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;NULL&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(key === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;UNDEFINED&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> key === <span class="string">&#x27;string&#x27;</span> || key <span class="keyword">instanceof</span> <span class="title class_">String</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;key&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> key.<span class="title function_">toString</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面为字典类增加方法</p>
<ul>
<li><p>判断是否含有某键</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">hasKey</span>(<span class="params">key</span>) &#123;<span class="comment">//判断字典是否含有key</span></span><br><span class="line">        <span class="keyword">return</span>  <span class="variable language_">this</span>.<span class="property">table</span>[<span class="variable language_">this</span>.<span class="title function_">toStrFn</span>(key)] != <span class="literal">null</span>;<span class="comment">//将传入键字符串化后查看table[key]是否存在</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置键值对</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">set</span>(<span class="params">key,value</span>) &#123;<span class="comment">//根据键值对设置键和值</span></span><br><span class="line">        <span class="keyword">if</span>(key!=<span class="literal">null</span>&amp;&amp;value!=<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> tableKey=<span class="variable language_">this</span>.<span class="title function_">toStrFn</span>(key);<span class="comment">//字符串化key值</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">table</span>[tableKey]=<span class="keyword">new</span> <span class="title class_">ValuePair</span>(tableKey,value);<span class="comment">//给table对象设置table属性</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//传入值不正确返回false</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里将table[key]的值设置为了实例化的ValuePair对象用于存储键值对，现在定义ValuePair类</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ValuePair</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">key,value</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">key</span>=key;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">value</span>=value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`#<span class="subst">$&#123;<span class="variable language_">this</span>.key&#125;</span> : <span class="subst">$&#123;<span class="variable language_">this</span>.value&#125;</span>`</span><span class="comment">//重写toString方法让其输出键值对</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>移除键值对</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">remove</span>(<span class="params">key</span>) &#123;<span class="comment">//从字典里删除键值对</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">hasKey</span>(<span class="variable language_">this</span>.<span class="title function_">toStrFn</span>(key))) &#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">table</span>[<span class="variable language_">this</span>.<span class="title function_">toStrFn</span>(key)];<span class="comment">//删除table中的key属性</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//找不到要删除的key值就return false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据键获取值的get方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">get</span>(<span class="params">key</span>) &#123;<span class="comment">//从字典中检索值</span></span><br><span class="line">    <span class="keyword">const</span> valuePair=<span class="variable language_">this</span>.<span class="property">table</span>[<span class="variable language_">this</span>.<span class="title function_">toStrFn</span>(key)];</span><br><span class="line">    <span class="keyword">return</span> valuePair==<span class="literal">null</span>? <span class="literal">undefined</span> : valuePair.<span class="property">value</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取全部的键值对</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">keyValues</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">values</span>(<span class="variable language_">this</span>.<span class="property">table</span>);<span class="comment">//ES7方法，返回table中所有ValuePair对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取所有的键</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">keys</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">keyValues</span>().<span class="title function_">map</span>(<span class="function"><span class="params">valuePair</span> =&gt;</span> valuePair.<span class="property">key</span>);<span class="comment">//获取所有的key值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取所有的值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">values</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">keyValues</span>().<span class="title function_">map</span>(<span class="function"><span class="params">valuePair</span> =&gt;</span> valuePair.<span class="property">value</span>);<span class="comment">//获取了所有的value值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历字典并对遍历到的每一个键值对执行函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">forEach</span>(<span class="params">callbackFn</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> valuePairs = <span class="variable language_">this</span>.<span class="title function_">keyValues</span>(); <span class="comment">// 获取全部键值对</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; valuePairs.<span class="property">length</span>; i++) &#123; <span class="comment">// 遍历每一个键值对</span></span><br><span class="line">        <span class="keyword">const</span> result = <span class="title function_">callbackFn</span>(valuePairs[i].<span class="property">key</span>, valuePairs[i].<span class="property">value</span>); <span class="comment">// 执行要对键值对进行的回调操作</span></span><br><span class="line">        <span class="keyword">if</span> (result === <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 出现错误即退出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取字典中值的个数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="variable language_">this</span>.<span class="property">table</span>).<span class="property">length</span>;<span class="comment">//返回字典中值的个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断字典是否为空</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">size</span>() === <span class="number">0</span>;<span class="comment">//判断字典是否为空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>清空整个字典</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">clear</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">table</span> = &#123;&#125;;<span class="comment">//清空字典</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>字典格式化输出</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;<span class="comment">//如果为空则返回空字符串</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> valuePairs = <span class="variable language_">this</span>.<span class="title function_">keyValues</span>();<span class="comment">//获取全部键值对</span></span><br><span class="line">    <span class="keyword">let</span> objString = <span class="string">`<span class="subst">$&#123;valuePairs[<span class="number">0</span>].toString()&#125;</span>`</span>; <span class="comment">// 对第一个键值对字符串化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; valuePairs.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        objString = <span class="string">`<span class="subst">$&#123;objString&#125;</span>,<span class="subst">$&#123;valuePairs[i].toString()&#125;</span>`</span>; <span class="comment">// 将剩下的键值对依次字符串化并拼接起来</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> objString; <span class="comment">// 返回拼接的结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>常用的字典方法就添加完成了</p>
<p>完整的字典类代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dictionary</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">toStrFn = defaultToString</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">toStrFn</span> = toStrFn;<span class="comment">//用于将键值转换为字符串</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">table</span>=&#123;&#125;<span class="comment">//;存放键值对,保存为table[key]=&#123;key,value&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">hasKey</span>(<span class="params">key</span>) &#123;<span class="comment">//判断字典是否含有key</span></span><br><span class="line">        <span class="keyword">return</span>  <span class="variable language_">this</span>.<span class="property">table</span>[<span class="variable language_">this</span>.<span class="title function_">toStrFn</span>(key)] != <span class="literal">null</span>;<span class="comment">//将传入键字符串化后查看table[key]是否存在</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">key,value</span>) &#123;<span class="comment">//根据键值对设置键和值</span></span><br><span class="line">        <span class="keyword">if</span>(key!=<span class="literal">null</span>&amp;&amp;value!=<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> tableKey=<span class="variable language_">this</span>.<span class="title function_">toStrFn</span>(key);<span class="comment">//字符串化key值</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">table</span>[tableKey]=<span class="keyword">new</span> <span class="title class_">ValuePair</span>(tableKey,value);<span class="comment">//给table对象设置table属性</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//传入值不正确返回false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">remove</span>(<span class="params">key</span>) &#123;<span class="comment">//从字典里删除键值对</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">hasKey</span>(<span class="variable language_">this</span>.<span class="title function_">toStrFn</span>(key))) &#123;</span><br><span class="line">            <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">table</span>[<span class="variable language_">this</span>.<span class="title function_">toStrFn</span>(key)];<span class="comment">//删除table中的key属性</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//找不到要删除的key值就return false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">key</span>) &#123;<span class="comment">//从字典中检索值</span></span><br><span class="line">        <span class="keyword">const</span> valuePair=<span class="variable language_">this</span>.<span class="property">table</span>[<span class="variable language_">this</span>.<span class="title function_">toStrFn</span>(key)];</span><br><span class="line">        <span class="keyword">return</span> valuePair==<span class="literal">null</span>? <span class="literal">undefined</span> : valuePair.<span class="property">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">keyValues</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">values</span>(<span class="variable language_">this</span>.<span class="property">table</span>);<span class="comment">//ES7方法，返回table中所有ValuePair对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">keys</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">keyValues</span>().<span class="title function_">map</span>(<span class="function"><span class="params">valuePair</span> =&gt;</span> valuePair.<span class="property">key</span>);<span class="comment">//获取所有的key值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">values</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">keyValues</span>().<span class="title function_">map</span>(<span class="function"><span class="params">valuePair</span> =&gt;</span> valuePair.<span class="property">value</span>);<span class="comment">//获取了所有的value值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">forEach</span>(<span class="params">callbackFn</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> valuePairs = <span class="variable language_">this</span>.<span class="title function_">keyValues</span>(); <span class="comment">// 获取全部键值对</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; valuePairs.<span class="property">length</span>; i++) &#123; <span class="comment">// 遍历每一个键值对</span></span><br><span class="line">            <span class="keyword">const</span> result = <span class="title function_">callbackFn</span>(valuePairs[i].<span class="property">key</span>, valuePairs[i].<span class="property">value</span>); <span class="comment">// 执行要对键值对进行的回调操作</span></span><br><span class="line">            <span class="keyword">if</span> (result === <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 出现错误即退出</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="variable language_">this</span>.<span class="property">table</span>).<span class="property">length</span>;<span class="comment">//返回字典中值的个数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">size</span>() === <span class="number">0</span>;<span class="comment">//判断字典是否为空</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">clear</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">table</span> = &#123;&#125;;<span class="comment">//清空字典</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;<span class="comment">//如果为空则返回空字符串</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> valuePairs = <span class="variable language_">this</span>.<span class="title function_">keyValues</span>();<span class="comment">//获取全部键值对</span></span><br><span class="line">        <span class="keyword">let</span> objString = <span class="string">`<span class="subst">$&#123;valuePairs[<span class="number">0</span>].toString()&#125;</span>`</span>; <span class="comment">// 对第一个键值对字符串化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; valuePairs.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            objString = <span class="string">`<span class="subst">$&#123;objString&#125;</span>,<span class="subst">$&#123;valuePairs[i].toString()&#125;</span>`</span>; <span class="comment">// 将剩下的键值对依次字符串化并拼接起来</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> objString; <span class="comment">// 返回拼接的结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>数据结构</tag>
        <tag>字典</tag>
      </tags>
  </entry>
  <entry>
    <title>css中position</title>
    <url>/2022/10/12/%E5%AE%9A%E4%BD%8D/</url>
    <content><![CDATA[<h1 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h1><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>static:正常生成元素框</p>
<p>relative：元素框偏移一定距离，所占空间不变</p>
<p>absolute：元素框完全从文档流中移除，相对容纳块定位</p>
<p>fixed：行为类似absolute，容纳块是视区自身</p>
<p>sticky：触发粘滞条件时，相当于相对容纳块绝对定位；触发粘滞的条件失效后，回到最初位置</p>
<h3 id="容纳块"><a href="#容纳块" class="headerlink" title="容纳块"></a>容纳块</h3><p>一般来说，容纳块指包含另一个元素的框体</p>
<p>对定位元素：</p>
<p>relative或static：容纳块由最近的祖辈元素框体的内容边界划定</p>
<p>absolute：容纳块是最近的不是static的祖辈元素</p>
<ul>
<li>块级元素：内边距边界</li>
<li>行内元素：内容边界</li>
<li>没有：初始容纳块</li>
</ul>
<p>定位元素可能位于容纳块之外</p>
<h3 id="偏移属性"><a href="#偏移属性" class="headerlink" title="偏移属性"></a>偏移属性</h3><p>top</p>
<p>bottom</p>
<p>left</p>
<p>right</p>
<h3 id="限制宽高"><a href="#限制宽高" class="headerlink" title="限制宽高"></a>限制宽高</h3><p>min-height,min-width:限制最小</p>
<p>max-width,max-height:限制最大</p>
<h3 id="内容溢出"><a href="#内容溢出" class="headerlink" title="内容溢出"></a>内容溢出</h3><p>某个元素在内容里放不下：设置overflow属性</p>
<p>visible：超出内容的部分可见</p>
<p>hidden：超出部分不可见</p>
<p>scroll：超出部分会隐藏，但可以通过滚动条查看</p>
<p>auto：让用户代理自己决定使用哪种方式，在必要时使用滚动条</p>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p><code>visibility:visible/hidden/collapse</code></p>
<p><code>visible</code>:可见</p>
<p><code>hidden</code>:隐藏（仍会占据空间，但不显示，相当于完全透明）</p>
<p><code>collapse</code>:用于渲染表格，在渲染非表格元素时和hidden一致</p>
<h3 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h3><p>如果文档能滚动，绝对定位元素也会随之滚动</p>
<h5 id="自动确定边界"><a href="#自动确定边界" class="headerlink" title="自动确定边界"></a>自动确定边界</h5><p>将绝对定位元素除bottom外的某个偏移属性值设置为auto将得到一种特殊的行为</p>
<p>即元素的位置会成为静态状态时的位置（即在常规文档流中的位置）</p>
<p>将left和right同时设成auto会让绝对定位元素水平居中</p>
<p>当元素各种属性值加起来不足容纳块的长度时（过约束），会对auto的值重新计算，当无auto时，会重新计算left或right的值</p>
<p>如果属性的值导致过约束，top将永远<strong>不被</strong>忽略</p>
<h3 id="Z-index"><a href="#Z-index" class="headerlink" title="Z-index"></a>Z-index</h3><p>z-index值越大，元素离读者越近</p>
<p>设立z-index的父元素的子元素的位置是相对于父元素的，无论子元素设置多小的z-index值都会显示在父元素上方</p>
<p>z-index：auto可视为z-index：0</p>
<h3 id="固定定位"><a href="#固定定位" class="headerlink" title="固定定位"></a>固定定位</h3><p>与绝对定位类似，但容纳块是整个视区</p>
<h3 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h3><p>相对定位使用偏移属性移动元素</p>
<p>如<code>bottom:20px</code>将把元素向上平移20px</p>
<p>在相对定位中，元素从常规的位置移开了，但其占据的空间没有消失</p>
<p>相对定位的元素同样可能会重叠</p>
<h3 id="粘滞定位"><a href="#粘滞定位" class="headerlink" title="粘滞定位"></a>粘滞定位</h3><p>粘滞定位元素通过设置偏移属性确定相对容纳块的粘滞定位矩形</p>
<p>如<code>.h2 &#123;position:stick;top:2em;bottom:auto;left:auto;right:auto&#125;</code></p>
<p>就设置了一个到达顶部就被粘滞的举行，想要让矩形在某个方向被粘滞，只需要将那个方向不设成auto即可</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>借助定位可以随意移动元素，这是常规文档流难以企及的。通过z轴确定叠放次序，加上各种溢出模式，定位依旧有用武之力</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>css中的flex布局</title>
    <url>/2022/10/12/%E5%BC%B9%E6%80%A7%E7%9B%92%E5%B8%83%E5%B1%80%EF%BC%9Aflex/</url>
    <content><![CDATA[<h1 id="弹性盒布局：flex"><a href="#弹性盒布局：flex" class="headerlink" title="弹性盒布局：flex"></a>弹性盒布局：flex</h1><h3 id="弹性盒基础"><a href="#弹性盒基础" class="headerlink" title="弹性盒基础"></a>弹性盒基础</h3><p>使用弹性盒后内容呈现顺序不再受到源码顺序的限制</p>
<p>声明<code>display:flex</code>或<code>display:inline-flex</code>即可激活弹性盒布局，然后该元素被称为弹性容器，其子元素被成为弹性元素</p>
<p>两种的区别是前者生成一个块级框，子元素在其中布局</p>
<p>后者生成一个行内级框，子元素在其中布局</p>
<p>把一个元素设为弹性容器后，只有直接子元素使用弹性盒布局</p>
<h3 id="flex-direction属性"><a href="#flex-direction属性" class="headerlink" title="flex-direction属性"></a>flex-direction属性</h3><p>设置布局的方向，指定在弹性容器中如何摆放弹性元素</p>
<p>可使用：</p>
<p><code>row</code>:横向</p>
<p><code>row-reverse</code>:横向相反</p>
<p><code>column</code>:竖向</p>
<p><code>column-reverse</code>:竖向相反</p>
<p>如果改变了书写模式，例如规定书写模式是竖向书写（如从上向下），则row表示从上到下</p>
<p>column表示从右向左</p>
<h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><p>默认情况下元素不会换行，有可能从容器框的边界溢出</p>
<p>设置flex-wrap属性允许弹性元素换行</p>
<p><code>flex-wrap:nowrap/wrap/wrap-reverse</code>(默认<code>nowrap</code>)</p>
<p>默认情况下：无论多少元素都在一行显示</p>
<p>warp：超出的部分换行到之后</p>
<p>wrap-reverse:超出部分换行到之前</p>
<h3 id="定义弹性流"><a href="#定义弹性流" class="headerlink" title="定义弹性流"></a>定义弹性流</h3><p>flex-flow：确定主轴和垂轴方向，以及元素是否换行</p>
<p><code>flex-flow:&lt;flex-direction&gt; &lt;flex-wrap&gt;</code></p>
<p>弹性元素沿主轴排列，沿垂轴添加（如果换行的话）</p>
<p>主轴一定和垂轴垂直</p>
<h3 id="调整内容"><a href="#调整内容" class="headerlink" title="调整内容"></a>调整内容</h3><p><code>justify-content</code>属性指明在弹性容器的主轴上如何分布各行里的弹性元素</p>
<p>应用于弹性容器上而不是弹性元素上</p>
<p><code>justify-content:flex-start/flex-end/center/space-between/space-around/space-evenly</code></p>
<p>默认flex-start</p>
<p><code>flex-start</code>:元素沿主轴起边排列</p>
<p><code>flex-end</code>:元素沿主轴终边排列</p>
<p><code>center</code>:元素视为一个整体排列在主轴中央</p>
<p><code>space-between</code>:把第一个元素放在主轴起边，最后一个元素放在主轴终边，中间的元素等间距排列</p>
<p><code>space-around</code>:让元素左边和右边分出等同的距离（第一个元素距离主轴起边的距离会是每两个元素之间距离的一半）</p>
<p><code>space-evenly</code>:与space-around类似但第一个元素距离主轴起边的距离与每两个元素之间距离相等</p>
<p>justify-content还会影响元素的溢出方式</p>
<h3 id="对齐元素"><a href="#对齐元素" class="headerlink" title="对齐元素"></a>对齐元素</h3><p>justify-content定义主轴方向的对齐方式，而align-items定义垂轴方向的对齐方式</p>
<p>align-items同样应用于容器上</p>
<p><code>align-items:flex-start/flex-end/center/baseline/stretch</code></p>
<p>初始值：stretch</p>
<p>stretch:可拉伸：即所有可拉伸的弹性元素将与所在行最高或最宽的弹性元素一样高或一样宽</p>
<p>如果显示设置了元素的垂轴方向尺寸，元素将不可拉伸</p>
<p>拉伸后的元素尺寸包含外边距的长度</p>
<p>弹性元素行的高或宽是正好能够放下弹性元素的尺寸</p>
<p>baseline：基线对齐，基线是文本第一行文字的底部，受到字号影响</p>
<h3 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h3><p>align-self设置的值会覆盖align-items的值</p>
<p>取值与align-item相同</p>
<h3 id="对齐内容"><a href="#对齐内容" class="headerlink" title="对齐内容"></a>对齐内容</h3><p>align-content属性指定弹性容器中垂轴方向上的额外空间如何分配到弹性元素行之间和周围</p>
<p>取值与align-items相同</p>
<p>如果只有一行，align-content对内容没有影响</p>
<h3 id="弹性元素"><a href="#弹性元素" class="headerlink" title="弹性元素"></a>弹性元素</h3><p>float和clear对弹性元素不起作用</p>
<p>变成弹性元素后，只要没有绝对定位，就是块级的</p>
<p>没有被标签包裹的文本是匿名弹性元素，不能直接选择，只能从弹性容器上继承样式</p>
<p>绝对定位的弹性元素不再参与弹性布局，它们不在文档流中，但会受到弹性容器的样式影响，先确定在弹性容器中的位置再进行position</p>
<p>弹性元素的min-width默认为auto，如果不想溢出可以设置为0，元素会被压缩</p>
<h3 id="flex属性"><a href="#flex属性" class="headerlink" title="flex属性"></a>flex属性</h3><p>flex属性是flex-grow，flex-shrink和flex-basis的简写形式（弹性增长因子，弹性缩减因子和弹性基准）</p>
<p>默认值是0，1，auto</p>
<p>flex属性指定确定弹性长度的各要素，弹性元素所在的框体尺寸由flex决定</p>
<p>弹性基准指明如何应用弹性增长因子和弹性缩减因子</p>
<h4 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h4><p>定义有多余空间时是否允许弹性元素增大，以及有多余空间时，相对于同辈弹性元素会以什么比例增大</p>
<p><strong>不鼓励通过flex-grow定义增长因子，只建议在flex简写中指定增长因子</strong></p>
<p>flex-grow的值始终是正数，小于零无效</p>
<p>flex-grow的值用于计算比例，若只有一个元素设置了flex-grow，则剩余的所有空间都被它占有，若有多个元素设置了，则会通过设置值之间的比例确定各自所占剩余空间的比例</p>
<p>如果flex属性没有设定增长因子和缩减因子，flex-grow默认为1，如果flex和flex-grow都没有被声明出来，默认为0</p>
<p>使用flex声明flex-grow属性和单独使用flex-grow声明的区别：</p>
<p>flex声明将把所有空间按比例分配，而flex-grow声明只会将余下空间按比例分配</p>
<h4 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h4><p><strong>同样只建议在flex简写属性中声明</strong></p>
<p>弹性缩减因子定义空间不足以放下所有弹性元素时，当前元素相对于其他同辈弹性元素将缩小多少</p>
<p>缩减因子默认为1</p>
<p>计算方法与grow类似：</p>
<p>如果设置shrink为1，1，3，长度均为300，容纳器长度为750</p>
<p>那么元素将分别缩小：30，30，90</p>
<p>如果弹性元素中的内容将要超出容器大小，且不能换行和缩小，弹性元素将无法缩小</p>
<p>缩减因子为任何正数都会导致内容换行，换行次数和缩减因子比例差不多</p>
<h4 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h4><p>定义弹性元素的初始或默认尺寸，即根据增长因子或缩减因子分配空间前，弹性元素的大小</p>
<p>如果提前声明了width和height，值为width和height，如果没声明，值为content</p>
<h5 id="content"><a href="#content" class="headerlink" title="content"></a>content</h5><p>在支持的环境中，使用content的basis值为弹性元素中内容的尺寸，即最长一行内容或最宽的媒体对象在主轴上的长度</p>
<p>弹性基准会覆盖元素的width和height，但不会忽略mid-width和mid-height</p>
<h5 id="auto与0"><a href="#auto与0" class="headerlink" title="auto与0"></a>auto与0</h5><p>auto下会根据grow或shrink决定<strong>剩下</strong>的区域的划分</p>
<p>0决定<strong>所有</strong>区域的划分</p>
<h3 id="flex简写模式"><a href="#flex简写模式" class="headerlink" title="flex简写模式"></a>flex简写模式</h3><p>如果只给flex一个值(数字)，实际上声明的是flex-grow</p>
<p><code>flex: initial</code>&#x3D;<code>flex:0 1 auto</code></p>
<p><code>flex:auto</code>&#x3D;<code>flex:1 1 auto</code></p>
<p><code>flex:none</code>&#x3D;<code>flex:0 0 auto</code></p>
<p><code>flex:1</code>&#x3D;<code>flex:1,0,auto</code></p>
<h3 id="order属性"><a href="#order属性" class="headerlink" title="order属性"></a>order属性</h3><p>order属性可以改变元素的出现顺序，但读取代码的顺序是不变的</p>
<p>默认值是0，负数会先出现，正数会后出现</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>弹性盒布局的效果用float也可以实现，但比float方便得多。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>js数据结构：哈希表</title>
    <url>/2022/10/12/%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%88HashTable%EF%BC%89/</url>
    <content><![CDATA[<h3 id="散列表（HashTable）"><a href="#散列表（HashTable）" class="headerlink" title="散列表（HashTable）"></a>散列表（HashTable）</h3><p>哈希表是通过使用哈希函数得到一个哈希值，通过哈希值可以直接找到元素在表中的位置。</p>
<p><img src="/image/img_20.png" alt="image-20220908155723989"></p>
<p>先创建一个哈希表类的骨架</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HashTable</span> &#123; </span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params">toStrFn = defaultToString</span>) &#123; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">toStrFn</span> = toStrFn; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">table</span> = &#123;&#125;; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后我们需要一个哈希函数（算法）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">loseloseHashCode</span>(<span class="params">key</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> key === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> key;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> tableKey=<span class="variable language_">this</span>.<span class="title function_">toStrFn</span>(key);</span><br><span class="line">  <span class="keyword">let</span> hash=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; tableKey.<span class="property">length</span>;i++) &#123;</span><br><span class="line">    hash+=tableKey.<span class="title function_">charCodeAt</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> hash%<span class="number">37</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">hashCode</span>(<span class="params">key</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">loseloseHashCode</span>(key);<span class="comment">//获取哈希值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法是将key字符串化后将每一个字母的ASKII码相加，为防止数值移除，对任意一个数（这里取37）取余得到哈希值，<code>hashCode</code>方法知识简单的调用了<code>loseloseHashCode</code></p>
<ul>
<li><p>向表中添加元素</p>
<p>先通过哈希函数得到哈希值，将哈希值作为要插入的位置<code>position</code>，将哈希表的position属性设置为要添加的键值对</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">put</span>(<span class="params">key,value</span>) &#123;<span class="comment">//向表中添加元素</span></span><br><span class="line">  <span class="keyword">if</span>(key!=<span class="literal">null</span>&amp;&amp;value!=<span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> position=<span class="variable language_">this</span>.<span class="title function_">hashCode</span>(key);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">table</span>[position]=<span class="keyword">new</span> <span class="title class_">ValuePair</span>(key,value);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>从表中获取元素</p>
<p>查找变得简单，只需要通过哈希函数就能计算出位置，通过位置直接获取即可</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">get</span>(<span class="params">key</span>) &#123;<span class="comment">//根据key获取元素</span></span><br><span class="line">  <span class="keyword">const</span> valuePair=<span class="variable language_">this</span>.<span class="property">table</span>[<span class="variable language_">this</span>.<span class="title function_">hashCode</span>(key)];</span><br><span class="line">  <span class="keyword">return</span> valuePair==<span class="literal">null</span>?<span class="attr">undefined</span>:valuePair.<span class="property">value</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>从表中删除元素</p>
<p>先得到哈希值，从而找到要删除的元素，确定要删除的键值对存在后<code>delete</code>即可</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">remove</span>(<span class="params">key</span>) &#123;<span class="comment">//根据key删除元素</span></span><br><span class="line">  <span class="keyword">const</span> hash=<span class="variable language_">this</span>.<span class="title function_">hashCode</span>(key);</span><br><span class="line">  <span class="keyword">const</span> valuePair=<span class="variable language_">this</span>.<span class="property">table</span>[hash];</span><br><span class="line">  <span class="keyword">if</span>(valuePair!=<span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">table</span>[hash];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>我们得到完整的HashTable类：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HashTable</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">toStrFn=defaultToString</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">toStrFn</span>=toStrFn;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">table</span>=&#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">loseloseHashCode</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> key === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> tableKey=<span class="variable language_">this</span>.<span class="title function_">toStrFn</span>(key);</span><br><span class="line">    <span class="keyword">let</span> hash=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; tableKey.<span class="property">length</span>;i++) &#123;</span><br><span class="line">      hash+=tableKey.<span class="title function_">charCodeAt</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hash%<span class="number">37</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">hashCode</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">loseloseHashCode</span>(key);<span class="comment">//获取哈希值</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">put</span>(<span class="params">key,value</span>) &#123;<span class="comment">//向表中添加元素</span></span><br><span class="line">    <span class="keyword">if</span>(key!=<span class="literal">null</span>&amp;&amp;value!=<span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> position=<span class="variable language_">this</span>.<span class="title function_">hashCode</span>(key);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">table</span>[position]=<span class="keyword">new</span> <span class="title class_">ValuePair</span>(key,value);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">key</span>) &#123;<span class="comment">//根据key获取元素</span></span><br><span class="line">    <span class="keyword">const</span> valuePair=<span class="variable language_">this</span>.<span class="property">table</span>[<span class="variable language_">this</span>.<span class="title function_">hashCode</span>(key)];</span><br><span class="line">    <span class="keyword">return</span> valuePair==<span class="literal">null</span>?<span class="attr">undefined</span>:valuePair.<span class="property">value</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">remove</span>(<span class="params">key</span>) &#123;<span class="comment">//根据key删除元素</span></span><br><span class="line">    <span class="keyword">const</span> hash=<span class="variable language_">this</span>.<span class="title function_">hashCode</span>(key);</span><br><span class="line">    <span class="keyword">const</span> valuePair=<span class="variable language_">this</span>.<span class="property">table</span>[hash];</span><br><span class="line">    <span class="keyword">if</span>(valuePair!=<span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">table</span>[hash];</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h3><p>通过哈希表的原理我们可以发现，每一个键值对绑定了一个哈希值，但是哈希值是通过函数计算出来的，当不同的key带入时可能会出现相同的哈希值，这样我们在进行添加操作时就会在相同的位置添加造成值被覆盖，这就是哈希冲突。我们可以选择更好的哈希函数避免出现这种情况，但当数据量较大时难免出现哈希冲突，解决哈希冲突就需要我们对哈希表进行优化，这里介绍两种解决方案</p>
<h4 id="分离链接"><a href="#分离链接" class="headerlink" title="分离链接"></a>分离链接</h4><p>这种方法简单易懂，就是在每个位置维护一个链表，当出现重复哈希值的元素要添加时，在链表尾部添加即可</p>
<p><img src="/image/img_21.png" alt="image-20220908161116930"></p>
<ul>
<li><p>重写put方法</p>
<p>在添加元素时注意哈希值对应的位置是否为空，为空就需要创建一个链表，不为空就调用链表的push方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">put</span>(<span class="params">key,value</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(key!=<span class="literal">null</span>&amp;&amp;value!=<span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> position=<span class="variable language_">this</span>.<span class="title function_">hashCode</span>(key);</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">table</span>[position]==<span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">table</span>[position]=<span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">table</span>[position].<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">ValuePair</span>(key,value));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重写get方法</p>
<p>与普通的get方法相比增加了遍历链表找到匹配的key值的内容</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">get</span>(<span class="params">key</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> position=<span class="variable language_">this</span>.<span class="title function_">hashCode</span>(key);</span><br><span class="line">  <span class="keyword">const</span> linkedList=<span class="variable language_">this</span>.<span class="property">table</span>[position];</span><br><span class="line">  <span class="keyword">if</span>(linkedList!=<span class="literal">null</span>&amp;&amp;!linkedList.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">    <span class="keyword">let</span> current=linkedList.<span class="title function_">getHead</span>();</span><br><span class="line">    <span class="keyword">while</span>(current!=<span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(current.<span class="property">element</span>.<span class="property">key</span>===key) &#123;</span><br><span class="line">        <span class="keyword">return</span> current.<span class="property">element</span>.<span class="property">value</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      current=current.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重写remove方法</p>
<p>即对对应位置的链表做删除结点操作，要注意最后链表是否为空，为空要删除</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">remove</span>(<span class="params">key</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> position=<span class="variable language_">this</span>.<span class="title function_">hashCode</span>(key);</span><br><span class="line">  <span class="keyword">const</span> linkedList=<span class="variable language_">this</span>.<span class="property">table</span>[position];</span><br><span class="line">  <span class="keyword">if</span>(linkedList!=<span class="literal">null</span>&amp;&amp;!linkedList.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">    <span class="keyword">let</span> current=linkedList.<span class="title function_">getHead</span>();</span><br><span class="line">    <span class="keyword">while</span>(current!=<span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(current.<span class="property">element</span>.<span class="property">key</span>===key) &#123;</span><br><span class="line">        linkedList.<span class="title function_">remove</span>(current.<span class="property">element</span>);</span><br><span class="line">        <span class="keyword">if</span>(linkedList.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">          <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">table</span>[position];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">      current=current.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="线性探查"><a href="#线性探查" class="headerlink" title="线性探查"></a>线性探查</h4><p>当想向表中某个位置添加一个新元素的时候，如果索引为 position 的位置已经被占据了就尝试 position+1 的位置。如果 position+1的位置也被占据了，就尝试 position+2 的位置，以此类推，直到在散列表中找到一个空闲的位置。</p>
<p><img src="/image/img_22.png" alt="image-20220908162404363"></p>
<p>线性探查技术分为两种。第一种是软删除方法。我们使用一个特殊的值（标记）来表示键值对被删除了（惰性删除或软删除），而不是真的删除它。经过一段时间，散列表被操作过后， 我们会得到一个标记了若干删除位置的散列表。这会逐渐降低散列表的效率，因为搜索键值会随时间变得更慢。</p>
<p>第二种方法需要检验是否有必要将一个或多个元素移动到之前的位置。当搜索一个键的时候，这种方法可以避免找到一个空位置。如果移动元素是必要的，我们就需要在散列表中挪动键 值对。下图展现了这个过程。</p>
<p><img src="/image/img_22.png" alt="image-20220908162549774"></p>
<ul>
<li><p>重写put方法</p>
<p>添加时若位置已有元素就向下继续查找直到找到空位</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">put</span>(<span class="params">key,value</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(key!=<span class="literal">null</span>&amp;&amp;value!=<span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> position=<span class="variable language_">this</span>.<span class="title function_">hashCode</span>(key);</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">table</span>[position]==<span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">table</span>[position]=<span class="keyword">new</span> <span class="title class_">ValuePair</span>(key,value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> index=position+<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span>(<span class="variable language_">this</span>.<span class="property">table</span>[index]!=<span class="literal">null</span>) &#123;</span><br><span class="line">        index++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">table</span>[index]=<span class="keyword">new</span> <span class="title class_">ValuePair</span>(key,value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重写get方法</p>
<p>若哈希值对应的位置上的key与需要的key不相同就依次向下查找知道找到需要的key</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">get</span>(<span class="params">key</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> position=<span class="variable language_">this</span>.<span class="title function_">hashCode</span>(key);</span><br><span class="line">  <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">table</span>[position]!=<span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">table</span>[position].<span class="property">key</span>===key) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">table</span>[position].<span class="property">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> index=position+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="variable language_">this</span>.<span class="property">table</span>[index].<span class="property">key</span>!==key&amp;&amp;<span class="variable language_">this</span>.<span class="property">table</span>[index]!=<span class="literal">null</span>) &#123;</span><br><span class="line">      index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">table</span>[index]!=<span class="literal">null</span>&amp;&amp;<span class="variable language_">this</span>.<span class="property">table</span>[index].<span class="property">key</span>===key) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">table</span>[index].<span class="property">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重写remove方法</p>
<p>查找要删除的元素与get逻辑类似，但删除后要让后面需要位移的元素位移到删除位置填充空位</p>
<p>需要位移的元素特点是：根据key计算的hash值小于等于删除位置的哈希值或要查找的key对应的哈希值，因为整个哈希表的位置值是从小到大排序的，若出现了后面元素的哈希值比前面元素的哈希值小则一定经过了位移，需要调整</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">remove</span>(<span class="params">key</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> position=<span class="variable language_">this</span>.<span class="title function_">hashCode</span>(key);</span><br><span class="line">  <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">table</span>[position]!=<span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">table</span>[position].<span class="property">key</span>===key) &#123;</span><br><span class="line">      <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">table</span>[position];</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">verifyRemoveSideEffect</span>(key,position);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> index=position+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="variable language_">this</span>.<span class="property">table</span>[index]!=<span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">table</span>[index].<span class="property">key</span>===key) &#123;</span><br><span class="line">      <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">table</span>[index];</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">verifyRemoveSideEffect</span>(key,index);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    index++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">verifyRemoveSideEffect</span>(<span class="params">key, removedPosition</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> hash=<span class="variable language_">this</span>.<span class="title function_">hashCode</span>(key);</span><br><span class="line">  <span class="keyword">let</span> index=removedPosition+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="variable language_">this</span>.<span class="property">table</span>[index]!=<span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> posHash=<span class="variable language_">this</span>.<span class="title function_">hashCode</span>(<span class="variable language_">this</span>.<span class="property">table</span>[index].<span class="property">key</span>);</span><br><span class="line">    <span class="keyword">if</span>(posHash&lt;=hash||posHash&lt;=removedPosition) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">table</span>[removedPosition]=<span class="variable language_">this</span>.<span class="property">table</span>[index];</span><br><span class="line">      <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">table</span>[index];</span><br><span class="line">      removedPosition=index;</span><br><span class="line">    &#125;</span><br><span class="line">    index++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然有解决方案但我们要尽量避免哈希冲突的发生，因此应该寻找更好的哈希函数</p>
</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>数据结构</tag>
        <tag>哈希表</tag>
        <tag>哈希函数</tag>
        <tag>哈希冲突</tag>
        <tag>线性探查</tag>
        <tag>分离链接</tag>
      </tags>
  </entry>
  <entry>
    <title>css中的grid</title>
    <url>/2022/10/12/%E6%A0%85%E6%A0%BC%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h1 id="栅格布局"><a href="#栅格布局" class="headerlink" title="栅格布局"></a>栅格布局</h1><h3 id="创建栅格容器"><a href="#创建栅格容器" class="headerlink" title="创建栅格容器"></a>创建栅格容器</h3><p><code>display:grid</code>:创建常规栅格</p>
<p><code>display:inline-grid</code>:创建行内栅格</p>
<p>常规栅格与块级元素仍有区别：</p>
<p>浮动元素不会打乱栅格容器，栅格不会移动到浮动元素下方</p>
<p>栅格容器的外边距不与其后代的外边距折叠</p>
<ul>
<li><p>栅格容器上所有column属性都被忽略</p>
</li>
<li><p>栅格容器没有::first-line和::first-letter伪元素</p>
</li>
<li><p>栅格元素的float和clear属性会被忽略</p>
</li>
<li><p>vertical-align属性对栅格元素不起作用</p>
</li>
<li><p>如果设置的是inline-grid，但目标元素是浮动的或者绝对定位的，inline-grid将变成grid</p>
</li>
</ul>
<h3 id="栅格术语"><a href="#栅格术语" class="headerlink" title="栅格术语"></a>栅格术语</h3><ul>
<li>栅格元素：通常是栅格容器的子元素或者其中的匿名文本，参与栅格布局</li>
<li>栅格轨道：两条相邻栅格线之间夹住的整个区域（栅格列，栅格行）</li>
<li>栅格单元：四条栅格线确定的区域，内部没有其他栅格线（最小单元格）</li>
<li>栅格区域：任意四条栅格线确定的区域，最小的栅格区域是栅格单元</li>
</ul>
<h3 id="放置栅格线"><a href="#放置栅格线" class="headerlink" title="放置栅格线"></a>放置栅格线</h3><p>使用<code>grid-template-rows</code>和<code>grid-template-columns</code>定义栅格模板中的栅格线</p>
<h4 id="宽度固定的栅格轨道"><a href="#宽度固定的栅格轨道" class="headerlink" title="宽度固定的栅格轨道"></a>宽度固定的栅格轨道</h4><p>宽度固定指栅格线之间的距离不随着栅格轨道中内容的变化而变化，百分数也算宽度固定</p>
<p>如<code>grid-template-columns:100px 50% 200px</code>;</p>
<p>为栅格线命名：使用中括号，如：</p>
<p><code>grid-template-columns:[start]100px[first] 50%[second] 200px[end]</code>为四条栅格线分别命名</p>
<p>名称可以重用</p>
<p>设置百分数时可能会使内容超出容器，可以使用设置极值的方式解决</p>
<p>设定极值<code>minmax(a,b)</code>指明行的高度不能小于一个值也不能大于一个值</p>
<p>如<code>grid-template-columns:[start]100px[first] minmax(3em,50%)[second] 200px[end]</code>规定列宽不能大于50%也不能小于3个字号</p>
<p>使用设定极值时浏览器会自动计算让其在范围内把剩余空间尽量铺满</p>
<p>除了使用minmax()还可以使用calc()计算</p>
<h4 id="弹性栅格轨道"><a href="#弹性栅格轨道" class="headerlink" title="弹性栅格轨道"></a>弹性栅格轨道</h4><p>弹性栅格轨道的尺寸基于整个轨道中的具体内容而定</p>
<p>份数单位：fr</p>
<p><code>grid-template-columns:1fr 1fr 1fr 1fr</code>&#x3D;<code>grid-template-columns:25% 25% 25% 25%</code></p>
<p>除了替代百分数外，fr还可以实现部分弹性伸缩</p>
<p>例如：<code>grid-template-columns:100px 1fr 100px</code></p>
<p>容器宽度大于200px时，剩余部分会全被分给1fr对应的部分</p>
<p>minmax()设定的最小值不允许以fr为单位，但最大值可以</p>
<h5 id="min-content和max-content"><a href="#min-content和max-content" class="headerlink" title="min-content和max-content"></a>min-content和max-content</h5><p>max-content:占据内容所需的最大空间&#x2F;内容尽量宽，以免换行</p>
<p>min-content:尽量少占据空间，能够显示出内容即可</p>
<p>这两个属性会应用到整个栅格轨道之上，如果把一列的尺寸设置成max-content,整列的宽度都与列中最宽的内容一样</p>
<p>如果在minmax中设置<code>minmax(0,max-content)</code>；那么将在确保不超出弹性容器的基础上尽量向max的值靠拢</p>
<p>如果将列和行都设置为max-content，浏览器先解析列再解析行，和只设置列是一样的</p>
<h5 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h5><p>auto用作最小值时，视作栅格元素的最小尺寸（由mid-width和mid-height定义）</p>
<p>作最大值时，作用等同于max-content</p>
<p>任何地方都可以使用auto，要么作最小值，要么作最大值，但<strong>尽量避免使用auto</strong></p>
<h5 id="fit-content"><a href="#fit-content" class="headerlink" title="fit-content"></a>fit-content</h5><p><code>fit-content(argument)=minmax(argument&gt;min-content?argument:min-content , argument&lt;max-content?arguement:max-content);</code></p>
<p>使用fit-content,内容不多时，轨道将缩小为最小内容尺寸，内容较多时，能为轨道尺寸设置一个上限</p>
<h4 id="重复栅格线"><a href="#重复栅格线" class="headerlink" title="重复栅格线"></a>重复栅格线</h4><p>使用repeat（）设置重复栅格线</p>
<p>例如：<code>grid-template-columns:repeat(10,5em)</code>将创建10个5字号轨道宽度的列轨道</p>
<p>也可以重复固定模式的列轨道</p>
<p>如：<code>grid-template-columns:repeat(10,5em 1fr 1fr)</code>将创建列结构为5em，1fr，1fr，然后重复10次，也就是创建了30个列轨道</p>
<p>如果想额外增加列，可以：<code>grid-template-columns:repeat(10,5em 1fr 1fr) 5em</code>在重复结束后加上一个列轨道</p>
<p>repeat（）中几乎可以使用任意值，但不能在重复中嵌套重复</p>
<h5 id="自动填充轨道"><a href="#自动填充轨道" class="headerlink" title="自动填充轨道"></a>自动填充轨道</h5><p>如果想让一直重复：<code>repeat(auto-fill,5em)</code>将会把5em的宽度一直重复到放不下为止</p>
<p>在一个模板里只能有一个自动重复的模式</p>
<p>固定数量的重复模式可以与自动填充的轨道结合到一起使用</p>
<p>使用auto-fill，没有元素的单元格会得到保留</p>
<p>但如果使用auto-fit，则会剔除</p>
<h4 id="栅格区域"><a href="#栅格区域" class="headerlink" title="栅格区域"></a>栅格区域</h4><p><code>grid-template-areas:none/String</code></p>
<p>使用字符串作为标识符，合并相同字符串</p>
<p>如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">grid-template-areas</span>:</span><br><span class="line"><span class="string">&quot;h h h h&quot;</span></span><br><span class="line"><span class="string">&quot;b c c c&quot;</span></span><br><span class="line"><span class="string">&quot;f f d d&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>第一行只有一列，第二行两列，宽度1：3，第三行同理</p>
<p>只能合并矩形区域，不能合并非矩形区域，形状太复杂会导致模板失效</p>
<p>通过area为区域标记名称，区域的栅格线实际上也已经隐式确定了名称</p>
<p>为了与内容匹配可以设置元素的grid-area</p>
<h3 id="在栅格中添加元素"><a href="#在栅格中添加元素" class="headerlink" title="在栅格中添加元素"></a>在栅格中添加元素</h3><p>可以引用栅格线，也可以引用栅格区域</p>
<h4 id="使用行线和列线"><a href="#使用行线和列线" class="headerlink" title="使用行线和列线"></a>使用行线和列线</h4><p><code>grid-row-start</code>:规定元素起始的行线（栅格线）</p>
<p><code>grid-row-end</code>:规定元素在那条行线结束</p>
<p><code>grid-column-start</code>和<code>grid-column-end</code>同理</p>
<p>如果省略的结束线，则自动使用起始线的下一条线结束，这等同于</p>
<p><code>grid-column-end:span 1 </code>或<code>grid-column-end: span</code></p>
<p>span后面的数字表示”跨越指定数目的栅格轨道“，只能用正整数</p>
<p>span既可以用于开始线也可以用于结束线。用于开始线时，意思是”从结束线开始，向开始方向计数“</p>
<p>通过显式定义的栅格线编号可以为负数，代表从后往前数第|n|个栅格线</p>
<p>栅格线编号除了通过数字引用也可以通过声明过的命名调用</p>
<p>还可以通过<code>grid-template-area</code>中定义的名称调用</p>
<h4 id="行和列的简写"><a href="#行和列的简写" class="headerlink" title="行和列的简写"></a>行和列的简写</h4><p>使用<code>grid-row</code>和<code>grid-column</code>可以简化声明开始和结束栅格线的过程</p>
<p>如：<code>grid-row:1/3</code></p>
<p>以斜线分割的两部分中，前半部分定义开始栅格线，后半部分定义结束栅格线</p>
<p>如果没有斜杆，定义的是开始栅格线，结束栅格线的位置却决于开始栅格线</p>
<ul>
<li>如果开始栅格线是名称，结束栅格线就是下一条同名栅格线</li>
<li>如果只提供一个数字，下一个栅格线是auto</li>
</ul>
<h4 id="隐式栅格"><a href="#隐式栅格" class="headerlink" title="隐式栅格"></a>隐式栅格</h4><p>如果行线只显示定义了三条，却进行了类似<code>grid-row:1/4</code>这样的声明，浏览器会再创建一条行线，这条栅格线和由此产生的栅格轨道是隐式栅格的一部分</p>
<p>span是从显示栅格内部开始计数的，但不一定在显示栅格内部结束</p>
<h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>如果开始线在结束线后面，会将两者对调</p>
<p>如果开始线和结束线都为跨度，忽略结束线并将值设置成auto</p>
<h4 id="使用区域"><a href="#使用区域" class="headerlink" title="使用区域"></a>使用区域</h4><p>将预先声明的<code>grid-template-areas</code>的标识符通过<code>grid-area</code>赋给元素</p>
<p>grid-area也可以直接使用</p>
<p><code>grid-area:row-start/column-start/row-end/column-end</code>根据这种规范来确定区域</p>
<h4 id="栅格元素重叠"><a href="#栅格元素重叠" class="headerlink" title="栅格元素重叠"></a>栅格元素重叠</h4><p>栅格元素是有可能重叠的</p>
<h3 id="栅格流"><a href="#栅格流" class="headerlink" title="栅格流"></a>栅格流</h3><p>栅格流主要分为两种模式：行优先和列优先，二者都可以通过密集流增强</p>
<p>通过grid-auto-flow设置栅格流</p>
<p><code>grid-auto-flow:row/column||dense</code>默认是row</p>
<p>栅格流放置的实际上是栅格区域，然后再把栅格元素放置到栅格区域中</p>
<p>行流和列流的工作方式是：如果下一个单元格可以放下对应的元素则放下，如果不能则跳过此单元格保证顺序。</p>
<p>如果想让元素尽量堆满单元格而不考虑顺序，可以在<code>grid-auto-flow</code>中加入dense</p>
<h3 id="自动增加栅格线"><a href="#自动增加栅格线" class="headerlink" title="自动增加栅格线"></a>自动增加栅格线</h3><p>如果有元素超出了声明的行&#x2F;列，系统会自动增加栅格线</p>
<p>一般来说，自动增加的栅格线对应的是最小尺寸，如果需要修改最小尺寸，可以使用</p>
<p><code>grid-auto-columns,grid-auto-rpws</code></p>
<p>可以为其添加一个属性值（极值）来为自动添加的行规范尺寸</p>
<h3 id="栏距"><a href="#栏距" class="headerlink" title="栏距"></a>栏距</h3><p>栏距由row-gap和column-gap设置，只能为非负数，不能为百分数或fr</p>
<p>简写是grid-gap</p>
<h3 id="栅格元素与盒模型"><a href="#栅格元素与盒模型" class="headerlink" title="栅格元素与盒模型"></a>栅格元素与盒模型</h3><p>当未为元素设置width和height时，设置正外边距会让元素向中心收缩，负外边距会向周围扩张</p>
<p>如果元素尺寸设置了，那么外边距将被覆盖</p>
<p>元素外边距不会影响栅格轨道尺寸的计算</p>
<p>如果栅格元素声明了绝对定位：对应的栅格区域充当容纳块和定位上下文</p>
<h3 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h3><p><code>justify-self</code>和<code>align-self</code>:控制元素在对应栅格区域内的横向&#x2F;纵向对齐方式</p>
<p><code>justify-item</code>和<code>align-item</code>:控制栅格容器内所有元素的横向&#x2F;纵向对齐方式</p>
<p><code>justify-content</code>和<code>align-content</code>:控制栅格的对齐属性，为栅格分配多余的空间事实上是调整栅格的栏距尺寸</p>
<h3 id="分层和排序"><a href="#分层和排序" class="headerlink" title="分层和排序"></a>分层和排序</h3><p>元素若重叠，分层可以使用z-index</p>
<p>若想控制元素出现的顺序，同样可以使用order，只改变视觉顺序不改变阅读源码顺序</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>栅格布局内容繁杂，引入了大量新特性，需要时常温故知新</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>js数据结构：栈</title>
    <url>/2022/10/12/%E6%A0%88/</url>
    <content><![CDATA[<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈是一种后入先出的数据结构</p>
<h4 id="用JavaScript对象来创建栈"><a href="#用JavaScript对象来创建栈" class="headerlink" title="用JavaScript对象来创建栈"></a>用JavaScript对象来创建栈</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span>=<span class="number">0</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span>=&#123;&#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="title function_">push</span>(<span class="params">element</span>) &#123;<span class="comment">//向栈中添加元素</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">count</span>]=element;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span>++;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="title function_">pop</span>(<span class="params"></span>) &#123;<span class="comment">//从栈中弹出元素</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">count</span>===<span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span>--;</span><br><span class="line">    <span class="keyword">const</span> result=<span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">count</span>];</span><br><span class="line">    <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">count</span>];</span><br><span class="line">    <span class="keyword">return</span> result;<span class="comment">//返回被删除的元素</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="title function_">peek</span>(<span class="params"></span>) &#123;<span class="comment">//返回栈顶元素</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">count</span>===<span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">count</span>-<span class="number">1</span>]</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="title function_">clear</span>(<span class="params"></span>) &#123;<span class="comment">//清空栈</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span>=&#123;&#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span>=<span class="number">0</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;<span class="comment">//判断栈是否清空</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">count</span>===<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;<span class="comment">//字符串化</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> objString=<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.items[<span class="number">0</span>]&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>;i &lt; <span class="variable language_">this</span>.<span class="property">count</span>;i++) &#123;</span><br><span class="line">      objString=<span class="string">`<span class="subst">$&#123;objString&#125;</span>,<span class="subst">$&#123;<span class="variable language_">this</span>.items[i]&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> objString;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="栈的安全性"><a href="#栈的安全性" class="headerlink" title="栈的安全性"></a>栈的安全性</h4><p>我们使用栈只希望元素添加到栈顶而不是其他位置，因此要保护栈的内部元素，然而我们创建的Stack类并没有这样的功能</p>
<ul>
<li><p>用 ES2015 的 WeakMap 实现类</p>
<p>如果用 WeakMap 来存储 items 属性（数组版本），Stack 类就是这样的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> items = <span class="keyword">new</span> <span class="title class_">WeakMap</span>(); <span class="comment">// &#123;1&#125; </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123; </span><br><span class="line"> <span class="title function_">constructor</span> () &#123; </span><br><span class="line"> items.<span class="title function_">set</span>(<span class="variable language_">this</span>, []); <span class="comment">// &#123;2&#125; </span></span><br><span class="line"> &#125; </span><br><span class="line"> <span class="title function_">push</span>(<span class="params">element</span>)&#123; </span><br><span class="line"> <span class="keyword">const</span> s = items.<span class="title function_">get</span>(<span class="variable language_">this</span>); <span class="comment">// &#123;3&#125; </span></span><br><span class="line"> s.<span class="title function_">push</span>(element); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="title function_">pop</span>(<span class="params"></span>)&#123; </span><br><span class="line"> <span class="keyword">const</span> s = items.<span class="title function_">get</span>(<span class="variable language_">this</span>); </span><br><span class="line"> <span class="keyword">const</span> r = s.<span class="title function_">pop</span>(); </span><br><span class="line"> <span class="keyword">return</span> r; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="comment">// 其他方法</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>行{1}，声明一个 WeakMap 类型的变量 items。</p>
<p>行{2}，在 constructor 中，以 this（Stack 类自己的引用）为键，把代表栈的数组 存入 items。</p>
<p>行{3}，从 WeakMap 中取出值，即以 this 为键（行{2}设置的）从 items 中取值。</p>
<p>采用这种方法，代码的可读性 不强，而且在扩展该类时无法继承私有属性。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>数据结构</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器的工作原理</title>
    <url>/2022/10/12/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%88%E7%AE%80%E6%98%93%E7%89%88%EF%BC%89/</url>
    <content><![CDATA[<h3 id="浏览器的工作原理（简易版）"><a href="#浏览器的工作原理（简易版）" class="headerlink" title="浏览器的工作原理（简易版）"></a>浏览器的工作原理（简易版）</h3><p>输入url后</p>
<ol>
<li><p>浏览器进行dns查找，把域名转换为ip地址，根据ip地址找到对应的服务器</p>
</li>
<li><p>浏览器通过TCP握手机制跟服务器建立连接，如果为https还有一步TLS握手</p>
</li>
<li><p>浏览器发起http&#x2F;https请求，获取响应。在浏览器接收响应时，受制于TCP连接的性质，浏览器先收到前14kb的数据，后续才会慢慢增加传输速度下载其他文件</p>
</li>
<li><p>收到html代码后，浏览器开始渲染网页</p>
<ol>
<li><p>解析html代码，构建DOM树（HTML文档在浏览器中的对象表示）</p>
<p>浏览器在解析HTML时顺序执行并且只有一个主线程负责，遇到script标签会先执行js代码，暂停解析html代码。对于图片，css文件，设置了defer&#x2F;async的script标签不会影响html解析，会异步加载</p>
<p>浏览器具有预扫描线程，扫描html代码，提前把css文件，字体，js文件下载下来，不影响主线程</p>
<p><img src="/image/image1.png" alt="dom树"></p>
</li>
<li><p>构建CSSOM树</p>
<p><img src="/image/image2.png" alt="CSSOM树"></p>
</li>
<li><p>合并DOM和CSSOM，形成渲染树</p>
<p><img src="/image/image3.png" alt="渲染树"></p>
</li>
<li><p>布局</p>
<p>对于图片这样的结点，如果没有指定宽高，会先忽略大小。图片下载完成后，浏览器根据图片的大小重新计算受影响的结点的宽高，这种方法被称为回流（reflow）</p>
</li>
<li><p>绘制</p>
<p>第一次布局之后，浏览器会把结点和结点的样式绘制在屏幕上，要求过程快速</p>
<p>如果布局发生回流，浏览器会发生重绘，把变化的布局重新绘制在屏幕上</p>
<p>绘制期间可能会有组合发生（产生了新的图层）,浏览器需要把图层组合起来，按正确的图层顺序渲染，发生了重绘也会导致重新组合</p>
<p>上述五步完成后，设置了defer&#x2F;async的script中的内容，网页加载完成</p>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器的缓存机制</title>
    <url>/2022/10/12/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h3 id="浏览器的缓存机制"><a href="#浏览器的缓存机制" class="headerlink" title="浏览器的缓存机制"></a>浏览器的缓存机制</h3><p>​	浏览器的缓存机制就是HTTP的缓存机制，是根据HTTP报文的缓存标识进行的</p>
<h4 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h4><p>​	强制缓存就算像浏览器缓存查找请求结果，并根据结果的缓存规则来判断是否使用缓存。强制缓存有三种情况</p>
<ul>
<li>不存在缓存结果和缓存标识，强制缓存失败，直接向服务器发送请求</li>
<li>存在缓存结果和缓存标识，但结果已失效，强制缓存失效，使用协商缓存</li>
<li>存在缓存结果和缓存标识，且结果尚未失效，则强制缓存生效，直接返回结果</li>
</ul>
<p>判断缓存结果是否失效的缓存规则放在HTTP响应报文中，控制强制缓存的字段是<code>Expires</code>和<code>Cache-Control</code>，后者优先级更高</p>
<ul>
<li><code>Expires</code>的时间值是一个绝对值，当客户端时间超过其值时强制缓存失效</li>
<li><code>Cache-Control</code>的时间值是一个相对值，它的值表示缓存的有效时间，用<code>max-age</code>表示</li>
</ul>
<h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><p>​	强制缓存失效后，浏览器携带缓存标识向服务器发送请求，服务器根据缓存标识决定是否使用缓存。协商缓存生效，返回304，协商缓存失效，返回200和请求结果</p>
<p>​	缓存标识也是在响应报文中返回浏览器的。控制协商缓存的字段分别有：<code>Last-Modified</code>和<code> If-Modified-Since</code></p>
<h5 id="Last-Modified-x2F-If-Modified-Since"><a href="#Last-Modified-x2F-If-Modified-Since" class="headerlink" title="Last-Modified&#x2F;If-Modified-Since"></a><code>Last-Modified</code>&#x2F;<code>If-Modified-Since</code></h5><p>Last-Modified是服务器响应请求时，返回该资源文件在服务器最后被修改的时间</p>
<p>If-Modified-Since则是客户端再次发起该请求时，携带上次请求返回的Last-Modified值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有If-Modified-Since字段，则会根据If-Modified-Since的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于If-Modified-Since的字段值，则重新返回资源，状态码为200；否则则返回304，代表资源无更新，可继续使用缓存文件</p>
<h5 id="Etag-x2F-If-None-Match"><a href="#Etag-x2F-If-None-Match" class="headerlink" title="Etag&#x2F;If-None-Match"></a><code>Etag</code>&#x2F;<code>If-None-Match</code></h5><p><code>Etag</code>是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)</p>
<p>If-None-Match是客户端再次发起该请求时，携带上次请求返回的唯一标识<code>Etag</code>值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有<code>If-None-Match</code>，则会根据<code>If-None-Match</code>的字段值与该资源在服务器的<code>Etag</code>值做对比，一致则返回304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为200</p>
<h3 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h3><p>在 Header 内的字段用于控制缓存机制<br>老方法 Expires，记录的绝对值<br>新方法 Cache-Control 多了一堆选项，记录的时间是相对值<br>获取缓存检测缓存是否过期，如果没过期取缓存，优先从内存，其次硬盘，如果过期，则与服务器协商缓存是否仍然可用，如果不可用则获取，可用取缓存</p>
<p>​	</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>计网</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>css中的滤镜，混合，遮罩，裁剪</title>
    <url>/2022/10/12/%E6%BB%A4%E9%95%9C%E3%80%81%E6%B7%B7%E5%90%88%E3%80%81%E8%A3%81%E5%89%AA%E5%92%8C%E9%81%AE%E7%BD%A9/</url>
    <content><![CDATA[<h1 id="滤镜、混合、裁剪和遮罩"><a href="#滤镜、混合、裁剪和遮罩" class="headerlink" title="滤镜、混合、裁剪和遮罩"></a>滤镜、混合、裁剪和遮罩</h1><h2 id="CSS滤镜"><a href="#CSS滤镜" class="headerlink" title="CSS滤镜"></a>CSS滤镜</h2><p><code>filter:none/blur()/brightness()/contrast()/drop-shadow()/grayscale()/</code></p>
<p><code>hue-rotate()/invert()/opacity()/sepia()/saturate()/url()</code></p>
<p>滤镜函数可以有多个，之间以空格分隔，各滤镜按列出的顺序应用</p>
<h3 id="基本滤镜"><a href="#基本滤镜" class="headerlink" title="基本滤镜"></a>基本滤镜</h3><p><code>blur(&lt;length&gt;)</code>使用高斯模糊对元素进行处理，标准偏差由length的值确定，设为0时不做模糊处理，不能为负值</p>
<p><code>opacity(&lt;number&gt;|&lt;percentage&gt;)</code>把透明度应用到元素上，与opacity属性十分相似，0表示完全透明，1或100%不做处理，不能使用负值</p>
<p><code>drop-shadow(&lt;length&gt;&#123;2,3&#125;&lt;color&gt;?)</code>长度和颜色的处理方式和box-shadow一样，如果不提供color，则使用元素的color属性决定阴影颜色</p>
<h3 id="颜色滤镜"><a href="#颜色滤镜" class="headerlink" title="颜色滤镜"></a>颜色滤镜</h3><p><code>grayscale([&lt;length&gt;|&lt;percentage&gt;])</code>把元素颜色变为指定的灰阶，当为0时不变，值为1或100%时完全变灰</p>
<p><code>sepia([&lt;number|&lt;percentage&gt;])</code>把元素由原色变为墨色调，当为0时不变，值为1或100%时完全变褐色</p>
<p><code>invert([&lt;number|&lt;percentage&gt;])</code>把元素作反相处理，0时不变，1时完全反相，0.5时得到均匀的灰色</p>
<p><code>hue-rotate(&lt;angle&gt;)</code>在色轮上旋转色相，而饱和度和透明度不变，0deg时无变化，360deg时也没变化，也可以为负数，表示逆时针转动</p>
<h3 id="亮度，对比度，饱和度"><a href="#亮度，对比度，饱和度" class="headerlink" title="亮度，对比度，饱和度"></a>亮度，对比度，饱和度</h3><p><code>brightness([&lt;number|&lt;percentage&gt;])</code>调整亮度，0时为黑色，1时正常，大于1时变亮，最终可能会变为白色</p>
<p><code>contrast([&lt;number|&lt;percentage&gt;])</code>调整对比度，0时变为纯灰色，1时正常，大于1时对比度加大</p>
<p><code>saturate([&lt;number|&lt;percentage&gt;])</code>调整饱和度,值越大颜色越鲜艳，越小颜色越暗淡</p>
<h3 id="SVG滤镜"><a href="#SVG滤镜" class="headerlink" title="SVG滤镜"></a>SVG滤镜</h3><p><code>url()</code>可以使用这个函数指定在SVG中定义的滤镜，实现从外部引用滤镜</p>
<h2 id="合成和混合"><a href="#合成和混合" class="headerlink" title="合成和混合"></a>合成和混合</h2><p>使用<code>mix-bend-mode</code>属性设定</p>
<p><code>mix-bend-mode: normal/multiply/screen/overlay/darken/lighten/color-dodge</code></p>
<p><code>/color-burn/hard-light/soft-light/difference/exclusion/hue/saturation/color/luminosity</code></p>
<ul>
<li>应用<code>mix-bend-mode</code>的元素是前景</li>
<li>位于元素背后的是背着物</li>
<li>像素分量是某个像素的颜色分量</li>
</ul>
<h3 id="变暗，变亮，差值和排除"><a href="#变暗，变亮，差值和排除" class="headerlink" title="变暗，变亮，差值和排除"></a>变暗，变亮，差值和排除</h3><p><code>darken</code>:前景中每个像素与背着物每个像素比较，取R,G,B中的较小值</p>
<p><code>lighten</code>:前景中每个像素与背着物每个像素比较，取R,G,B中的较大值</p>
<p><code>difference</code>:前景中每个像素与背着物每个像素比较，取R,G,B差的绝对值</p>
<p><code>exclusion</code>:<code>difference</code>的温和版本，所用公式是back+fore-|2 x back x fore|,back和fore是0到1之间的值</p>
<h3 id="正片叠底，滤色和叠加"><a href="#正片叠底，滤色和叠加" class="headerlink" title="正片叠底，滤色和叠加"></a>正片叠底，滤色和叠加</h3><p><code>multiply</code>:前景中每个像素分量与背着物中对应位置上的像素分量相乘。得到的结果与前景相比更暗</p>
<p><code>screen</code>:对前景和背着物中同一位置的像素分量作反相处理，相乘后再反相。得到的结果与前景相比更亮</p>
<p><code>overlay</code>:<code>multiply</code>和<code>screen</code>的综合运用，如果前景像素分量比50%暗，执行multiply，反之执行screen</p>
<h3 id="强光和柔光"><a href="#强光和柔光" class="headerlink" title="强光和柔光"></a>强光和柔光</h3><p><code>hard-light</code>: 与<code>overlay</code>相反，起决定作用的是背着物</p>
<p><code>soft-light</code>:<code>hard-light</code>的柔和版本，效果有所缓和</p>
<h3 id="颜色减淡和加深"><a href="#颜色减淡和加深" class="headerlink" title="颜色减淡和加深"></a>颜色减淡和加深</h3><p><code>color-dodge</code>:前景中各像素分量做反相处理，再拿背着物中对应的像素分量除以反相后的前景值。得到的结果是背着物变得更亮</p>
<p><code>color-bend</code>:与<code>color-dodge</code>的作用相反。背着物各像素分量做反相处理，反相后的背着物值除以没有修改的前景值，然后再反相。结果是背着物中越暗的像素，由前景中像素加深的程度越大</p>
<h3 id="色相，饱和度，明度和颜色"><a href="#色相，饱和度，明度和颜色" class="headerlink" title="色相，饱和度，明度和颜色"></a>色相，饱和度，明度和颜色</h3><p><code>hue</code>:把背着物中每一像素的明度和饱和度与前景中对应像素的色相角度合并</p>
<p><code>saturation</code>:把背着物中每一像素的色相角度和明度与前景中对应像素的饱和度合并</p>
<p><code>color</code>:把背着物中每一像素的明度与前景中对应像素的色相角度和饱和度合并</p>
<p><code>luminosity</code>:把背着物中每一像素的色相角度和饱和度与前景中的对应像素合并</p>
<h2 id="与背景混合"><a href="#与背景混合" class="headerlink" title="与背景混合"></a>与背景混合</h2><p><code>mix-blend-mode</code>只能将元素与背着物混合，当元素有多个背景图且背景图有重叠时，可以使用<code>background-blend-mode</code>属性</p>
<p>该属性的值与<code>mix-blend-mode</code>相同</p>
<h3 id="独立混合"><a href="#独立混合" class="headerlink" title="独立混合"></a>独立混合</h3><p>使用<code>isolation:isolate</code>将父元素独立出来从而影响子元素的混合方式</p>
<h2 id="裁剪和遮罩"><a href="#裁剪和遮罩" class="headerlink" title="裁剪和遮罩"></a>裁剪和遮罩</h2><p>如果只想把元素的一部分裁掉，可以使用<code>clip-path</code>属性</p>
<h3 id="裁剪形状"><a href="#裁剪形状" class="headerlink" title="裁剪形状"></a>裁剪形状</h3><p><code>inset()</code>:值为1到4个长度或百分数，定义距离范围框各边的偏移量,可以使用<code>round</code>关键字或另一组4个长度或百分比定义圆角</p>
<p><code>circle()</code>:只接受一个值定义圆的半径。在一或两个长度或百分数后使用at关键字定义圆心位置</p>
<p><code>ellispse()</code>值为两个长度或百分数或关键字定义椭圆在横轴或纵轴上的半径，在一或两个长度或百分数后使用at关键字定义圆心位置</p>
<p><code>polygon()</code>一系列以x和y坐标值（空格分开）定义多边形</p>
<h2 id="蒙版"><a href="#蒙版" class="headerlink" title="蒙版"></a>蒙版</h2><p>“蒙版的意思是”：位于形状内部的内容可见，而在形状外部的内容不可见</p>
<h3 id="定义蒙版"><a href="#定义蒙版" class="headerlink" title="定义蒙版"></a>定义蒙版</h3><p>指定用什么图像作为蒙版:<code>mask-image</code></p>
<h3 id="改变蒙版模式"><a href="#改变蒙版模式" class="headerlink" title="改变蒙版模式"></a>改变蒙版模式</h3><p>使用<code>mask-mode</code>改变蒙版模式</p>
<p><code>mask-mode:alpha/luminance/match-source</code></p>
<p><code>alpha</code>:通过alpha通道计算蒙版，<code>luminance</code>使用亮度计算蒙版</p>
<p><code>match-source</code>:是<code>alpha</code>和<code>luminance</code>的结合体</p>
<h3 id="调整蒙版尺寸和重复方式"><a href="#调整蒙版尺寸和重复方式" class="headerlink" title="调整蒙版尺寸和重复方式"></a>调整蒙版尺寸和重复方式</h3><p>使用<code>mask-size</code>调整蒙版尺寸</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>关于爱情</title>
    <url>/2022/10/12/%E7%88%B1%E6%83%85/</url>
    <content><![CDATA[<h3 id="爱情"><a href="#爱情" class="headerlink" title="爱情"></a>爱情</h3><p>看了b站一个视频，对其中的内容做一个笔记，结合一下自身</p>
<h3 id="爱与情"><a href="#爱与情" class="headerlink" title="爱与情"></a>爱与情</h3><p><strong>爱是能发自内心的替ta而死，情是能彼此同时能有一种感觉</strong></p>
<p>​	爱是能发自内心的替ta而死，替ta而死不是为ta而死。为ta而死总有种自我感动的成分在其中，替ta而死更接近于你可以在ta不知道你死的情况下去死。父母的爱是真正的爱，他们往往能做到替孩子而死，即使孩子很叛逆很无知。为ta而死的情感最多可以称为恋，不是爱。</p>
<p>​	情是彼此同时有一种感觉。情强调双向，如亲情，如果只是父母对孩子很好，而孩子不知感恩，对父母很差的话，我们只能评价他爸他妈对他很好，他爸他妈很惯他，而不能说他们家庭里亲情很浓厚</p>
<p>​	那么爱情就是双方都能感觉到让对方活比自己活更为快乐</p>
<h3 id="男性：真理"><a href="#男性：真理" class="headerlink" title="男性：真理"></a>男性：真理</h3><p>​	在谈如何选择爱时，先解释一下男性和女性对待事物的原型。男性的原型是真理，女性的原型是爱。真理和爱是生命的一部分，真理是生命的形式，爱是生命的力量。当谈到爱情的时候，要有爱的感觉，然后也要有途径</p>
<p>​	真理是强调过程，行为的。当男性谈到一件事的时候，一件不能十分轻松做到的事的时候，相比于判断自己是否真的要做，会花更多的精力研究怎么去做，完成的途径。</p>
<p>​	男性在对待伴侣的选择问题是，会更想寻找一个对自己有所爱慕，敬仰的。因为真理本身的特点就是渴望被认可，敬佩的，兄弟彼此之间的敬佩也是这个原因。我们谈到智者也会先联想到男性老者而不是女性老者，也是因为男性会更强调认可。</p>
<h3 id="女性：爱"><a href="#女性：爱" class="headerlink" title="女性：爱"></a>女性：爱</h3><p>​	相比于男性的真理，女性的原型就是爱。<strong>真理强调行为，爱强调选择</strong>。女性会更需要<strong>承认</strong>，承认是指自己不用变，做自己就行了。而男性在这方面是相反的，男性更倾向于改变。男性的真理需要扩充，不断更新，女性的爱则更倾向于自己的内心不被污染，更倾向保护，保护自己的纯真</p>
<h3 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h3><p>​	通过男性和女性的原型，可以有：<strong>男性看行动，女性看选择</strong>。女性选择男性，要看这个男性做了什么而不是说了什么，因为男性在语言上是可以学习的，可以学习各种话术。他可以让女性认为自己可能是怎样的，通过话术包装自己。男性的行为往往可以反应出他的真理，因此在选择男性时更应该看行为。</p>
<p>​	而男性选择女性，要看女性在关键时刻做出的选择。我们经常可以发现，一对男女在经历过一件事之后，男性会说自己突然发现她不爱我了，因为他看到了女性的选择。男性选择女性，不必纠结于女性过去做了什么，这是真理层面的内容，而是要看她在人生关键时刻做出的选择。她对这些事情的选择体现了她的爱。例如一个女性，当她的生活安然无恙时她体现的很纯良，但当压力很大，面临危机时，这时候应该看她选择宽恕还是憎恶，戾气还是温柔，这样就知道她的爱了</p>
<p>最后贴一下视频链接<a href="https://www.bilibili.com/video/BV15a411f7Xt/?spm_id_from=333.788&vd_source=ea0b821b0c66dd7f6257ac303626c797">18分钟解密爱情的核心，男生看行动，女生看选择_哔哩哔哩_bilibili</a>单纯是比较赞同观点而记录下</p>
]]></content>
      <categories>
        <category>爱情</category>
        <category>生活</category>
      </categories>
      <tags>
        <tag>爱情</tag>
        <tag>真理</tag>
        <tag>爱</tag>
        <tag>生活</tag>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title>HUSTSE李院长数据结构课程初评</title>
    <url>/2022/10/12/%E7%AE%80%E8%AF%84%E8%BD%AF%E9%99%A2%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE/</url>
    <content><![CDATA[<h3 id="HUSTSE数据结构李院长课程听后感"><a href="#HUSTSE数据结构李院长课程听后感" class="headerlink" title="HUSTSE数据结构李院长课程听后感"></a>HUSTSE数据结构李院长课程听后感</h3><p>​	首先，我很少听课，或者很少上课，因为李院长特有的随时提问机制，不得不选择听课，听了两节课之后，简要写一下听后感</p>
<p>​	其实对于李院长的课我早已有了心理准备，作为软院四大名师之一声名远扬，念念ppt，上课水我确实能够接受，毕竟很多老师都是这样，给学生留下了充足的自学空间</p>
<p>​	但李院长能位列四大名师，必定有他过人之处：<strong>让你无论是听课还是自学都困难</strong></p>
<p>​	首先课堂上我个人认为学生有权利选择是否听课，因为授课老师的方式或者教学质量并不能适合所有学生，学生应该选择更适合自己的学习方式，然而李不同意。李对自己的课堂教学有着超出寻常的自信，认为我们都应该认真听他上课。事实是什么样子呢？喜欢夹带些英语，问些奇怪问题暂且不说，自己做的ppt上的断句都要琢磨半天真的像是认真备课的样子吗？而且不知道自己上节课讲了什么，把要讲的内容当成讲过的内容，是不是祖传ppt就忘了备课？反正我听下来是比较失望的</p>
<p>​	如果我已经听到这里，我一定会选择打开电脑自己去实现数据结构，然而，李院长通过提问实时检测你有没有听课。而且他提问的内容千奇百怪，因为我个人有一些数据结构基础，我的个人感觉是他认为我们都已经学完数据结构了，能回答他的问题的同学应该是提前学过的。对于没有学过的同学，既不知道他在问什么，也不知道他问的有什么用。除了这种“向后提问”，还有”向前提问“。李会突然提问他刚刚讲过的知识，仿佛在抽查同学们的听课效率，让我梦回高中。</p>
<p>​	最后一点，还是这个提问，我最想说的其实是尊重问题。李明显有种作为教师高高在上的感觉，他不屑于倾听，只想听到他想听到的答案。因此他会突然打断同学的发言让他坐下或者提问其他人。如果是想省时间就不要提问好吧，提问又不给学生最基本的尊重，属于师德问题。</p>
<p>​	顺便提一下上学期教英语的Helen老师，真的天使，无论学生有没有听课，回答的怎么样，她都能认真倾听，努力识别我们不熟的口语。她真的是很照顾学生的老师，希望李能够向她学习。</p>
<p>​	目前只听了两堂课，后面可能会再写些，关于他数据结构核心知识的讲解评价</p>
<p>​	</p>
]]></content>
      <categories>
        <category>课堂</category>
        <category>评价</category>
        <category>生活</category>
      </categories>
      <tags>
        <tag>课程评价</tag>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title>css中表格样式</title>
    <url>/2022/10/12/%E8%A1%A8%E6%A0%BC%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h1 id="表格布局"><a href="#表格布局" class="headerlink" title="表格布局"></a>表格布局</h1><h3 id="表格格式化"><a href="#表格格式化" class="headerlink" title="表格格式化"></a>表格格式化</h3>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>未完成（鸽）</tag>
      </tags>
  </entry>
  <entry>
    <title>css中的过渡</title>
    <url>/2022/10/12/%E8%BF%87%E6%B8%A1/</url>
    <content><![CDATA[<h1 id="过渡"><a href="#过渡" class="headerlink" title="过渡"></a>过渡</h1><h2 id="定义过渡属性"><a href="#定义过渡属性" class="headerlink" title="定义过渡属性"></a>定义过渡属性</h2><p>CSS中使用四个属性定义过渡</p>
<p><code>transition-property</code></p>
<p><code>transition-duration</code></p>
<p><code>transition-timing-function</code></p>
<p><code>transition-delay</code></p>
<p>以及简写属性<code>transition</code></p>
<p>与过渡相关的属性加在非悬停状态上可以使开始和结束状态都实现过渡</p>
<p>而加在悬停状态上只会使开始时实现过渡，结束时瞬时切换</p>
<h3 id="设置使用过渡的属性transition-property"><a href="#设置使用过渡的属性transition-property" class="headerlink" title="设置使用过渡的属性transition-property"></a>设置使用过渡的属性<code>transition-property</code></h3><p>属性的值是以逗号分隔的属性列表，指使用过渡的属性</p>
<p>默认值为all，即所有支持动画的属性都采用过渡</p>
<p>不支持动画的属性会立即变为过渡后的值</p>
<p>如果需要对某些例外属性单独设置，应该把all设在首位，然后声明例外的属性如：</p>
<p><code>transition:all,color;  transition-duration:1s,2s;</code></p>
<p>值为none时禁用所有过渡，如果想禁用部分只能单独列出其他所有元素</p>
<h3 id="设置过渡持续时间transition-duration"><a href="#设置过渡持续时间transition-duration" class="headerlink" title="设置过渡持续时间transition-duration"></a>设置过渡持续时间<code>transition-duration</code></h3><p>值是以逗号分隔的长度列表，单位为s或ms，指定从一个状态过渡到另一个状态需要多久</p>
<p>如果在两个状态间来回切换但只设置了一个时间，则那么这个时间只在向那个状态过渡时起作用</p>
<p>即使值为零也要写成0s</p>
<p>如果设置的<code>transition-delay</code>时长不为正数，<code>transition-duration</code>又没有声明，不会触发<code>transitionend</code>事件，只要过渡总时间大于0s，就会触发<code>transitionend</code>事件</p>
<p>如果列表中有一个时间为负数，整个<code>transition-duration</code>属性都会失效</p>
<p>如果时间列表中时间数量与属性数量不一致，按照浏览器的规则处理</p>
<p>如果时间数多于属性数，忽略后面的属性</p>
<p>如果时间数少于属性数且恰好为2个，奇数属性使用第一个，偶数属性使用第二个</p>
<p>100ms到200ms的时间最佳</p>
<h3 id="调整过渡的内部时序transition-timing-function"><a href="#调整过渡的内部时序transition-timing-function" class="headerlink" title="调整过渡的内部时序transition-timing-function"></a>调整过渡的内部时序<code>transition-timing-function</code></h3><p>可以取的值有<code>ease,linear,ease-in,ease-out,ease-in-out,step-start,step-end,steps(n,start)(n是步进的次数),step(n,end),cubic-bezier(x1,y1,x2,y2)</code></p>
<h4 id="通过三次方贝塞尔函数定义"><a href="#通过三次方贝塞尔函数定义" class="headerlink" title="通过三次方贝塞尔函数定义"></a>通过三次方贝塞尔函数定义</h4><p><code>ease</code>慢速开始，中间很快，然后变慢，结尾特别慢</p>
<p><code>linear</code>整个过程匀速</p>
<p><code>ease-in</code>慢速开始，然后加速</p>
<p><code>ease-out</code>快速开始，然后慢速</p>
<p><code>ease-in-out</code>于ease类似，两端慢中间快，但两端不同速</p>
<p><code>cubic-bezier(x1,y1,x2,y2)</code>定义一个三次方贝塞尔函数</p>
<h4 id="通过步进时序函数定义"><a href="#通过步进时序函数定义" class="headerlink" title="通过步进时序函数定义"></a>通过步进时序函数定义</h4><p><code>step-start</code>整个过程都处于最终关键帧上，等同于<code>steps(1,start)</code></p>
<p><code>step-end</code>整个过渡都在初始关键帧上，等同于<code>steps(1,end)</code></p>
<p><code>steps(n,start)</code></p>
<p><code>step(n,end)</code></p>
<p>这两个函数可以显示固定的镜头数</p>
<p>使用<code>transition-timing-function</code>不改变过渡的持续时间，只控制过渡的行进节奏</p>
<h3 id="延时过渡transition-delay"><a href="#延时过渡transition-delay" class="headerlink" title="延时过渡transition-delay"></a>延时过渡<code>transition-delay</code></h3><p>该属性在元素上发生触发过渡的变化与开始过渡之间引入一定的延迟</p>
<p>默认是0s，即无延迟</p>
<p>值也可以为负数</p>
<p>设置延迟可以防止误操作</p>
<h5 id="值为负数"><a href="#值为负数" class="headerlink" title="值为负数"></a>值为负数</h5><p>如果值为负数，则会从中间某个位置立即过渡</p>
<p>如：让元素x移动200像素，<code>transition-duration</code>设置为200ms,<code>transition-delay</code>设置为-150ms，那么元素x将立即移动150px，再过渡运动到200px</p>
<p>从悬停状态回到初始状态时，默认还会使用相同的delay值，所以x会立即反向运动150px，再过渡回到原点</p>
<h3 id="transition简写"><a href="#transition简写" class="headerlink" title="transition简写"></a><code>transition</code>简写</h3><p>可以同时书写四个属性</p>
<p>如果没有声明<code>transition-timing-function</code>默认为ease</p>
<p>要注意<code>transition-duration</code>和<code>transition-delay</code>的顺序，前面的是<code>duration</code>,后面的是<code>delay</code></p>
<p>持续时间必须设置，否则过渡不可见</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>js数据结构：链表</title>
    <url>/2022/10/12/%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>​	链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的。每个 元素由一个存储元素本身的节点和一个指向下一个元素的引用（也称指针或链接）组成。</p>
<p>​	相对于传统的数组，链表的一个好处在于，添加或移除元素的时候不需要移动其他元素。然 而，链表需要使用指针，因此实现链表时需要额外注意。在数组中，我们可以直接访问任何位置 的任何元素，而要想访问链表中间的一个元素，则需要从起点（表头）开始迭代链表直到找到所 需的元素</p>
<p>​	想实现最简单的链表数据结构，首先我们需要引入节点类</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">Node</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;./Link-list-model.js&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;defaultEquals&#125; <span class="keyword">from</span> <span class="string">&quot;./until.js&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><code>Node</code>类在<code>Link-list-model.js</code>中的定义如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">element</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">element</span>=element;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">next</span>=<span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;<span class="title class_">Node</span>&#125;</span><br></pre></td></tr></table></figure>

<p>其中节点类包含成分和所指的下一个节点</p>
<p><code>defaultEquals</code>是定义的默认比较函数，用于比较两元素是否相等</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">defaultEquals</span>(<span class="params">a,b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a===b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;defaultEquals&#125;</span><br></pre></td></tr></table></figure>

<p>引入它们后，就可以编写链表类了</p>
<h4 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h4><p>单向链表是最简单的链表结构，其构造函数如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params">equalsFn=defaultEquals</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">count</span>=<span class="number">0</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">head</span>=<span class="literal">undefined</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">equalsFn</span>=equalsFn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到单向链表的骨架包含一个头节点<code>head</code>，统计链表长度的计数器<code>count</code>和一个比较元素是否相等的<code>equalsFn</code>方法</p>
<p>现在可以给它添加其他方法了</p>
<ul>
<li><p>向链表中插入节点</p>
<p>向链表中插入节点默认在尾部，逻辑大致为：如果链表没有头节点就设为头节点，如果有头节点就遍历到链表尾部插入，方法是将尾部节点的<code>next</code>属性设置为要插入的节点，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">push</span>(<span class="params">element</span>) &#123;<span class="comment">//向链表中插入节点</span></span><br><span class="line">  <span class="keyword">const</span> node=<span class="keyword">new</span> <span class="title class_">Node</span>(element);</span><br><span class="line">  <span class="keyword">let</span> currentNode;<span class="comment">//当前节点</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">head</span>===<span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">head</span>=node;<span class="comment">//没有节点就设为头节点</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    currentNode=<span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">    <span class="keyword">while</span>(currentNode.<span class="property">next</span>!==<span class="literal">undefined</span>) &#123;</span><br><span class="line">      currentNode=currentNode.<span class="property">next</span>;<span class="comment">//遍历链表找到尾部</span></span><br><span class="line">    &#125;</span><br><span class="line">    currentNode.<span class="property">next</span>=node;<span class="comment">//在尾部插入节点</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">count</span>++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查找指定位置的节点</p>
<p>逻辑大致为遍历链表的同时计数，直至所计数与需要的位置index相同，代码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">getElementAt</span>(<span class="params">index</span>) &#123;<span class="comment">//查找指定位置的节点</span></span><br><span class="line">  <span class="keyword">if</span>(index&gt;=<span class="number">0</span>&amp;&amp;index&lt;=<span class="variable language_">this</span>.<span class="property">count</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> currentNode=<span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;index&amp;&amp;currentNode!==<span class="literal">undefined</span>;i++) &#123;</span><br><span class="line">      currentNode=currentNode.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> currentNode;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这也是一个链表中的工具方法，会在其他方法中复用</p>
</li>
<li><p>从指定位置删除节点</p>
<p>逻辑是如果传入index对应头节点就改变头节点，如果不是就获取指定位置的节点和它的前一个节点，将前一个节点的next指向指定位置的后一个节点，孤立的节点会被js垃圾回收机制回收</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">removeAt</span>(<span class="params">index</span>) &#123;<span class="comment">//从指定位置删除元素</span></span><br><span class="line">  <span class="keyword">if</span>(index &gt;= <span class="number">0</span> &amp;&amp; index &lt; <span class="variable language_">this</span>.<span class="property">count</span>) &#123;<span class="comment">//检验是否越界</span></span><br><span class="line">    <span class="keyword">let</span> currentNode=<span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">    <span class="keyword">if</span>(index===<span class="number">0</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">head</span>=currentNode.<span class="property">next</span>;<span class="comment">//从头节点的下一个设为头节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> previousNode=<span class="variable language_">this</span>.<span class="title function_">getElementAt</span>(index-<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">let</span> currentNode=previousNode.<span class="property">next</span>;</span><br><span class="line">      previousNode.<span class="property">next</span>=currentNode.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span>--;</span><br><span class="line">    <span class="keyword">return</span> currentNode.<span class="property">element</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在指定位置插入元素</p>
<p>逻辑大致为如果是头节点就改变头节点，如果不是就获取指定位置的节点和前一个节点，前一个节点的next设置为待插入节点，待插入节点的next设置为指定位置的节点</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">insert</span>(<span class="params">index,element</span>) &#123;<span class="comment">//在指定位置插入元素</span></span><br><span class="line">  <span class="keyword">if</span>(index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= <span class="variable language_">this</span>.<span class="property">count</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> node=<span class="keyword">new</span> <span class="title class_">Node</span>(element);</span><br><span class="line">    <span class="keyword">let</span> currentNode=<span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">    <span class="keyword">if</span>(index===<span class="number">0</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">head</span>=node;</span><br><span class="line">      node.<span class="property">next</span>=currentNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> previousNode=<span class="variable language_">this</span>.<span class="title function_">getElementAt</span>(index-<span class="number">1</span>);</span><br><span class="line">      currentNode=previousNode.<span class="property">next</span>;</span><br><span class="line">      previousNode.<span class="property">next</span>=node;</span><br><span class="line">      node.<span class="property">next</span>=currentNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span>++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据值返回某个节点的位置</p>
<p>逻辑是遍历链表，计数，依次比较值然后返回位置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">indexOf</span>(<span class="params">element</span>) &#123;<span class="comment">//根据值返回某个元素的位置</span></span><br><span class="line">  <span class="keyword">let</span> currentNode=<span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;<span class="variable language_">this</span>.<span class="property">count</span>&amp;&amp;currentNode!==<span class="literal">undefined</span>;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">equalsFn</span>(currentNode.<span class="property">element</span>,element)) &#123;</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    currentNode=currentNode.<span class="property">next</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据值删除节点</p>
<p>逻辑是先用<code>indexOf</code>方法获取index，在用<code>removeAt</code>删除</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">remove</span>(<span class="params">element</span>)&#123;<span class="comment">//根据值删除节点</span></span><br><span class="line">  <span class="keyword">const</span> index=<span class="variable language_">this</span>.<span class="title function_">indexOf</span>(element);</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">removeAt</span>(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取链表长度</p>
<p>直接返回count即可</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">size</span>(<span class="params"></span>) &#123;<span class="comment">//返回链表长度</span></span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">count</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断链表是否为空</p>
<p>即判断count是否为0</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;<span class="comment">//判断链表是否为空</span></span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">count</span>===<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取头节点</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">getHead</span>(<span class="params"></span>) &#123;<span class="comment">//返回头节点</span></span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串化</p>
<p>重写<code>toString</code>方法，依次拼接</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> objString=<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.head.element&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">let</span> currentNode=<span class="variable language_">this</span>.<span class="property">head</span>.<span class="property">next</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;<span class="variable language_">this</span>.<span class="title function_">size</span>()&amp;&amp;currentNode!==<span class="literal">undefined</span>;i++) &#123;</span><br><span class="line">      objString=<span class="string">`<span class="subst">$&#123;objString&#125;</span>,<span class="subst">$&#123;currentNode.element&#125;</span>`</span>;</span><br><span class="line">      currentNode=currentNode.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> objString;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>将方法结合到一起得到单向链表的类声明</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedList</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">equalsFn=defaultEquals</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span>=<span class="number">0</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">head</span>=<span class="literal">undefined</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">equalsFn</span>=equalsFn;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">push</span>(<span class="params">element</span>) &#123;<span class="comment">//向链表中插入节点</span></span><br><span class="line">    <span class="keyword">const</span> node=<span class="keyword">new</span> <span class="title class_">Node</span>(element);</span><br><span class="line">    <span class="keyword">let</span> currentNode;<span class="comment">//当前节点</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">head</span>===<span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">head</span>=node;<span class="comment">//没有节点就设为头节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      currentNode=<span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">      <span class="keyword">while</span>(currentNode.<span class="property">next</span>!==<span class="literal">undefined</span>) &#123;</span><br><span class="line">        currentNode=currentNode.<span class="property">next</span>;<span class="comment">//遍历链表找到尾部</span></span><br><span class="line">      &#125;</span><br><span class="line">      currentNode.<span class="property">next</span>=node;<span class="comment">//在尾部插入节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span>++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">removeAt</span>(<span class="params">index</span>) &#123;<span class="comment">//从指定位置删除元素</span></span><br><span class="line">    <span class="keyword">if</span>(index &gt;= <span class="number">0</span> &amp;&amp; index &lt; <span class="variable language_">this</span>.<span class="property">count</span>) &#123;<span class="comment">//检验是否越界</span></span><br><span class="line">      <span class="keyword">let</span> currentNode=<span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">      <span class="keyword">if</span>(index===<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">head</span>=currentNode.<span class="property">next</span>;<span class="comment">//从头节点的下一个设为头节点</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> previousNode=<span class="variable language_">this</span>.<span class="title function_">getElementAt</span>(index-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">let</span> currentNode=previousNode.<span class="property">next</span>;</span><br><span class="line">        previousNode.<span class="property">next</span>=currentNode.<span class="property">next</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">count</span>--;</span><br><span class="line">      <span class="keyword">return</span> currentNode.<span class="property">element</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getElementAt</span>(<span class="params">index</span>) &#123;<span class="comment">//查找指定位置的节点</span></span><br><span class="line">    <span class="keyword">if</span>(index&gt;=<span class="number">0</span>&amp;&amp;index&lt;=<span class="variable language_">this</span>.<span class="property">count</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> currentNode=<span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;index&amp;&amp;currentNode!==<span class="literal">undefined</span>;i++) &#123;</span><br><span class="line">        currentNode=currentNode.<span class="property">next</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> currentNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">insert</span>(<span class="params">index,element</span>) &#123;<span class="comment">//在指定位置插入元素</span></span><br><span class="line">    <span class="keyword">if</span>(index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= <span class="variable language_">this</span>.<span class="property">count</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> node=<span class="keyword">new</span> <span class="title class_">Node</span>(element);</span><br><span class="line">      <span class="keyword">let</span> currentNode=<span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">      <span class="keyword">if</span>(index===<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">head</span>=node;</span><br><span class="line">        node.<span class="property">next</span>=currentNode;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> previousNode=<span class="variable language_">this</span>.<span class="title function_">getElementAt</span>(index-<span class="number">1</span>);</span><br><span class="line">        currentNode=previousNode.<span class="property">next</span>;</span><br><span class="line">        previousNode.<span class="property">next</span>=node;</span><br><span class="line">        node.<span class="property">next</span>=currentNode;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">count</span>++;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">indexOf</span>(<span class="params">element</span>) &#123;<span class="comment">//根据值返回某个元素的位置</span></span><br><span class="line">    <span class="keyword">let</span> currentNode=<span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;<span class="variable language_">this</span>.<span class="property">count</span>&amp;&amp;currentNode!==<span class="literal">undefined</span>;i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">equalsFn</span>(currentNode.<span class="property">element</span>,element)) &#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">      &#125;</span><br><span class="line">      currentNode=currentNode.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">remove</span>(<span class="params">element</span>)&#123;<span class="comment">//根据值删除节点</span></span><br><span class="line">    <span class="keyword">const</span> index=<span class="variable language_">this</span>.<span class="title function_">indexOf</span>(element);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">removeAt</span>(index);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">size</span>(<span class="params"></span>) &#123;<span class="comment">//返回链表长度</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">count</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;<span class="comment">//判断链表是否为空</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">count</span>===<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getHead</span>(<span class="params"></span>) &#123;<span class="comment">//返回头节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> objString=<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.head.element&#125;</span>`</span>;</span><br><span class="line">      <span class="keyword">let</span> currentNode=<span class="variable language_">this</span>.<span class="property">head</span>.<span class="property">next</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;<span class="variable language_">this</span>.<span class="title function_">size</span>()&amp;&amp;currentNode!==<span class="literal">undefined</span>;i++) &#123;</span><br><span class="line">        objString=<span class="string">`<span class="subst">$&#123;objString&#125;</span>,<span class="subst">$&#123;currentNode.element&#125;</span>`</span>;</span><br><span class="line">        currentNode=currentNode.<span class="property">next</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> objString;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><p>双向链表和普通链表的区别在于，在链表中， 一个节点只有链向下一个节点的链接；而在双向链表中，链接是双向的：一个链向下一个元素， 另一个链向前一个元素</p>
<p>那么首先要更新Node类，它应该包含一个属性指向前一个节点</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DoubleNode</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Node</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">element,next,prev</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(element,next);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">prev</span>=prev;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>super</code>方法可以继承对element和next的声明</p>
<p>然后需要对原有的链表类拓展</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params">equalsFn=defaultEquals</span>) &#123;</span><br><span class="line">  <span class="variable language_">super</span>(equalsFn);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">tail</span>=<span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>增加一个尾部节点，让链表可以从尾部遍历</p>
<ul>
<li><p>重写insert方法</p>
<p>重写从指定位置插入，除了要增加对prev属性的处理外还要增加一种情况，即在链表尾部插入，要改变链表的tail属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">insert</span>(<span class="params">index, element</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(index&gt;=<span class="number">0</span>&amp;&amp;index&lt;=<span class="variable language_">this</span>.<span class="property">count</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> node=<span class="keyword">new</span> <span class="title class_">DoubleNode</span>(element);</span><br><span class="line">    <span class="keyword">let</span> currentNode=<span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">    <span class="keyword">if</span>(index===<span class="number">0</span>) &#123;<span class="comment">//头部插入</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">head</span>===<span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">head</span>=node;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">tail</span>=node;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node.<span class="property">next</span>=<span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">head</span>.<span class="property">prev</span>=node;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">head</span>=node;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(index===<span class="variable language_">this</span>.<span class="property">count</span>) &#123;<span class="comment">//尾部插入</span></span><br><span class="line">      currentNode=<span class="variable language_">this</span>.<span class="property">tail</span>;</span><br><span class="line">      currentNode.<span class="property">next</span>=node;</span><br><span class="line">      node.<span class="property">prev</span>=currentNode;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">tail</span>=node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> previousNode=<span class="variable language_">this</span>.<span class="title function_">getElementAt</span>(index-<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">let</span> currentNode=previousNode.<span class="property">next</span>;</span><br><span class="line">      previousNode.<span class="property">next</span>=node;</span><br><span class="line">      node.<span class="property">prev</span>=previousNode;</span><br><span class="line">      node.<span class="property">next</span>=currentNode;</span><br><span class="line">      currentNode.<span class="property">prev</span>=node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span>++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重写removeAt方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">removeAt</span>(<span class="params">index</span>) &#123;<span class="comment">//从指定位置删除</span></span><br><span class="line">  <span class="keyword">if</span>(index&gt;=<span class="number">0</span>&amp;&amp;index&lt;<span class="variable language_">this</span>.<span class="property">count</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> currentNode=<span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">    <span class="keyword">if</span>(index===<span class="number">0</span>) &#123;<span class="comment">//在头部删除</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">head</span>=currentNode.<span class="property">next</span>;</span><br><span class="line">      <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">count</span>===<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">tail</span>=<span class="literal">undefined</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">head</span>.<span class="property">prev</span>=<span class="literal">undefined</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(index===<span class="variable language_">this</span>.<span class="property">count</span>-<span class="number">1</span>) &#123;<span class="comment">//在尾部删除</span></span><br><span class="line">      currentNode=<span class="variable language_">this</span>.<span class="property">tail</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">tail</span>=currentNode.<span class="property">prev</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">tail</span>.<span class="property">next</span>=<span class="literal">undefined</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> previousNode=<span class="variable language_">this</span>.<span class="title function_">getElementAt</span>(index-<span class="number">1</span>);</span><br><span class="line">      currentNode=previousNode.<span class="property">next</span>;</span><br><span class="line">      previousNode.<span class="property">next</span>=currentNode.<span class="property">next</span>;</span><br><span class="line">      currentNode.<span class="property">next</span>.<span class="property">prev</span>=previousNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span>--;</span><br><span class="line">    <span class="keyword">return</span> currentNode.<span class="property">element</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>双向链表的其他部分也要重写，这里不展开</p>
<h4 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h4><p>循环链表就是首尾相连的链表</p>
<p>无需对节点类和链表类拓展，直接继承即可</p>
<ul>
<li><p>重写insert方法</p>
<p>需要注意在头节点和尾节点插入时需要改变首尾相连</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">insert</span>(<span class="params">index, element</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> node=<span class="keyword">new</span> <span class="title class_">Node</span>(element);</span><br><span class="line">  <span class="keyword">let</span> currentNode=<span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">  <span class="keyword">if</span>(index&gt;=<span class="number">0</span>&amp;&amp;index&lt;=<span class="variable language_">this</span>.<span class="property">count</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(index===<span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(currentNode===<span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">head</span>=node;</span><br><span class="line">        node.<span class="property">next</span>=<span class="variable language_">this</span>.<span class="property">head</span>;<span class="comment">//首尾相连</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">head</span>=node;</span><br><span class="line">        node.<span class="property">next</span>=currentNode;</span><br><span class="line">        currentNode=<span class="variable language_">this</span>.<span class="title function_">getElementAt</span>(<span class="variable language_">this</span>.<span class="title function_">size</span>()-<span class="number">1</span>);</span><br><span class="line">        currentNode.<span class="property">next</span>=node;<span class="comment">//首尾相连</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> previousNode=<span class="variable language_">this</span>.<span class="title function_">getElementAt</span>(index-<span class="number">1</span>);</span><br><span class="line">      currentNode=previousNode.<span class="property">next</span>;</span><br><span class="line">      previousNode.<span class="property">next</span>=node;</span><br><span class="line">      node.<span class="property">next</span>=currentNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span>++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重写removeAt方法</p>
<p>同样注意首尾相连</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">removeAt</span>(<span class="params">index</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> currentNode;</span><br><span class="line">  <span class="keyword">if</span>(index&gt;=<span class="number">0</span>&amp;&amp;index&lt;<span class="variable language_">this</span>.<span class="property">count</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(index===<span class="number">0</span>) &#123;<span class="comment">//删除头部</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">size</span>()===<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">head</span>=<span class="literal">undefined</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> removed=<span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">        currentNode=<span class="variable language_">this</span>.<span class="title function_">getElementAt</span>(<span class="variable language_">this</span>.<span class="title function_">size</span>()-<span class="number">1</span>);</span><br><span class="line">        currentNode.<span class="property">next</span>=removed.<span class="property">next</span>;<span class="comment">//首尾相连</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">head</span>=removed.<span class="property">next</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> previousNode=<span class="variable language_">this</span>.<span class="title function_">getElementAt</span>(index-<span class="number">1</span>);</span><br><span class="line">      currentNode=previousNode.<span class="property">next</span>;</span><br><span class="line">      previousNode.<span class="property">next</span>=currentNode.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span>--;</span><br><span class="line">    <span class="keyword">return</span> currentNode.<span class="property">element</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>其他方法也要重写，这里不展开</p>
<h4 id="有序链表"><a href="#有序链表" class="headerlink" title="有序链表"></a>有序链表</h4><p>有序链表要求所有节点根据element保持有序性</p>
<p>为使代码更为优雅，先定义Compare对象表示比较结果</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Compare</span> = &#123;</span><br><span class="line">  <span class="attr">LESS_THAN</span>: -<span class="number">1</span>,</span><br><span class="line">  <span class="attr">BIGGER_THAN</span>: <span class="number">1</span></span><br><span class="line">&#125;;<span class="comment">//一个比较对象</span></span><br></pre></td></tr></table></figure>

<p>然后定义默认比较方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">defaultCompare</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (a === b) &#123; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a &lt; b ? <span class="title class_">Compare</span>.<span class="property">LESS_THAN</span> : <span class="title class_">Compare</span>.<span class="property">BIGGER_THAN</span>;</span><br><span class="line">&#125;<span class="comment">//默认比较方法</span></span><br></pre></td></tr></table></figure>

<p>然后声明有序链表，它与单向链表相比需要拓展比较方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params">equalsFn = defaultEquals, compareFn = defaultCompare</span>) &#123;</span><br><span class="line">  <span class="variable language_">super</span>(equalsFn);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">compareFn</span> = compareFn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>有序插入元素</p>
<p>逻辑是依次遍历链表直至找到比要插入元素大的节点，需要考虑没有节点和所有元素都比待插入元素小两种情况</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">insert</span>(<span class="params">element,index=<span class="number">0</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">super</span>.<span class="title function_">insert</span>(<span class="number">0</span>,element);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> position=<span class="variable language_">this</span>.<span class="title function_">getIndexNextSortedElement</span>(element);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">super</span>.<span class="title function_">insert</span>(position,element)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">getIndexNextSortedElement</span>(<span class="params">element</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> currentNode=<span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">  <span class="keyword">let</span> i=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(;i&lt;<span class="variable language_">this</span>.<span class="title function_">size</span>()&amp;&amp;currentNode;i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> comp=<span class="variable language_">this</span>.<span class="title function_">compareFn</span>(element,currentNode.<span class="property">element</span>);</span><br><span class="line">    <span class="keyword">if</span>(comp===<span class="title class_">Compare</span>.<span class="property">LESS_THAN</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> i;<span class="comment">//如果发现比后一个元素小就返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    currentNode=currentNode.<span class="property">next</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i;<span class="comment">//比所有元素都大就放在最后</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>还需要重写其他方法，这里不展开</p>
<h4 id="使用链表创建栈"><a href="#使用链表创建栈" class="headerlink" title="使用链表创建栈"></a>使用链表创建栈</h4><p>在栈的实现内部使用链表 数据结构会更加简单，因为不需要重新创建这些代码，也使代码的可读性更好。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StackLinkedList</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span>=<span class="keyword">new</span> <span class="title class_">DoubleLinkedList</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">push</span>(<span class="params">element</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">push</span>(element);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">pop</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">removeAt</span>(<span class="variable language_">this</span>.<span class="title function_">size</span>()-<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">isEmpty</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>.<span class="property">count</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">peek</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>.<span class="property">tail</span>.<span class="property">element</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">clear</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">clear</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">toString</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>数据结构</tag>
        <tag>栈</tag>
        <tag>链表</tag>
        <tag>双向链表</tag>
        <tag>单向链表</tag>
        <tag>循环链表</tag>
        <tag>有序链表</tag>
      </tags>
  </entry>
  <entry>
    <title>软件综合实践</title>
    <url>/2022/12/22/%E8%BD%AF%E4%BB%B6%E7%BB%BC%E5%90%88%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h3 id="软件综合实践"><a href="#软件综合实践" class="headerlink" title="软件综合实践"></a>软件综合实践</h3><p>这篇文章是对学院课程《软件综合实践》的学习整理，主要是编译原理的部分过程学习（编译前端）</p>
<p>省略了第一章的内容</p>
<h4 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h4><p>词法分析过程将源程序文件是做一个字符型文本文件并读取字符，将其分为若干个记号（token）。每个token都是表示源程序中信息单元的字符序列，如关键字（keyword），标识符（identifier），特殊符号（special symbol）等。token表示扫描程序从剩余字符串开头识别或匹配的某种字符格式</p>
<p>因此扫描程序的任务是格式匹配的一种。我们需要研究扫描过程中的格式说明和识别方法，其中最重要的是<strong>正则表达式</strong>和<strong>有穷自动机</strong>。扫描程序也是编译器处理源代码输入的部分，需要尽可能高校，要注意实际细节</p>
<p>我们通过以下几个部分来研究扫描程序：</p>
<ol>
<li>学习扫描程序操作的概述以及涉及到的结构和概念</li>
<li>学习正则表达式</li>
<li>学习有穷自动机（它是对正则给出的串格式的识别算法）</li>
<li>学习如何编写相关程序</li>
</ol>
<h5 id="扫描处理"><a href="#扫描处理" class="headerlink" title="扫描处理"></a>扫描处理</h5><p>扫描处理的任务是读取源程序代码字符并生成token，token就是编译器之后部分（通常是分析程序）处理的逻辑单元。扫描处理类似于在一个英文语句中将字母拼成一个个单词的处理</p>
<p>token在c中常被定义成枚举类型，如</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    IF, THEN, ELSE, PLUS, MINUS, NUM, ID, ...</span><br><span class="line">&#125; TokenTyoe;</span><br></pre></td></tr></table></figure>

<p>token包含若干种类型，分为保留字（如<code>IF THEN</code>），特殊符号（如<code>PLUS MINUS</code>,表示+和-），多字符串的记号（如<code>NUM ID</code>表示数字和标识符）</p>
<p>token必须和它们表示的字符串完全区分开，如<code>IF</code>和<code>if</code>要做区别。token对应的字符串可以被称作token的词义，一个token可以有一个（如保留字）或者无限多个串值（如标识符）。任何与token相关的值都可以成为token的属性（attribute），如上面的串值就是一个属性，记号也可以有其他属性，如某个<code>NUM</code>有一个”114514”的串值属性，也有代表真实值114514的数字值属性。</p>
<p>为了之后的处理，扫描程序要求至少要有与token所需相等的属性。例如如果需要计算<code>NUM</code>的串值，直接取串值即可，就不需要计算数字值了。因为扫描程序需要计算每一个token的相关属性，把若干属性收集到一个数据类型中是很有用的，这种数据类型成为记号记录（token record），如，在C中可将记号记录声明为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    TokenType tokenval;</span><br><span class="line">    <span class="type">char</span> * stringval;</span><br><span class="line">    <span class="type">int</span> numval;</span><br><span class="line">&#125; TokenRecord;<span class="comment">//假设只需要数字属性和串值属性</span></span><br></pre></td></tr></table></figure>

<p>虽然扫描程序需要将整个源程序转化为token序列，但很少会一次性完成它。实际上扫描程序是在分析程序的控制下进行操作的，它通过一个函数从输入中读取字符串并返回下一个token。在C中，可以声明一个这样的函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TokenType <span class="title function_">getToken</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>这个函数会计算如串值这样的属性，并返回下一个记号。我们并不给这个函数提供参数，实际上参数被保存在缓冲区中。</p>
<p>下面开始研究字符串中定于和识别格式的方式</p>
<h5 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h5><p>正则表达式是一种匹配模式，它表示它匹配的所有字符串的集合。</p>
<ul>
<li><p>定义</p>
<ul>
<li><p>基本正则表达式</p>
<p>它们是字母表中的单个字符且自身匹配。如<code>L(a) = &#123;a&#125;</code>用来匹配a字符。特殊情况下还需要用到其他两个字符。一个是空串，表示不包含任何字符串，用ε表示（<code>L(ε) = ε</code>），另一个是与任何串都不匹配的符号，称它为空集（{}），用符号∅表示（<code>L(∅) = &#123;&#125;</code>）;{}与{ε}的区别是前者不会匹配任何串而后者会匹配空串</p>
</li>
<li><p>运算</p>
<p>包含三种基本运算</p>
<ul>
<li><p>从各对象中选择：用|表示</p>
<p>如果r和s是正则表达式，r|s表示可以被r或被s匹配的串集</p>
</li>
<li><p>连结：不需要添加符号</p>
<p>r和s的连结可以写作rs，表示两串连结后的串集，如<code>ab</code>只匹配ab，但<code>(a|b)c</code>匹配ac或bc，<code>(a|b)(c|d)</code>则会匹配ac，ad，bc，bd</p>
</li>
<li><p>重复：用元字符*表示</p>
<p>r*表示匹配串的任意又穷连结，每个连结匹配均为r。可以理解为匹配0到n个r，如<code>(a|bb)*</code>可匹配a，bb，abb，aaa，aabba等</p>
</li>
</ul>
</li>
<li><p>优先级与括号</p>
<p>三种运算中，重复（*）优先级最高，其次是连结，最后是选择（|）。当要使用不同的优先顺序时，要加括号</p>
</li>
<li><p>给正则命名</p>
<p>为较长的正则命名可以简化书写，如要匹配给一个或多个数字，正则表达式为<code>(0|1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)*</code></p>
<p>给<code>(0|1|2|3|4|5|6|7|8|9)</code>命名为<code>digit</code>则可以简化为<code>digit digit*</code></p>
<p>但这样做也增加了复杂度，这使得正则表达式的名称变成了元字符，需要一个方法将其和普通字符串做区别，而且名字中不能含有名字，不能递归表示</p>
</li>
</ul>
</li>
<li><p>拓展</p>
<p>除了上面的三种基本运算，还可以定义一些常用的拓展新运算</p>
<ul>
<li><p>一个或多个重复</p>
<p>用+表示。<code>(0|1)+</code>&#x3D;&#x3D;<code>(0|1)(0|1)*</code></p>
</li>
<li><p>字母表中的任意字符</p>
<p>用<code>.</code>表示与任意字符匹配</p>
</li>
<li><p>字符范围</p>
<p>如果要表示一个范围的某个字符，可以用方括号和连字符表示。如<code>[a-z]</code>表示小写字母，<code>[0-9]</code>表示数字，<code>[abc]</code>表示<code>a|b|c</code>，<code>[a-zA-Z]</code>表示大小写字母表</p>
</li>
<li><p>不在给定范围内的字符</p>
<p>用<del>表示非。如&#96;</del>(a|b|c)&#96;表示abc以外的字符。</p>
</li>
<li><p>可选的字符</p>
<p>用?表示某字符是可选的，如<code>(+?)[0-9]</code>表示数字前的加号是可选的</p>
</li>
</ul>
</li>
<li><p>token的正则表达式</p>
<p>这里先简单讨论一下token的典型正则</p>
<ul>
<li><p>数</p>
<p>这里的数包括自然数，十进制数，带指数（e&#x2F;E）的数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">nat = [<span class="number">0</span><span class="number">-9</span>]+</span><br><span class="line">signedNat = (+|-)?nat</span><br><span class="line">number = signedNat(.nat)?(EsignedNat)?</span><br></pre></td></tr></table></figure>
</li>
<li><p>保留字</p>
<p>保留字（关键字）是固定的，用|选择即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">reserved = <span class="keyword">if</span>|<span class="keyword">while</span>|<span class="keyword">do</span>|<span class="keyword">for</span>...</span><br></pre></td></tr></table></figure>
</li>
<li><p>标识符</p>
<p>一般来说标识符以字母开头并且只包含数字和字母</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">letter = [a-zA-Z]</span><br><span class="line">digit = [<span class="number">0</span><span class="number">-9</span>]</span><br><span class="line">identifier = letter(letter|digit)*</span><br></pre></td></tr></table></figure>
</li>
<li><p>注释</p>
<p>注释一般有两种，前后为分隔符的自由格式，或者一个或多个特殊字符开头并到这行结尾</p>
<p>到本行结尾的注释比较简单，如在c中为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//(~\n)*</span></span><br></pre></td></tr></table></figure>

<p>但当分隔符多于一个时,如<code>/* */</code>时情况就复杂的多，扫描程序往往会通过特殊办法解决。</p>
<p>在一些语言中，注释是可以嵌套的，所以这就要求正则表达式统计数量，但这是正则表达式不能实现的</p>
</li>
<li><p>二义性，空白格和先行</p>
<p>有些串可以被不同的正则表达式匹配。比如按照上面的标准，if既可以是标识符又可以是关键字。程序语言必须规定应该遵循哪个规则，但正则表达式做不到。可以做出如下处理：</p>
<p>当串既是标识符又是关键字时，取做关键字</p>
<p>当串既是单个记号又可以是若干记号的序列时，解释为单个记号。这常常被称作“最长子串原理”：可组成单个token的字符最长串在任何时候都假设为代表下一个token（这理解起来感觉很晦涩，但中文译版是这样翻译的，原文好像也是这么写的。查了一下可以理解为当字符串的一个或者多个子串可以进行匹配时取最长的子串匹配）。</p>
<p>在使用最长子串原理时会遇到记号分隔符（token delimiter）的问题。如在<code>x=y</code>中，等号将标识符x分隔，因为等号不是标识符的一部分。一般认为空格，换行，tab是记号分隔符。我们需要定义空白格伪记号（原文是这么写，可以理解为就是一种token），可以这样定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">whitespace = (newline|blank|tab|comment)+<span class="comment">//换行，空格，tab，注释</span></span><br></pre></td></tr></table></figure>

<p>但要注意空格通常不当作记号分隔符而是直接被忽略掉，有这种忽略行为的语言的扫描程序需要检查记号分隔符后舍弃空格。</p>
<p>分隔符会结束掉某个token串，但分隔符不是token的一部分。因此扫描程序必须要处理先行（lookahead）问题。（文中关于lookahead的部分描述的难懂，给出一个易懂的解释：先行问题就是有些token必须要读到它们的后一位才能判断是否结束）</p>
</li>
</ul>
</li>
</ul>
<h5 id="有穷自动机"><a href="#有穷自动机" class="headerlink" title="有穷自动机"></a>有穷自动机</h5><p>有穷自动机的图形描述：用一个箭头线指向一个圆圈代表初始状态，从这个圆圈（初始状态）再引出箭头，箭头上标注字符集代表匹配条件，指向下一个状态，如此下去，直到到达最终状态（接受状态）。接受状态用一个边界为双线的圆圈表示。（参照pdf42页图2-1）。</p>
<h6 id="确定性有穷状态机"><a href="#确定性有穷状态机" class="headerlink" title="确定性有穷状态机"></a>确定性有穷状态机</h6><p>确定性有穷自动机（DFA）：下一个状态由当前状态和当前输入字符唯一给出的自动机（也就是根据当前状态和字符可以确定的到达下一个状态）。</p>
<p>数学描述比较抽象，不描述，可以参考pdfP43</p>
<h6 id="先行，回溯和非确定性自动机"><a href="#先行，回溯和非确定性自动机" class="headerlink" title="先行，回溯和非确定性自动机"></a>先行，回溯和非确定性自动机</h6><p>我们先继续学习DFA表示的精确算法。</p>
<p>注意到DFA图示只是给出了运算的要点。即使是数学公式也不能描述所有方面。比如不能描述出错时的错误是什么。</p>
<p>  举标识符的DFA为例，出错状态并不是真正的错误，而是表示该字符不能被识别（比如遇到了分隔符），此时识别应该结束，应该接受并生成token，所以对DFA做出改进，得到图2-5所示（PDFP46）。</p>
<p>  现在再考虑初始状态。若所有token都是以不同字符开头的就会比较好处理，一个初始状态加上不同的起始字符箭头即可，但实际上不是这样，如&lt;,&lt;&#x3D;就是相同起始字符的token，若按之前的表示方法表示，就不符合DFA的定义了（确定性）。一个解决方法是拓展有穷自动机的定义，让它包括对某个特定字符能存在多个转换。这种新型自动机被称为非确定性有穷自动机（NFA）。</p>
<p>  在给出NFA的定义前，先要引入ε-转换的概念。ε-转换是无需考虑和消耗任何字串就可以发生的转换。可以看作对空串的匹配。引入ε-转换的好处是能够方便的合并一些token的DFA，还能清晰的描述出空串的匹配。（具体可以看p48底部的部分）。</p>
<p>  NFA的定义与DFA很像，但需要拓展字母表（要包含ε）和拓展函数T（现在能够一对多了）的含义。具体数学定义不给出，参考p49</p>
<h6 id="代码实现有穷自动机"><a href="#代码实现有穷自动机" class="headerlink" title="代码实现有穷自动机"></a>代码实现有穷自动机</h6><p>  这里的方法并不都会用在扫描程序中，扫描程序相关的代码部分会在后面展开</p>
<p>  原文中这一节的伪代码和代码似乎都是Fortran语言的，这里用C格式表示</p>
<p>  考虑标识符的DFA,实现它最简单的方法如下（伪代码）：</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//现在处于状态1（初始状态）</span></span><br><span class="line"><span class="comment">//假设现在读到的字符为character，下一个字符为character.next</span></span><br><span class="line"><span class="keyword">if</span>(isLetter(character.next)==<span class="literal">true</span>) &#123;<span class="comment">//如果下一个字符是字母</span></span><br><span class="line">    character = character.next;<span class="comment">//这里开始向后移动输入（进入状态2）</span></span><br><span class="line">    <span class="keyword">while</span>(isDigit(character.next)||isLetter(character.next)) &#123;</span><br><span class="line">        <span class="comment">//如果下一个字符是数字或字母</span></span><br><span class="line">        character = character.next;<span class="comment">//这里向后移动输入（保持状态2）        </span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//结束循环，说明读到了分隔符，达到状态3（接受状态）</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//其他情况或错误</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>  这种方式用输入的移动来表示状态的改变。当一个DFA没有多少状态时，这样编写没什么问题。但它也有缺点。当状态增多或者路径增多时会变得很麻烦，而且每个算法都是特殊的，必须用略微不同的方法处理不同的DFA，这难以实现。</p>
<p>  另一个方法是定义一个状态变量，并把转换写进switch…case…语句中，避免出现在循环中</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//仍是上一个代码块的表述</span></span><br><span class="line"><span class="type">int</span> state = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(state == <span class="number">1</span> || state ==<span class="number">2</span>) &#123;</span><br><span class="line">   <span class="keyword">switch</span>(state) &#123;</span><br><span class="line">       <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">          <span class="comment">//原文这里还是一个switch...case...筛选character,但在c中不允许这样表示</span></span><br><span class="line">          <span class="keyword">if</span>(isLetter(character) == <span class="literal">true</span>) &#123;</span><br><span class="line">              character = character.next;</span><br><span class="line">              state = <span class="number">2</span>;<span class="comment">//进入状态2</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              state = ...；<span class="comment">//其他状态，表示错误或者其他情况</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>；</span><br><span class="line">       <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">           <span class="keyword">if</span>(isDigit(character.next)||isLetter(character.next)) &#123;</span><br><span class="line">				state = <span class="number">2</span>;</span><br><span class="line">               	character = character.next;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               state = <span class="number">3</span>;<span class="comment">//进入状态3（接受状态）</span></span><br><span class="line">           &#125;    </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(state = <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="comment">//accepted</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  除了这种方法之外，还可以将DFA表示为数据结构，写成一类代码。转换表或者二维数组就可以解决这个问题。可以参照P53内容，大意是创建一个二维数组T用来表示转换，列表示状态，行表示输入，数组元素值表示在该状态下输入该字符后转换到的状态。表中空白处的值由二维数组Advance定义，这是一个布尔类型的数组，用于判断。下面给出一段示例代码</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> state = <span class="number">1</span>;</span><br><span class="line"><span class="type">char</span> character = character.next;</span><br><span class="line"><span class="type">int</span> Accepted[<span class="number">5</span>] = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>];</span><br><span class="line"><span class="keyword">while</span>(!Accepted[state]&amp;&amp;!error[state]) &#123;</span><br><span class="line">  <span class="type">int</span> newState = T[state][<span class="type">char</span>];<span class="comment">//从T数组中读取状态</span></span><br><span class="line">  <span class="keyword">if</span>(Advance[state][<span class="type">char</span>]) &#123;<span class="comment">//空白为false,处理先行，否则为true,继续读取</span></span><br><span class="line">    character = character.next;</span><br><span class="line">  &#125;</span><br><span class="line">  state = newState;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(Accepted[state]) &#123;</span><br><span class="line">  accepted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  这种方式称为表驱动，虽然简化了代码，但表格会变得异常大，造成了很多内存上的浪费，依赖于诸如稀疏矩阵的压缩等方法进行处理。</p>
<p>  NFA的实现将在之后讲述</p>
<h5 id="从正则表达式到DFA"><a href="#从正则表达式到DFA" class="headerlink" title="从正则表达式到DFA"></a>从正则表达式到DFA</h5><p>   将正则表达式翻译成DFA最简单的方式是通过中间构造，先将正则表达式翻译成NFA,在将NFA翻译成DFA,最后将DFA转换为程序实现</p>
<ul>
<li>从正则表达式到NFA</li>
</ul>
<pre><code>这里的核心思想是使用ε-转换表示并置，选择，重复等。原书中的插图简单易懂，可以阅读P56-P58的图示理解
</code></pre>
<ul>
<li><p>从NFA到DFA</p>
<p>现在给定任意一个NFA，要把它转换为DFA，首先要做的就是消除ε-转换。消除ε-转换涉及到构造ε-闭包的操作。ε-闭包是通过ε-转换能到达的所有状态的集合。而我们要进行的，消除单个字符多重转换涉及到通过单个字符可到达的状态的集合。两个过程都要求考虑集合而不是单个状态。下面先来研究构造ε-闭包</p>
<p>原书中用一个例子表述了如何构造ε-闭包，这个例子还是通俗易懂的，参考p59</p>
<p>先构造每个状态的ε-闭包，一个集合的ε-闭包就是每个单独状态的ε-闭包的和</p>
<p>现在再来看通过给定NFA（假设用$M$表示）来构造DFA（假设称为$\overline{M}$）。我们先计算$M$的初始状态ε闭包，这就是$\overline{M}$ 的初始状态。对于这个初始状态集合S，对于输入的字符a，再计算在a上发生的装换的集合S‘，再计算S’的闭包…重复下去直到不再生成新的转换或状态。对于具体过程原书中也给出了一个通俗易懂的例子，参考P59例2.1</p>
</li>
<li><p>将DFA的状态数最小化</p>
<p>上面生成DFA的方法有一个缺点：生成的DFA可能比较复杂。扫描程序中为保证高效率，构造的DFA理论上应该是最小的。实际上，自动机理论中有一个很重要的结果：对于任何给定的DFA,都有一个含有最少量状态等价的DFA,而且这个最小状态数的DFA是唯一的，我们可以从任何指定的DFA中直接得到最小状态的DFA。</p>
<p>原书中还是举了两个例子，可以参考P62。算法的思路大致是将所有的接受状态先视作一个整体，然后对每一个字符进行讨论，若每个状态下该字符造成的转换都相同，就视为一个整体，若出现异样，就分割。通过这种从整体一次次分割来保证最少的状态数</p>
</li>
</ul>
<h5 id="TINY扫描程序的实现"><a href="#TINY扫描程序的实现" class="headerlink" title="TINY扫描程序的实现"></a>TINY扫描程序的实现</h5><p>这里就直接结合源码分析了</p>
<p>首先在<code>global.h</code>文件中用枚举类型定义了token</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> </span></span><br><span class="line"><span class="class">    /* <span class="title">book</span>-<span class="title">keeping</span> <span class="title">tokens</span> 内务记号用于标记（文件末尾<span class="title">EOF</span>和错误<span class="title">ERROR</span>）*/</span></span><br><span class="line"><span class="class">   &#123;</span>ENDFILE,ERROR,</span><br><span class="line">    <span class="comment">/* reserved words 保留字*/</span></span><br><span class="line">    IF,THEN,ELSE,END,REPEAT,UNTIL,READ,WRITE,</span><br><span class="line">    <span class="comment">/* multicharacter tokens 多字符token*/</span></span><br><span class="line">    ID,NUM,</span><br><span class="line">    <span class="comment">/* special symbols 特殊符号*/</span></span><br><span class="line">    ASSIGN,EQ,LT,PLUS,MINUS,TIMES,OVER,LPAREN,RPAREN,SEMI</span><br><span class="line">   &#125; TokenType;</span><br></pre></td></tr></table></figure>

<p>图2.8（pdfP64）给出了一个要实现的DFA图示，在<code>scan.h</code>和<code>scan.c</code>中有对应实现</p>
<p>在scan.c中，用枚举类型定义了状态，和图2.8中一致</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* states in scanner DFA */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">   &#123;</span> START,INASSIGN,INCOMMENT,INNUM,INID,DONE &#125;</span><br><span class="line">   StateType;</span><br></pre></td></tr></table></figure>

<p>在global.h中还定义了文件变量source和list，以及一个整型变量lineno，它们也在扫描程序中使用，分别表示源代码文件和输出的文件，若开启打印扫描细节时才会用作标记的行号</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在main.c中初始化</span></span><br><span class="line"><span class="keyword">extern</span> FILE* source; <span class="comment">/* source code text file */</span></span><br><span class="line"><span class="keyword">extern</span> FILE* listing; <span class="comment">/* listing output text file */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> lineno; <span class="comment">/* source line number for listing */</span></span><br></pre></td></tr></table></figure>

<p>在scan.h中定义了MAXTOKENLEN,表示token串值的最大长度，为40。在scan.c中定义了tokenString，长度最大为41,则标识符不能超过40个字符（算上空字符）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//scan.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXTOKENLEN 40</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//scan.c</span></span><br><span class="line"><span class="comment">/* lexeme of identifier or reserved word */</span></span><br><span class="line"><span class="type">char</span> tokenString[MAXTOKENLEN+<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p>scan.c中还定义了一些静态变量，他们的作用在注释里给出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* BUFLEN = length of the input buffer for</span></span><br><span class="line"><span class="comment">   source code lines */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFLEN 256<span class="comment">//定义缓冲区长度为256</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> lineBuf[BUFLEN]; <span class="comment">/* holds the current line缓冲区对应的字符串 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> linepos = <span class="number">0</span>; <span class="comment">/* current position in LineBuf在缓冲区字符串中的位置 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> bufsize = <span class="number">0</span>; <span class="comment">/* current size of buffer string缓冲区字符串的长度 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> EOF_flag = FALSE; <span class="comment">/* corrects ungetNextChar behavior on EOF文件末尾标志 */</span></span><br></pre></td></tr></table></figure>

<p>扫描程序通过<code>getNextChar</code>函数读取字符，函数的逻辑是：当前位置不在末尾时，直接返回当前位置的字符并让位置加一，当前位置若在末尾了，就利用<code>fgets</code>从source文件中更新缓冲区字符串（lineBuf），同时增加lineno,刷新linepos和bufsize。如果不能读取新的一行，就说明已经到末尾了，修改EOF_flag。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">getNextChar</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; <span class="keyword">if</span> (!(linepos &lt; bufsize))<span class="comment">//判断是否到达缓冲区字符串尾部</span></span><br><span class="line">    <span class="comment">//到了尾部，更新缓冲区</span></span><br><span class="line">  &#123; lineno++;</span><br><span class="line">   <span class="comment">//从source中读取新的一行的BUFLEN-1长度的字符串并赋值给lineBuf</span></span><br><span class="line">    <span class="keyword">if</span> (fgets(lineBuf,BUFLEN<span class="number">-1</span>,source))</span><br><span class="line">    &#123; <span class="keyword">if</span> (EchoSource) <span class="built_in">fprintf</span>(listing,<span class="string">&quot;%4d: %s&quot;</span>,lineno,lineBuf);</span><br><span class="line">      bufsize = <span class="built_in">strlen</span>(lineBuf);</span><br><span class="line">      linepos = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span> lineBuf[linepos++];<span class="comment">//更新完成后返回字符</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//读取失败，说明到了尾部</span></span><br><span class="line">    &#123; EOF_flag = TRUE;</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">//没到尾部，直接返回</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> lineBuf[linepos++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>getNextChar</code>函数读取一行的最长长度是255个字符，因此要求源码程序一行的字符数不能超过255</p>
<p>还有一个<code>ungetNextChar</code>函数，用于处理先行，当读多了的时候需要回退</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ungetNextChar</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; <span class="keyword">if</span> (!EOF_flag) linepos-- ;&#125;<span class="comment">//将位置回退一个字符</span></span><br></pre></td></tr></table></figure>

<p>然后来分析关键的getToken函数，因为这个函数比较长，其中也涉及到其他函数，先拆开来分析，最后给出完整的代码注释   </p>
<p>在最前面是对一些必要的变量的定义</p>
<p>tokenStringIndex是用于标识tokenString的当前字符所在的位置，因为改变字符串要给char数组赋值，需要一个数组下标。</p>
<p>currentToken,表示getToken函数返回的token</p>
<p>state,表示状态，初始状态是START</p>
<p>save,一个标志变量，用于标记是否要将字符存进tokenString里                                            </p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*index for storing into tokenString下标 */</span></span><br><span class="line"><span class="type">int</span> tokenStringIndex = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* holds current token to be returned表示返回的token */</span></span><br><span class="line">TokenType currentToken;</span><br><span class="line"><span class="comment">/* current state - always begins at START状态变量 */</span></span><br><span class="line">StateType state = START;</span><br><span class="line"><span class="comment">/* flag to indicate save to tokenString标志变量 */</span></span><br><span class="line"><span class="type">int</span> save;</span><br></pre></td></tr></table></figure>

<p>获取token的逻辑和之前所说的定义一个状态变量，并把转换写进switch…case…语句中的方法是类似的</p>
<p>先进入一个while循环，当状态不为结束状态时执行循环</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (state != DONE)&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>  然后从缓冲区中开始获取字符，并将save先设置成true（默认读取的字符需要存进tokenString)，接着开始switch…case区分状态</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> c = getNextChar();</span><br><span class="line">     save = TRUE;</span><br><span class="line">     <span class="keyword">switch</span> (state)&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>switch中的内容比较多，但知道原理之后可以发现都是简单的选择判断</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> START:</span><br><span class="line">         <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c))<span class="comment">//若当前字符为数字</span></span><br><span class="line">           state = INNUM;<span class="comment">//进入INNUM状态（数）</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isalpha</span>(c))<span class="comment">//若为字母</span></span><br><span class="line">           state = INID;<span class="comment">//进入ID状态（标识符）</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;:&#x27;</span>)<span class="comment">//若为:</span></span><br><span class="line">           state = INASSIGN;<span class="comment">//进入INASSIGN状态</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> ((c == <span class="string">&#x27; &#x27;</span>) || (c == <span class="string">&#x27;\t&#x27;</span>) || (c == <span class="string">&#x27;\n&#x27;</span>))<span class="comment">//若开头就是空格/tab/换行</span></span><br><span class="line">           save = FALSE;<span class="comment">//忽略</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;&#123;&#x27;</span>)<span class="comment">//若为注释符</span></span><br><span class="line">         &#123; save = FALSE;<span class="comment">//忽略</span></span><br><span class="line">           state = INCOMMENT;<span class="comment">//进入INCOMMENT状态（注释）</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span><span class="comment">//否则就是单字符的特殊字符</span></span><br><span class="line">         &#123; state = DONE;<span class="comment">//进入完成状态</span></span><br><span class="line">           <span class="keyword">switch</span> (c)<span class="comment">//根据读到字符的类型开始给token赋值</span></span><br><span class="line">           &#123; <span class="keyword">case</span> EOF:</span><br><span class="line">               save = FALSE;</span><br><span class="line">               currentToken = ENDFILE;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">             <span class="keyword">case</span> <span class="string">&#x27;=&#x27;</span>:</span><br><span class="line">               currentToken = EQ;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">             <span class="keyword">case</span> <span class="string">&#x27;&lt;&#x27;</span>:</span><br><span class="line">               currentToken = LT;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">             <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">               currentToken = PLUS;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">             <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">               currentToken = MINUS;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">             <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">               currentToken = TIMES;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">             <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">               currentToken = OVER;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">             <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">               currentToken = LPAREN;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">             <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">               currentToken = RPAREN;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">             <span class="keyword">case</span> <span class="string">&#x27;;&#x27;</span>:</span><br><span class="line">               currentToken = SEMI;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">             <span class="keyword">default</span>:</span><br><span class="line">               currentToken = ERROR;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//对INCOMMENT状态的处理</span></span><br><span class="line">       <span class="keyword">case</span> INCOMMENT:</span><br><span class="line">         save = FALSE;<span class="comment">//注释内容不保存</span></span><br><span class="line">         <span class="keyword">if</span> (c == EOF)<span class="comment">//如果注释一直到了文件末尾</span></span><br><span class="line">         &#123; state = DONE;<span class="comment">//进入结束状态</span></span><br><span class="line">           currentToken = ENDFILE;<span class="comment">//token赋值为ENDFILE</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;&#125;&#x27;</span>) state = START;<span class="comment">//读到&#125;结束注释，回到start状态（注释也是分隔符）</span></span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//对INASSIGN状态的处理</span></span><br><span class="line">       <span class="keyword">case</span> INASSIGN:</span><br><span class="line">         state = DONE;<span class="comment">//该次处理一定能判断出token类型，状态改变为结束状态</span></span><br><span class="line">         <span class="keyword">if</span> (c == <span class="string">&#x27;=&#x27;</span>)<span class="comment">//如果为：=，表示赋值</span></span><br><span class="line">           currentToken = ASSIGN;</span><br><span class="line">         <span class="keyword">else</span><span class="comment">//否则就是错误符号</span></span><br><span class="line">         &#123; <span class="comment">/* backup in the input */</span></span><br><span class="line">           ungetNextChar();<span class="comment">//读到的其他符号不能保存，回退一个字符</span></span><br><span class="line">           save = FALSE;<span class="comment">//不保存</span></span><br><span class="line">           currentToken = ERROR;<span class="comment">//为错误类型的TOKEN</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//对INNUM状态的处理</span></span><br><span class="line">       <span class="keyword">case</span> INNUM:</span><br><span class="line">         <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(c))<span class="comment">//如果读到的不是数字就结束</span></span><br><span class="line">         &#123; <span class="comment">/* backup in the input */</span></span><br><span class="line">           ungetNextChar();<span class="comment">//不储存这个非数字字符，回退</span></span><br><span class="line">           save = FALSE;<span class="comment">//不保存这个字符</span></span><br><span class="line">           state = DONE;<span class="comment">//状态更新为结束状态</span></span><br><span class="line">           currentToken = NUM;<span class="comment">//给token赋值为数</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//对INID状态的处理，和INNUM类似</span></span><br><span class="line">       <span class="keyword">case</span> INID:</span><br><span class="line">         <span class="keyword">if</span> (!<span class="built_in">isalpha</span>(c))</span><br><span class="line">         &#123; <span class="comment">/* backup in the input */</span></span><br><span class="line">           ungetNextChar();</span><br><span class="line">           save = FALSE;</span><br><span class="line">           state = DONE;</span><br><span class="line">           currentToken = ID;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//对DONE状态无需处理</span></span><br><span class="line">       <span class="keyword">case</span> DONE:</span><br><span class="line">       <span class="keyword">default</span>: <span class="comment">/* should never happen不属于上面的任何一个状态，报错 */</span></span><br><span class="line">         <span class="built_in">fprintf</span>(listing,<span class="string">&quot;Scanner Bug: state= %d\n&quot;</span>,state);</span><br><span class="line">         state = DONE;</span><br><span class="line">         currentToken = ERROR;</span><br><span class="line">         <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>switch…case…完，更改状态和token一遍之后，开始将读到的字符存入tokenString</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((save) &amp;&amp; (tokenStringIndex &lt;= MAXTOKENLEN))<span class="comment">//需要存入并且没标识符没超过上限</span></span><br><span class="line">  tokenString[tokenStringIndex++] = (<span class="type">char</span>) c;<span class="comment">//将字符存入tokenString</span></span><br></pre></td></tr></table></figure>

<p>上面并没有对DONE状态做处理，进入DONE状态后，首先需要在tokenString末尾补上\0结束，然后要考虑标识符是不是保留字</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (state == DONE)</span><br><span class="line">&#123; tokenString[tokenStringIndex] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  <span class="keyword">if</span> (currentToken == ID)</span><br><span class="line">    currentToken = reservedLookup(tokenString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里判断是否为保留字的函数为<code>reservedLookup</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> TokenType <span class="title function_">reservedLookup</span> <span class="params">(<span class="type">char</span> * s)</span></span><br><span class="line">&#123; <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;MAXRESERVED;i++)</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(s,reservedWords[i].str))</span><br><span class="line">      <span class="keyword">return</span> reservedWords[i].tok;<span class="comment">//若tokenString和保留字相等，返回该保留字作为token</span></span><br><span class="line">  <span class="keyword">return</span> ID;<span class="comment">//没有匹配成功，还是标识符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面将传入的tokenString和reservedWords比较</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span> <span class="type">char</span>* str;</span><br><span class="line">      TokenType tok;</span><br><span class="line">    &#125; reservedWords[MAXRESERVED]</span><br><span class="line">   = &#123;&#123;<span class="string">&quot;if&quot;</span>,IF&#125;,&#123;<span class="string">&quot;then&quot;</span>,THEN&#125;,&#123;<span class="string">&quot;else&quot;</span>,ELSE&#125;,&#123;<span class="string">&quot;end&quot;</span>,END&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;repeat&quot;</span>,REPEAT&#125;,&#123;<span class="string">&quot;until&quot;</span>,UNTIL&#125;,&#123;<span class="string">&quot;read&quot;</span>,READ&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;write&quot;</span>,WRITE&#125;&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>reservedWord</code>是一个结构体数组，每个结构体有str表示tokenString和tok表示对应的token，传入的tokenString和数组中每一个结构体的str比较，相同的话就返回对应token</p>
<p>getToken函数最后面还有一个if判断，传入一个全局变量（可以当作开关），为true就会打印出扫描细节</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (TraceScan) &#123;</span><br><span class="line">  <span class="built_in">fprintf</span>(listing,<span class="string">&quot;\t%d: &quot;</span>,lineno);</span><br><span class="line">  printToken(currentToken,tokenString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里用到了<code>printToken</code>函数，它定义在util.c中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printToken</span><span class="params">( TokenType token, <span class="type">const</span> <span class="type">char</span>* tokenString )</span></span><br><span class="line">&#123; <span class="keyword">switch</span> (token)</span><br><span class="line">  &#123; <span class="keyword">case</span> IF:</span><br><span class="line">    <span class="keyword">case</span> THEN:</span><br><span class="line">    <span class="keyword">case</span> ELSE:</span><br><span class="line">    <span class="keyword">case</span> END:</span><br><span class="line">    <span class="keyword">case</span> REPEAT:</span><br><span class="line">    <span class="keyword">case</span> UNTIL:</span><br><span class="line">    <span class="keyword">case</span> READ:</span><br><span class="line">    <span class="keyword">case</span> WRITE:</span><br><span class="line">      <span class="built_in">fprintf</span>(listing,</span><br><span class="line">         <span class="string">&quot;reserved word: %s\n&quot;</span>,tokenString);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ASSIGN: <span class="built_in">fprintf</span>(listing,<span class="string">&quot;:=\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LT: <span class="built_in">fprintf</span>(listing,<span class="string">&quot;&lt;\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> EQ: <span class="built_in">fprintf</span>(listing,<span class="string">&quot;=\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LPAREN: <span class="built_in">fprintf</span>(listing,<span class="string">&quot;(\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> RPAREN: <span class="built_in">fprintf</span>(listing,<span class="string">&quot;)\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SEMI: <span class="built_in">fprintf</span>(listing,<span class="string">&quot;;\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> PLUS: <span class="built_in">fprintf</span>(listing,<span class="string">&quot;+\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MINUS: <span class="built_in">fprintf</span>(listing,<span class="string">&quot;-\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> TIMES: <span class="built_in">fprintf</span>(listing,<span class="string">&quot;*\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> OVER: <span class="built_in">fprintf</span>(listing,<span class="string">&quot;/\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ENDFILE: <span class="built_in">fprintf</span>(listing,<span class="string">&quot;EOF\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> NUM:</span><br><span class="line">      <span class="built_in">fprintf</span>(listing,</span><br><span class="line">          <span class="string">&quot;NUM, val= %s\n&quot;</span>,tokenString);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ID:</span><br><span class="line">      <span class="built_in">fprintf</span>(listing,</span><br><span class="line">          <span class="string">&quot;ID, name= %s\n&quot;</span>,tokenString);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ERROR:</span><br><span class="line">      <span class="built_in">fprintf</span>(listing,</span><br><span class="line">          <span class="string">&quot;ERROR: %s\n&quot;</span>,tokenString);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">/* should never happen */</span></span><br><span class="line">      <span class="built_in">fprintf</span>(listing,<span class="string">&quot;Unknown token: %d\n&quot;</span>,token);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很简单的switch…case，根据token的不同类型打印对应内容</p>
<p>这就是scan.c的内容，可以生成单个token并返回</p>
<h5 id="用Lex自动生成扫描程序"><a href="#用Lex自动生成扫描程序" class="headerlink" title="用Lex自动生成扫描程序"></a>用Lex自动生成扫描程序</h5><p>本节依然是针对TINY语言开发扫描程序，但使用Lex扫描程序生成器生成扫描程序。</p>
<p>如果你已经安装配置好了flex的话，在lex文件夹下运行<code>flex tiny.l</code>，就可以生成一个扫描程序<code>lex.yy.c</code>，用这个去替换scan.c即可</p>
<p>Lex是一个包含了正则表达式的文本文件作为其输出的程序，此外还包括每一个表达式被匹配时采取的动作</p>
<h6 id="正则表达式的lex约定"><a href="#正则表达式的lex约定" class="headerlink" title="正则表达式的lex约定"></a>正则表达式的lex约定</h6><p>直接给出法则如下</p>
<ul>
<li>a：匹配字符a</li>
<li>“a”：即使a是元字符，也匹配字符a，对于普通字符a,也匹配</li>
<li>\a：a为元字符时，匹配字符a</li>
<li>a*：a的零次或多次重复</li>
<li>a+：a的一次或多次重复</li>
<li>a?：一个可选的a</li>
<li>a|b：a或b</li>
<li>(a)：a本身</li>
<li>[abc]：abc中的任意一个</li>
<li>[a-d]：abcd中任意一个</li>
<li>[^ab]：除了a或b外的任意一个字符</li>
<li>.：除换行外的任意一个字符</li>
<li>{xxx}：名字为xxx的正则表达式</li>
</ul>
<h6 id="Lex输入文件的格式"><a href="#Lex输入文件的格式" class="headerlink" title="Lex输入文件的格式"></a>Lex输入文件的格式</h6><p>Lex输入文件由三部分组成：定义（definition）集，规则（rule）集以及辅助程序（auxiliary routine）集或者用户程序（user routine）集。这三个部分用双百分号隔开，因此Lex输入格式如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;definition&#125;</span><br><span class="line">%%</span><br><span class="line">&#123;rules&#125;</span><br><span class="line">%%</span><br><span class="line">&#123;auxiliary routine&#125;</span><br></pre></td></tr></table></figure>

<p>直接结合<code>tiny.l</code>来看</p>
<p>先看定义集部分</p>
<p>首先包括一个用<code>%&#123;&#125;%</code>括起来的部分，这一部分可以理解为宏定义，在这一部分里写的c代码会转换到生成的<code>lex.yy.c</code>的最前面。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">%&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;globals.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;util.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;scan.h&quot;</span></span></span><br><span class="line"><span class="comment">/* lexeme of identifier or reserved word */</span></span><br><span class="line"><span class="type">char</span> tokenString[MAXTOKENLEN+<span class="number">1</span>];</span><br><span class="line">%&#125;</span><br></pre></td></tr></table></figure>

<p>然后是定义一些正则名称和表达式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">digit       [<span class="number">0</span><span class="number">-9</span>]</span><br><span class="line">number      &#123;digit&#125;+</span><br><span class="line">letter      [a-zA-Z]</span><br><span class="line">identifier  &#123;letter&#125;+</span><br><span class="line">newline     \n                                                                 </span><br><span class="line">whitespace  [ \t]+</span><br></pre></td></tr></table></figure>

<p>然后就是以双百分号分界，后面便是最重要的规则集</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;if&quot;</span>            &#123;<span class="keyword">return</span> IF;&#125;</span><br><span class="line"><span class="string">&quot;then&quot;</span>          &#123;<span class="keyword">return</span> THEN;&#125;</span><br><span class="line"><span class="string">&quot;else&quot;</span>          &#123;<span class="keyword">return</span> ELSE;&#125;</span><br><span class="line"><span class="string">&quot;end&quot;</span>           &#123;<span class="keyword">return</span> END;&#125;</span><br><span class="line"><span class="string">&quot;repeat&quot;</span>        &#123;<span class="keyword">return</span> REPEAT;&#125;</span><br><span class="line"><span class="string">&quot;until&quot;</span>         &#123;<span class="keyword">return</span> UNTIL;&#125;</span><br><span class="line"><span class="string">&quot;read&quot;</span>          &#123;<span class="keyword">return</span> READ;&#125;</span><br><span class="line"><span class="string">&quot;write&quot;</span>         &#123;<span class="keyword">return</span> WRITE;&#125;</span><br><span class="line"><span class="string">&quot;:=&quot;</span>            &#123;<span class="keyword">return</span> ASSIGN;&#125;</span><br><span class="line"><span class="string">&quot;=&quot;</span>             &#123;<span class="keyword">return</span> EQ;&#125;</span><br><span class="line"><span class="string">&quot;&lt;&quot;</span>             &#123;<span class="keyword">return</span> LT;&#125;</span><br><span class="line"><span class="string">&quot;+&quot;</span>             &#123;<span class="keyword">return</span> PLUS;&#125;</span><br><span class="line"><span class="string">&quot;-&quot;</span>             &#123;<span class="keyword">return</span> MINUS;&#125;</span><br><span class="line"><span class="string">&quot;*&quot;</span>             &#123;<span class="keyword">return</span> TIMES;&#125;</span><br><span class="line"><span class="string">&quot;/&quot;</span>             &#123;<span class="keyword">return</span> OVER;&#125;</span><br><span class="line"><span class="string">&quot;(&quot;</span>             &#123;<span class="keyword">return</span> LPAREN;&#125;</span><br><span class="line"><span class="string">&quot;)&quot;</span>             &#123;<span class="keyword">return</span> RPAREN;&#125;</span><br><span class="line"><span class="string">&quot;;&quot;</span>             &#123;<span class="keyword">return</span> SEMI;&#125;</span><br><span class="line">&#123;number&#125;        &#123;<span class="keyword">return</span> NUM;&#125;</span><br><span class="line">&#123;identifier&#125;    &#123;<span class="keyword">return</span> ID;&#125;</span><br><span class="line">&#123;newline&#125;       &#123;lineno++;&#125;</span><br><span class="line">&#123;whitespace&#125;    &#123;<span class="comment">/* skip whitespace */</span>&#125;</span><br><span class="line"><span class="string">&quot;&#123;&quot;</span>             &#123; <span class="type">char</span> c;</span><br><span class="line">                  <span class="keyword">do</span></span><br><span class="line">                  &#123; c = input();</span><br><span class="line">                    <span class="keyword">if</span> (c == EOF) <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">if</span> (c == <span class="string">&#x27;\n&#x27;</span>) lineno++;</span><br><span class="line">                  &#125; <span class="keyword">while</span> (c != <span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">.               &#123;<span class="keyword">return</span> ERROR;&#125;</span><br></pre></td></tr></table></figure>

<p>规则集的每一行都有两个部分构成：正则表达式和匹配时执行的c代码。c代码要写在大括号内（这个大括号是分隔含义，要与c的大括号区别）。</p>
<p>为了处理多义性，如标识符和保留字，lex会先进行最长字串匹配，如果最长字串匹配后仍具有多义性，按照规则集的书写顺序匹配。可以看到规则集中先写明了保留字的匹配规则，因此当读到保留字对应字段时lex会当作保留字而不是标识符匹配。</p>
<p>然后就是最后的辅助程序段，这部分的代码也会原封不动的被搬进生成的扫描程序，用于辅助运行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TokenType <span class="title function_">getToken</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; <span class="type">static</span> <span class="type">int</span> firstTime = TRUE;</span><br><span class="line">  TokenType currentToken;</span><br><span class="line">  <span class="keyword">if</span> (firstTime)</span><br><span class="line">  &#123; firstTime = FALSE;</span><br><span class="line">    lineno++;</span><br><span class="line">    yyin = source;                                                                     </span><br><span class="line">    yyout = listing;</span><br><span class="line">  &#125;</span><br><span class="line">  currentToken = yylex();</span><br><span class="line">  <span class="built_in">strncpy</span>(tokenString,yytext,MAXTOKENLEN);</span><br><span class="line">  <span class="keyword">if</span> (TraceScan) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(listing,<span class="string">&quot;\t%d: &quot;</span>,lineno);</span><br><span class="line">    printToken(currentToken,tokenString);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> currentToken;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体逻辑不再解释，理解文件结构即可。</p>
<p>原书词法分析的部分到此为止，下面开始讲解语法分析</p>
<h4 id="上下文无关语法及分析"><a href="#上下文无关语法及分析" class="headerlink" title="上下文无关语法及分析"></a>上下文无关语法及分析</h4><p>分析的任务是确定程序的语法，因此这个过程又被称为语法分析。程序设计语言的语法通常是由上下文无关的文法规则给出。在学习分析算法和如何利用算法之前要先学习上下文无关文法的理论。分析按照构造语法树的方式可分为两种算法：自顶向下分析和自底向上分析，在后续会提到这两种方法。</p>
<h5 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h5><p>分析程序的任务是从由扫描程序产生的token中确定程序的语法结构，隐式或显式的构造出能表示该结构的分析树和语法树。可以将分析程序看成一个函数，它接收扫描程序产生的token作为输入并生成语法树作为输出。分析步骤可减为对分析程序的调用:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">syntaxTree = parse();</span><br></pre></td></tr></table></figure>

<p> 对于单遍编译来说，分析程序中包含了所有的其他阶段，不需要显示的构造语法树了，而多遍编译会将语法树作为输入。</p>
<h5 id="上下文无关文法"><a href="#上下文无关文法" class="headerlink" title="上下文无关文法"></a>上下文无关文法</h5><p>上下文无关文法用于说明程序设计语言的语法结构。这种说明方式除了涉及到递归之外，和使用正则表达式的词法结构十分相似。</p>
<h6 id="与正则表达式比较"><a href="#与正则表达式比较" class="headerlink" title="与正则表达式比较"></a>与正则表达式比较</h6><p>基本正则表达式有3中运算：选择（|），并置，重复（*），以及命名用等号。</p>
<p>文法规则使用相似的表示法：|还是表示选择，并置也仍然存在，但是不存在重复了。另外，命名使用了箭头→而不是等号&#x3D;，这是因为现在的名字涉及到了更加复杂的定义过程，这是由定义的递归本质决定的，如下面这个例子</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exp</span> → <span class="built_in">exp</span> op <span class="built_in">exp</span>|(<span class="built_in">exp</span>)|number</span><br><span class="line">op → +|-|*</span><br></pre></td></tr></table></figure>

<p>这里涉及了一个表达式的文法，exp的规则就是递归的。</p>
<p>文法规则还将正则表达式作为部件，如在exp规则中使用了number。这个例子中使用的文法格式通常被称为BNF文法（Back-Naur form）</p>
<h6 id="上下文无关文法规则的说明"><a href="#上下文无关文法规则的说明" class="headerlink" title="上下文无关文法规则的说明"></a>上下文无关文法规则的说明</h6><p>与正则表达式类似，文法规则也定义在一个字母表或符号集之上。在正则中，这些符号一般就是指字符，而在文法规则中，符号通常指的是表示字符串的记号，这里的记号就是一个固定的符号，对于能表示多个字符串的标识符和数字记号来说，用斜体表示。如将TINY语言的记号字母表表示为集合：</p>
<p>{if, then, else, end, repeat, until, read, write, <em>identify</em>, <em>number</em>, +, -, *, &#x2F;, &#x3D;, &lt;, (, ), ;, :&#x3D;}</p>
<p>假设有一个字母表，BNF的上下文无关文法规则是由符号串组成。第一个符号是结构名字，第二个符号是元字符→，这个符号之后是一个符号串，串中每个符号都是字母表中的符号（一个结构的名字）或者元字符|</p>
<p>当然这并没有统一的标准，例如代替→的字符通常有&#x3D;、:、::&#x3D;， 代替斜体的方法使用尖括号括住名字，将斜体换为大写。使用不同的惯例，写出来的文法规则也不一样</p>
<p>BNF中还会经常使用到括号划分优先级，区分括号与元字符括号的方法是在括号两边加上引号（”(“）</p>
<p>由于括号里面的内容可以定义成新的规则（如将<code>(+|-|*)</code>定义成<code>op</code>），括号其实并不是不可或缺，如果规定左边的相同名字可以出现无数次的话，|也不是不可或缺，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exp → exp op exp</span><br><span class="line">exp → (exp)</span><br><span class="line">exp → number</span><br></pre></td></tr></table></figure>

<p>然而通常并不这么做，还是将所有选择放在一个规则里表示</p>
<h6 id="推导及由文法定义的语言"><a href="#推导及由文法定义的语言" class="headerlink" title="推导及由文法定义的语言"></a>推导及由文法定义的语言</h6><p>如现在给出一个表达式：<code>(34 - 3)*42</code></p>
<p>则他与含有七个记号的串对应：<code>(number - number)*number</code></p>
<p>其中number记号是一个正规的表达式，他与<code>exp → number</code>对应</p>
<p>文法规则通过推导确定记号符号的正规串。推导是指在文法规则的右边进行选择并替换，举个例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exp =&gt; exp op exp</span><br><span class="line">	=&gt; exp op number</span><br><span class="line">	=&gt; exp * number</span><br><span class="line">	=&gt; (exp) * number</span><br><span class="line">	=&gt; (exp op exp)* number</span><br><span class="line">	=&gt; (exp op number) * number</span><br><span class="line">	=&gt; (exp - number) * number</span><br><span class="line">	=&gt; (number - number) * number</span><br></pre></td></tr></table></figure>

<p>这样就完成了(34 - 3)*42的推导</p>
<p>由推导从exp中得到的所有记号符号的串集是 被表达式的文法定义的语言。这个语言包括了所有合乎语法的表达式。用符号表示：<code>L(G) = &#123;s|exp =&gt;* s&#125;</code></p>
<p>G代表表达式文法，s代表记号符号的任意数组串（也称为句子），&#x3D;&gt;*表示由替换序列组成的推导（*表示多次，与正则中的重复很像）。通过推导产生L(G)中的串。</p>
<p>一些术语可以更好的区别结构与符号，结构必须被进一步替换，他们被称作非终结符，而符号终结推导，被称为终结符。</p>
<p>如果要产生空串，可以定义<code>empty → ε</code>。这样的文法规则被称为ε-产生式，任何包括了空串的文法至少要有一个ε-产生式。如可以将正则表达式a*写成文法规则<code>A → Aa|ε</code></p>
<h5 id="分析树和抽象语法树"><a href="#分析树和抽象语法树" class="headerlink" title="分析树和抽象语法树"></a>分析树和抽象语法树</h5><h6 id="分析树"><a href="#分析树" class="headerlink" title="分析树"></a>分析树</h6><p>通过推导可以生成分析树，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exp =&gt; exp op exp</span><br><span class="line">	=&gt; number op exp</span><br><span class="line">	=&gt; number * exp</span><br><span class="line">	=&gt; number * number</span><br></pre></td></tr></table></figure>

<p> 这个推导可以生成下面的分析树（省略树枝）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">		exp</span><br><span class="line"></span><br><span class="line">exp		op		exp</span><br><span class="line"></span><br><span class="line">number	*		number</span><br></pre></td></tr></table></figure>

<p>如果考虑推导顺序，还可以进行编号：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">		1exp</span><br><span class="line"></span><br><span class="line">2exp	3op		4exp</span><br><span class="line"></span><br><span class="line">number	*		number</span><br></pre></td></tr></table></figure>

<p>推导因为顺序原因可以是多种多样的。最左推导指每次推导都替换掉最左非终结符的推导，最右同理</p>
<p> 根据最左推导和最右推导，可以构造出具有前序编号和后序编号的分析树（可以参考pdfP88,P89的向噶U内内容）</p>
<h6 id="抽象语法树"><a href="#抽象语法树" class="headerlink" title="抽象语法树"></a>抽象语法树</h6><p>分析树虽然能完整的表示推导的过程，但它提供的信息太多了，在编译过程中我们并不需要那么多信息，这时候我们就需要对分析树进行优化，创建抽象语法树</p>
<p>仍以上一节的例子为例，先为分析树加上一些额外信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">		exp</span><br><span class="line"></span><br><span class="line">exp		op		exp</span><br><span class="line"></span><br><span class="line">number	*		number</span><br><span class="line">3				4</span><br></pre></td></tr></table></figure>

<p>表示3*4的运算，我们进行优化后得到抽象语法树</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">		*</span><br><span class="line">	/		\</span><br><span class="line">3				4</span><br></pre></td></tr></table></figure>

<p>这样省略的推导，且能够表示出相同的信息</p>
<p>再考虑(3*4)*4</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">				*</span><br><span class="line">			/		\</span><br><span class="line">		*				4</span><br><span class="line">	/		\</span><br><span class="line">3				4</span><br></pre></td></tr></table></figure>

<p>虽然省略了括号但仍然能清晰的表示(3*4)*4的含义</p>
<p>我们可以由一个数据类型定义这样的抽象语法树</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span>Plus, Minus, Times&#125; OpKind;<span class="comment">//操作符类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span>OpKind, ConstKind&#125; ExpKind;<span class="comment">//表达式类型，带操作符或常量</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">streenode</span> &#123;</span></span><br><span class="line">    ExpKind kind;</span><br><span class="line">    OpKind op;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">streenode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span><span class="comment">//带操作符的话需要左右节点</span></span><br><span class="line">    <span class="type">int</span> val;<span class="comment">//不带操作符的定值</span></span><br><span class="line">&#125; sTreeNode;</span><br><span class="line"><span class="keyword">typedef</span> sTreeNode *SyntaxTree;</span><br></pre></td></tr></table></figure>

<h5 id="二义性"><a href="#二义性" class="headerlink" title="二义性"></a>二义性</h5><h6 id="二义性文法"><a href="#二义性文法" class="headerlink" title="二义性文法"></a>二义性文法</h6><p>考虑串<code>2-1*3</code>，即使使用最左推导，它仍然能推导出两种分析树</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">					exp</span><br><span class="line">			 /       |       \			</span><br><span class="line">		exp			op			exp</span><br><span class="line">    /   |     \      |            |</span><br><span class="line">exp		op		exp	 *			number</span><br><span class="line"> |      |        |</span><br><span class="line">number	-		number</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	exp</span><br><span class="line">/	 |	  		\</span><br><span class="line">exp  op    		exp</span><br><span class="line"> |	  |		/	 |    \	</span><br><span class="line">number	  -	   exp	 op     exp</span><br><span class="line">               |     |       |</span><br><span class="line">              number *      number</span><br></pre></td></tr></table></figure>

<p>抽象语法树也对应有两种</p>
<p>能产生两种不同分析树的串的文法被称为二义性文法，这种文法不能准确的指示出程序的语法结构，所以是分析程序必须解决的问题。</p>
<p>基本的解决方法有两个。一个是设置一个规则，这个规则可以在二义性情况下指出哪个分析树是对的，这种方法的缺点在于语言的语法结构再也不能由文法规则单独提供了。另一个办法是将文法强制改变成一个能产生正确分析树的文法，这样不会产生二义性了。</p>
<p>当然我们要确定哪个语法树是正确的，很明显，先乘后减的运算是正确的。要消除这个运算的二义性，我们可以设置*的优先级更高的规则。但这样并不能规避所有的二义性，如2-1-5，不同的推导仍然会产生二义性，所以又需要制定一个规则：减法运算为左结合（认为一个减法序列的运算是自左向右的）</p>
<p>所以对于简单的表达式文法，可以有一个规则规定加减乘为左结合。</p>
<p>下面不再讨论通过规则消除二义性，而是通过重写文法来消除二义性。</p>
<h6 id="优先权和结合性"><a href="#优先权和结合性" class="headerlink" title="优先权和结合性"></a>优先权和结合性</h6><p>为了处理文法中优先级的问题，就要把具有相同优先级的运算符归到一组里，现在重写简单表达式的文法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exp → exp addop exp|term</span><br><span class="line">addop → +|-</span><br><span class="line">term → term mulop term | factor</span><br><span class="line">mulop → *</span><br><span class="line">factor → (exp)|number</span><br></pre></td></tr></table></figure>

<p>这样乘法被归到了term规则下，而加减法被归到了exp规则下，这样生成的抽象语法树中加减法始终在上部，因此它们的优先级就降低了。这种分组被称为优先级联</p>
<p>这种文法解决了优先级，但没有解决结合性，解决办法是用基本情况代替递归，再次重写规则</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exp → exp addop term|term</span><br><span class="line">addop → +|-</span><br><span class="line">term → term mulop term | factor</span><br><span class="line">mulop → *</span><br><span class="line">factor → (exp)|number</span><br></pre></td></tr></table></figure>

<p><code>exp → exp addop term|term</code>使得加减运算符左结合，而<code>exp → term addop add|term</code>使得右结合。</p>
<p>现在让所有运算都左结合</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exp → exp addop term|term</span><br><span class="line">addop → +|-</span><br><span class="line">term → term mulop factor | factor</span><br><span class="line">mulop → *</span><br><span class="line">factor → (exp)|number</span><br></pre></td></tr></table></figure>

<p>优先级联使分析树变得复杂，但抽象语法树不受影响</p>
<h6 id="悬挂else问题"><a href="#悬挂else问题" class="headerlink" title="悬挂else问题"></a>悬挂else问题</h6><p>考虑下面的简化版本的if语句文法（把判断语句简化为0|1,把其他语句简化为other）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">statement → if-stmt|other</span><br><span class="line">if-stmt → if(exp) statement|if(exp) statement else statement</span><br><span class="line">exp → 0|1</span><br></pre></td></tr></table></figure>

<p>考虑下面的串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(0) if(1) other else other</span><br></pre></td></tr></table></figure>

<p>这里同样有二义性，指的是else与第一个if匹配还是第二个if匹配。这种二义性称为悬挂else问题。很明显，在c语言中，else应该与第二个if匹配，如果要与第一个if匹配，就要加大括号</p>
<p>解决办法比之前的麻烦一些</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">statment → matched-stmt|unmatched-stmt</span><br><span class="line">matched-stmt → if(exp) mathched-stmt else matched-stmt|other</span><br><span class="line">unmathched-stmt → if(exp) statement | if(exp) mathched-stmt else unmatched-stmt </span><br><span class="line">exp → 0|1</span><br></pre></td></tr></table></figure>

<p>这样只有一个matched-stmt会出现在else之前，使得能够正确匹配</p>
<p>但通常不在BNF中建立这样的规则，主要原因是分析办法很容易按照遵循最近嵌套规则的方法来配置</p>
<h6 id="无关紧要的二义性"><a href="#无关紧要的二义性" class="headerlink" title="无关紧要的二义性"></a>无关紧要的二义性</h6><p>有些二义性可能会生成唯一的语法树，或者语法树虽然不同但语义是相同的（比如乘法的结合律），这种二义性称为无关紧要的二义性。然而分析算法却要提供一些消除二义性的规则。</p>
<h5 id="拓展的表示法：EBNF和语法图"><a href="#拓展的表示法：EBNF和语法图" class="headerlink" title="拓展的表示法：EBNF和语法图"></a>拓展的表示法：EBNF和语法图</h5><h6 id="EBNF表示法"><a href="#EBNF表示法" class="headerlink" title="EBNF表示法"></a>EBNF表示法</h6><p>重复和可选的结构在程序设计语言中很普遍，在BNF文法规则中也是一样的。BNF表示法有时扩展到包含这两种特殊表示法，我们称之为拓展的BNF或EBNF表示法</p>
<p>EBNF选择用花括号{…}表示重复</p>
<p>例如将<code>A→aA|b</code>这种右递归改写为重复形式：<code>A → &#123;a&#125;b</code></p>
<p>这种写法的一个问题是让分析树的构造不清楚，但不用在意，左递归和右递归仍然能够区分</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">右递归：A → &#123;a&#125;b</span><br><span class="line">左递归：A → b&#123;a&#125;</span><br></pre></td></tr></table></figure>

<p>通常使用左递归的形式</p>
<p>在结合性的表示中也会出现问题，如在表示加减法的文法规则<code>exp → exp addop term | term </code>，在EBNF中写作：<code>exp → term &#123;addop term&#125;</code>，虽然看不出来，但我们可以规定它暗示了左结合，同理，也可以写出右结合：<code>exp → &#123;term addop&#125; term</code>。但事实并不是这样，如：</p>
<p><code>stmt-sequence → stmt;stmt-sequence|stmt</code> 可以看成一个<code>stmt</code>后接可选的<code>;sequence-stmt</code></p>
<p>在EBNF中可选用方括号<code>[]</code>表示,如可选else就可以写成</p>
<p><code>if-stmt → if(exp) statement [else statement]</code></p>
<p>上面的例子也可以写作<code>stmt-sequence → stmt[;stmt-sequence]</code>                                                                                                                                                                                                                                                                                                                                                                                          </p>
<h6 id="语法图"><a href="#语法图" class="headerlink" title="语法图"></a>语法图</h6><p>用作可视地表示EBNF规则的图形表示法被称为语法图。它们由表示终结符和非终结符的方框，表示序列和选择的带箭头的线，非终结符标记组成，用圆形和椭圆形框表示终结符，方形框和矩形框则表示非终结符</p>
<p>具体图示参考PDFP101及其后内容</p>
<h5 id="上下文无关语言的形式特性"><a href="#上下文无关语言的形式特性" class="headerlink" title="上下文无关语言的形式特性"></a>上下文无关语言的形式特性</h5><p>这里是用更正式的数学方法写出前面提到的术语和定义，这里就不展开了，可以参考PDFP103-P107</p>
<h5 id="TINY语言的语法"><a href="#TINY语言的语法" class="headerlink" title="TINY语言的语法"></a>TINY语言的语法</h5><h6 id="TINY语言的上下文无关语法"><a href="#TINY语言的上下文无关语法" class="headerlink" title="TINY语言的上下文无关语法"></a>TINY语言的上下文无关语法</h6><p>下面先给出TINY语言的BNF文法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">program → stmt-sequence</span><br><span class="line">stmt-sequence → stmt-sequence ; statement | statement</span><br><span class="line">statement → if-stmt | repeat-stmt | read-stmt | write-stmt</span><br><span class="line">if-stmt → if exp then stmt-sequence end</span><br><span class="line">		  | if exp then stmt-sequence else stmt-sequence end</span><br><span class="line">repeat-stmt → repeat stmt-sequence until exp</span><br><span class="line">assign-stmt → identifier := exp</span><br><span class="line">read-stmt → read identifier</span><br><span class="line">write-stmt → write exp</span><br><span class="line">exp → simple-exp comparision-op simple-exp | simple-exp</span><br><span class="line">comparison-op → &lt; | =</span><br><span class="line">simple-exp → simple-exp addop term | term</span><br><span class="line">addop → +|-</span><br><span class="line">term → term mulop factor | factor</span><br><span class="line">mulop → *|/</span><br><span class="line">factor → (exp) | number | identifier</span><br></pre></td></tr></table></figure>

<p>可以看到TINY程序只是一个语句序列，它有五种语句：if语句，repeat语句，read语句，write语句，assignment语句。if语句使用end作为括号关键字因此不存在悬挂else问题。read语句一次读入一个变量，而write语句一次只写出一个表达式。表达式有两类，比较表达式（使用&lt;和&#x3D;作为操作符），算术表达式（使用+-*&#x2F;作为运算符）。TINY没有声明语句 ，只通过赋值语句来隐式声明一个变量，只有一个作用域（全局作用域）且没有过程和函数</p>
<p>另外一点是TINY使用分号来分隔语句但最后一个语句末尾没有分号，因为TINY没有空语句</p>
<p>因为这一章并没有涉及到更多的分析细节，重点在于理论学习，这里只分析少许代码</p>
<p>在global.h中定义了语法树的结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**************************************************/</span></span><br><span class="line"><span class="comment">/***********   Syntax tree for parsing ************/</span></span><br><span class="line"><span class="comment">/**************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span>StmtK,ExpK&#125; NodeKind;<span class="comment">//枚举定义节点类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span>IfK,RepeatK,AssignK,ReadK,WriteK&#125; StmtKind;<span class="comment">//枚举定义语句类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span>OpK,ConstK,IdK&#125; ExpKind;<span class="comment">//枚举定义表达式类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ExpType is used for type checking */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span>Void,Integer,Boolean&#125; ExpType;<span class="comment">//枚举定义表达式的值的类型</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXCHILDREN 3<span class="comment">//定义子节点的最大数目（给数组开辟空间）</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span></span></span><br><span class="line"><span class="class">   &#123;</span> <span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span> * <span class="title">child</span>[<span class="title">MAXCHILDREN</span>];</span><span class="comment">//子节点</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span> * <span class="title">sibling</span>;</span><span class="comment">//同级节点，如用分号隔开的多个语句</span></span><br><span class="line">     <span class="type">int</span> lineno;<span class="comment">//行号，和词法分析里的作用一样</span></span><br><span class="line">     NodeKind nodekind;<span class="comment">//节点类型</span></span><br><span class="line">     <span class="class"><span class="keyword">union</span> &#123;</span> StmtKind stmt; ExpKind <span class="built_in">exp</span>;&#125; kind;<span class="comment">//种类（是语句或者表达式）</span></span><br><span class="line">     <span class="class"><span class="keyword">union</span> &#123;</span> TokenType op;</span><br><span class="line">             <span class="type">int</span> val;</span><br><span class="line">             <span class="type">char</span> * name; &#125; attr;<span class="comment">//节点的属性（操作符，数字值，标识符的串值）</span></span><br><span class="line">     ExpType type; <span class="comment">/* for type checking of exp 表达式的值的类型 */</span></span><br><span class="line">   &#125; TreeNode;</span><br></pre></td></tr></table></figure>

<p>本章到此结束，下面开始讲解分析过程</p>
<h4 id="自顶向下的分析"><a href="#自顶向下的分析" class="headerlink" title="自顶向下的分析"></a>自顶向下的分析</h4><p>自顶向下的分析算法通过在最左推导中描述出各个步骤来分析记号串输入。之所以称为是自顶向下是因为分析树中隐含的编号是前序编号，且顺序是由根到叶。</p>
<p>自顶向下的分析程序有两类：回溯分析程序和预测分析程序。预测分析程序试图用一个或多个先行记号来预测输入串的下一个构造，而回溯分析程序试图分析其他有可能的输入，当失败时就回溯备份。虽然回溯分析程序更加强大，但都太慢了，对于编译器并不合适，本书不研究回溯分析程序</p>
<p>本章要学习的两类自顶向下分析算法分别是递归下降分析和LL(1)分析。递归下降比较常用，且对于手写程序最为合适，因此先学习递归下降的分析算法。LL(1)在实际中不常用到，所以只是简单学习，它是下一张自底向上算法的前奏。</p>
<h5 id="使用递归下降分析算法进行自顶向下的分析"><a href="#使用递归下降分析算法进行自顶向下的分析" class="headerlink" title="使用递归下降分析算法进行自顶向下的分析"></a>使用递归下降分析算法进行自顶向下的分析</h5><h6 id="递归下降分析的基本方法"><a href="#递归下降分析的基本方法" class="headerlink" title="递归下降分析的基本方法"></a>递归下降分析的基本方法</h6><p>递归下降分析的概念很简单：将一个非终结符A的文法规则看作识别A的一个过程。	</p>
<p>考虑前一章的表达式文法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exp → exp addop term|term</span><br><span class="line">addop → +|-</span><br><span class="line">term → term mulop factor | factor</span><br><span class="line">mulop → *</span><br><span class="line">factor → (exp)|number</span><br></pre></td></tr></table></figure>

<p>考虑对其中的factor进行递归下降分析，可以写出这样的伪代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TokenType * <span class="title function_">factor</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(token == <span class="string">&#x27;:&#x27;</span>) &#123;</span><br><span class="line">    match(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">    <span class="built_in">exp</span>();</span><br><span class="line">    match(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(token == number) &#123;</span><br><span class="line">    match(number);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    error()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 这段伪代码中，假设有一个在输入中保存的token变量，还假设有一个match()匹配过程，它用参数匹配记号，如果成功则前移，失败就表明错误</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">match</span><span class="params">(TokenType * expected_token)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(token == expected_token) &#123;</span><br><span class="line">    getToken();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    error()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="comment">//伪代码</span></span><br></pre></td></tr></table></figure>

<p>并非所有文法规则都像factor规则这么简单。我们需要用到EBNF</p>
<h6 id="重复和选择：使用EBNF"><a href="#重复和选择：使用EBNF" class="headerlink" title="重复和选择：使用EBNF"></a>重复和选择：使用EBNF</h6><p>考虑一个化简后的if的文法规则</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if-stmt → if (exp) statement</span><br><span class="line">		  | if (exp) statement else statement</span><br></pre></td></tr></table></figure>

<p> 这里并不能直接区分出右边的两个选择，因为它们都是以if开头，必须要看到else时才能决定是否识别可选的else部分，这恰好对应EBNF中的可选。所以它与EBNF的匹配度更高。事实上EBNF就是为了能更加贴合递归下降分析的代码过程而被设计的，所以如果使用递归下降分析的话应该尽可能使用EBNF表示文法。</p>
<p>考虑下面这种情况          </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exp → exp addop term|term</span><br></pre></td></tr></table></figure>

<p>如果对BNF直接分析的话，第一个分析的token就是exp，这会造成无限递归，然而使用EBNF就不存在这个问题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exp → term &#123;addop term&#125;</span><br></pre></td></tr></table></figure>

<p>对于花括号中的内容，我们可以使用循环来表示在代码中</p>
<h5 id="LL-1-分析"><a href="#LL-1-分析" class="headerlink" title="LL(1)分析"></a>LL(1)分析</h5><p>不在课程要求内，先省略相关内容</p>
<h5 id="TINY语言的递归下降分析程序"><a href="#TINY语言的递归下降分析程序" class="headerlink" title="TINY语言的递归下降分析程序"></a>TINY语言的递归下降分析程序</h5><p>先给出TINY语言的EBNF文法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">program → stmt-sequence</span><br><span class="line">stmt-sequence → statement &#123;;statement&#125;</span><br><span class="line">statement → if    printTree(psyntaxTree);-stmt | repeat-stmt | read-stmt | write-stmt</span><br><span class="line">if-stmt → if exp then stmt-sequence [else stmt-sequence] end</span><br><span class="line">repeat-stmt → repeat stmt-sequence until exp</span><br><span class="line">assign-stmt → identifier := exp</span><br><span class="line">read-stmt → read identifier</span><br><span class="line">write-stmt → write exp</span><br><span class="line">exp → simple-exp [comparision-op simple-exp]</span><br><span class="line">comparison-op → &lt;|=</span><br><span class="line">simple-exp → term &#123;addop term&#125;</span><br><span class="line">addop → +|-</span><br><span class="line">term → factor&#123;mulop factor&#125;</span><br><span class="line">mulop → *|/</span><br><span class="line">factor → (exp) | number | identifier</span><br></pre></td></tr></table></figure>

<p>原书中有加粗表示字符穿串而不是名称，更容易看懂，可以看PDFp146</p>
<p>这里直接结合源码</p>
<p>分析的内容在文件parse.c中，而语法树节点的定义在global.h中，在上一章已经分析过</p>
<p>parse.c的核心函数<code>parse()</code>在main.c中被调用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">syntaxTree = parse();</span><br><span class="line"><span class="keyword">if</span> (TraceParse) &#123;</span><br><span class="line">  <span class="built_in">fprintf</span>(listing, <span class="string">&quot;\nSyntax tree:\n&quot;</span>);</span><br><span class="line">  printTree(psyntaxTree);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里调用了<code>parse()</code>函数并生成了一棵语法树。如果打开了<code>TraceParse</code>选项后（和扫描程序的类似），就会把语法树打印出来</p>
<p><code>printTree</code>函数定义在util.c文件中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Variable indentno is used by printTree to</span></span><br><span class="line"><span class="comment"> * store current number of spaces to indent</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> indentno = <span class="number">0</span>;<span class="comment">//用于计数的变量，表示要打印的空格数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* macros to increase/decrease indentation */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INDENT indentno+=2<span class="comment">//表示加两个空格</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNINDENT indentno-=2<span class="comment">//表示减两个空格</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* printSpaces indents by printing spaces */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">printSpaces</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;indentno;i++)<span class="comment">//for循环打印空格表示缩进</span></span><br><span class="line">    <span class="built_in">fprintf</span>(listing,<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* procedure printTree prints a syntax tree to the </span></span><br><span class="line"><span class="comment"> * listing file using indentation to indicate subtrees</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printTree</span><span class="params">( TreeNode * tree )</span><span class="comment">//接收一个树节点（根节点）</span></span><br><span class="line">&#123; <span class="type">int</span> i;</span><br><span class="line">  INDENT;<span class="comment">//默认先缩进两格</span></span><br><span class="line">  <span class="keyword">while</span> (tree != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    printSpaces();<span class="comment">//根据indentno的值打印空格表示缩进</span></span><br><span class="line">    <span class="keyword">if</span> (tree-&gt;nodekind==StmtK)</span><br><span class="line">    &#123; <span class="keyword">switch</span> (tree-&gt;kind.stmt) &#123;</span><br><span class="line">        <span class="keyword">case</span> IfK:</span><br><span class="line">          <span class="built_in">fprintf</span>(listing,<span class="string">&quot;If\n&quot;</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> RepeatK:</span><br><span class="line">          <span class="built_in">fprintf</span>(listing,<span class="string">&quot;Repeat\n&quot;</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> AssignK:</span><br><span class="line">          <span class="built_in">fprintf</span>(listing,<span class="string">&quot;Assign to: %s\n&quot;</span>,tree-&gt;attr.name);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ReadK:</span><br><span class="line">          <span class="built_in">fprintf</span>(listing,<span class="string">&quot;Read: %s\n&quot;</span>,tree-&gt;attr.name);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> WriteK:</span><br><span class="line">          <span class="built_in">fprintf</span>(listing,<span class="string">&quot;Write\n&quot;</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="built_in">fprintf</span>(listing,<span class="string">&quot;Unknown ExpNode kind\n&quot;</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (tree-&gt;nodekind==ExpK)</span><br><span class="line">    &#123; <span class="keyword">switch</span> (tree-&gt;kind.<span class="built_in">exp</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> OpK:</span><br><span class="line">          <span class="built_in">fprintf</span>(listing,<span class="string">&quot;Op: &quot;</span>);</span><br><span class="line">          printToken(tree-&gt;attr.op,<span class="string">&quot;\0&quot;</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ConstK:</span><br><span class="line">          <span class="built_in">fprintf</span>(listing,<span class="string">&quot;Const: %d\n&quot;</span>,tree-&gt;attr.val);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IdK:</span><br><span class="line">          <span class="built_in">fprintf</span>(listing,<span class="string">&quot;Id: %s\n&quot;</span>,tree-&gt;attr.name);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="built_in">fprintf</span>(listing,<span class="string">&quot;Unknown ExpNode kind\n&quot;</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">fprintf</span>(listing,<span class="string">&quot;Unknown node kind\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;MAXCHILDREN;i++)</span><br><span class="line">         printTree(tree-&gt;child[i]);</span><br><span class="line">    tree = tree-&gt;sibling;</span><br><span class="line">  &#125;</span><br><span class="line">  UNINDENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到每调用一次<code>printTree</code>函数都会先让缩进增加两格空格，如果有子节点的话就会重复调用<code>printTree</code>，导致缩进继续增加，缩进效果就是这样实现的。而当没有孩子节点的时候转到兄弟节点（没有兄弟节点就结束while循环），转到兄弟节点后会让缩进减少两格空格（<code>UNINDENT</code>），所以同级的节点缩进数一定相同，依靠缩进便于展示树状结构</p>
<p>下面进入正题，开始看<code>parse()</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;globals.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;util.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;scan.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;parse.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> TokenType token; <span class="comment">/* holds current token */</span></span><br><span class="line"><span class="comment">/****************************************/</span></span><br><span class="line"><span class="comment">/* the primary function of the parser   */</span></span><br><span class="line"><span class="comment">/****************************************/</span></span><br><span class="line"><span class="comment">/* Function parse returns the newly </span></span><br><span class="line"><span class="comment"> * constructed syntax tree</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">TreeNode * <span class="title function_">parse</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; TreeNode * t;</span><br><span class="line">  token = getToken();</span><br><span class="line">  t = stmt_sequence();</span><br><span class="line">  <span class="keyword">if</span> (token!=ENDFILE)</span><br><span class="line">    syntaxError(<span class="string">&quot;Code ends before file\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数非常简单，它先调用<code>getToken()</code>函数，把获取到token赋给token变量，这个变量是在parse.c的顶部声明的，表示当前遍历到的token，然后它调用<code>stmt-sequence</code>函数（之前有提到TINY只是由语句序列构成的），根据递归下降分析，这个函数会匹配，然后调用其他函数，这其中会不断的触发<code>getToken</code>，所以说扫描程序是由分析程序驱动的。完成整个递归下降分析后，生成了一棵语法树并返回。如果开始就文件尾就会触发错误。</p>
<p>下面来看<code>stmt-sequence</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TreeNode * <span class="title function_">stmt_sequence</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; TreeNode * t = statement();</span><br><span class="line">  TreeNode * p = t;</span><br><span class="line">  <span class="keyword">while</span> ((token!=ENDFILE) &amp;&amp; (token!=END) &amp;&amp;(token!=ELSE) &amp;&amp; (token!=UNTIL))</span><br><span class="line">  &#123; TreeNode * q;<span class="comment">//定义一个节点q</span></span><br><span class="line">    match(SEMI);<span class="comment">//匹配分号</span></span><br><span class="line">    q = statement();<span class="comment">//获取statement生成的节点并赋值给q</span></span><br><span class="line">    <span class="keyword">if</span> (q!=<span class="literal">NULL</span>) &#123;<span class="comment">//如果获取到了</span></span><br><span class="line">      <span class="keyword">if</span> (t==<span class="literal">NULL</span>) t = p = q;</span><br><span class="line">      <span class="keyword">else</span> <span class="comment">/* now p cannot be NULL either */</span></span><br><span class="line">      &#123; p-&gt;sibling = q;<span class="comment">//就把q作为p的邻接节点</span></span><br><span class="line">        p = q;<span class="comment">//q赋值给p（链表后移）</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结合EBNF文法<code>stmt-sequence → statement &#123;;statement&#125;</code>，语句序列是由一个<code>statement</code>和重复的<code>;statement</code>组成的，因此在这个函数开头先调用了<code>statement</code>函数，这个函数继续递归下降得到树节点t,然后while循环的作用是表示重复。所有重复的statement节点都会用邻接表的形式充当兄弟节点</p>
<p>然后看<code>statement()</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TreeNode * <span class="title function_">statement</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; TreeNode * t = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">switch</span> (token) &#123;</span><br><span class="line">    <span class="keyword">case</span> IF : t = if_stmt(); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> REPEAT : t = repeat_stmt(); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ID : t = assign_stmt(); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> READ : t = read_stmt(); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WRITE : t = write_stmt(); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span> : syntaxError(<span class="string">&quot;unexpected token -&gt; &quot;</span>);</span><br><span class="line">              printToken(token,tokenString);</span><br><span class="line">              token = getToken();</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">  &#125; <span class="comment">/* end case */</span></span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据文法<code>statement → if-stmt | repeat-stmt | read-stmt | write-stmt</code>，这个函数被设计成<code>switch...case...</code>来表示选择，当然也包括了错误处理</p>
<p>先假设正确匹配了，依次看各种语句</p>
<p>先看if</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TreeNode * <span class="title function_">if_stmt</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; TreeNode * t = newStmtNode(IfK);</span><br><span class="line">  match(IF);</span><br><span class="line">  <span class="keyword">if</span> (t!=<span class="literal">NULL</span>) t-&gt;child[<span class="number">0</span>] = <span class="built_in">exp</span>();<span class="comment">//匹配exp</span></span><br><span class="line">  match(THEN);<span class="comment">//匹配then</span></span><br><span class="line">  <span class="keyword">if</span> (t!=<span class="literal">NULL</span>) t-&gt;child[<span class="number">1</span>] = stmt_sequence();<span class="comment">//匹配if==true执行的语句</span></span><br><span class="line">  <span class="keyword">if</span> (token==ELSE) &#123;<span class="comment">//匹配可选的else</span></span><br><span class="line">    match(ELSE);</span><br><span class="line">    <span class="keyword">if</span> (t!=<span class="literal">NULL</span>) t-&gt;child[<span class="number">2</span>] = stmt_sequence();</span><br><span class="line">  &#125;</span><br><span class="line">  match(END);</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于<code>if-stmt</code>函数被调用的前提是当前token是IF,所以当调用时我们就可以预测这会生成一个语句类型的节点，且语句类型是if。所以先调用一个工具函数<code>newStmtNode</code>，这个函数在<code>util.c</code>中定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Function newStmtNode creates a new statement</span></span><br><span class="line"><span class="comment"> * node for syntax tree construction</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">TreeNode * <span class="title function_">newStmtNode</span><span class="params">(StmtKind kind)</span></span><br><span class="line">&#123; TreeNode * t = (TreeNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode));<span class="comment">//通过动态内存分配创建节点</span></span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">if</span> (t==<span class="literal">NULL</span>)<span class="comment">//分配失败</span></span><br><span class="line">    <span class="built_in">fprintf</span>(listing,<span class="string">&quot;Out of memory error at line %d\n&quot;</span>,lineno);</span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="comment">//开始根据获取的参数给t初始化一些数据</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;MAXCHILDREN;i++) t-&gt;child[i] = <span class="literal">NULL</span>;</span><br><span class="line">    t-&gt;sibling = <span class="literal">NULL</span>;</span><br><span class="line">    t-&gt;nodekind = StmtK;</span><br><span class="line">    t-&gt;kind.stmt = kind;</span><br><span class="line">    t-&gt;lineno = lineno;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> t;<span class="comment">//返回t</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后调用<code>match</code>函数匹配IF,其实<code>if-stmt</code>函数被调用的前提是当前token是IF，所以这个match一定会成立，实际上只是为了获取下一个token（驱动扫描程序）</p>
<p>看一下<code>match</code>函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">match</span><span class="params">(TokenType expected)</span></span><br><span class="line">&#123; <span class="keyword">if</span> (token == expected) token = getToken();<span class="comment">//如果token和作为参数的需要的token相同就获取下一个token</span></span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="comment">//否则进行错误处理</span></span><br><span class="line">    syntaxError(<span class="string">&quot;unexpected token -&gt; &quot;</span>);</span><br><span class="line">    printToken(token,tokenString);</span><br><span class="line">    <span class="built_in">fprintf</span>(listing,<span class="string">&quot;      &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据文法<code>if-stmt → if exp then stmt-sequence [else stmt-sequence] end</code>，匹配了if之后需要匹配exp(TINY语言的exp外面不需要括号)，匹配完exp之后会再匹配then字符串，然后匹配if为true时执行的语句，对于else由于是可选的所以用了if选择匹配。最后是结尾标志符end的匹配</p>
<p>下面再看<code>exp()</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TreeNode * <span class="title function_">exp</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; TreeNode * t = simple_exp();<span class="comment">//进行simple-exp的匹配</span></span><br><span class="line">  <span class="keyword">if</span> ((token==LT)||(token==EQ)) &#123;</span><br><span class="line">    TreeNode * p = newExpNode(OpK);<span class="comment">//调用工具函数初始化</span></span><br><span class="line">    <span class="keyword">if</span> (p!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">      p-&gt;child[<span class="number">0</span>] = t;<span class="comment">//如果是比较型表达式，那么第一个simple-exp就要成为该表达式的子节点</span></span><br><span class="line">      p-&gt;attr.op = token;<span class="comment">//给节点完善操作符属性</span></span><br><span class="line">      t = p;<span class="comment">//返回值更改为p</span></span><br><span class="line">    &#125;</span><br><span class="line">    match(token);<span class="comment">//传入token,必然成立，目的是获取下一个token</span></span><br><span class="line">    <span class="keyword">if</span> (t!=<span class="literal">NULL</span>)</span><br><span class="line">      t-&gt;child[<span class="number">1</span>] = simple_exp();<span class="comment">//另一个子节点是后面的simple-exp</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据文法<code>exp → simple-exp [comparision-op simple-exp]</code>，exp是由一个<code>simple-exp</code>(运算表达式)和可选的<code>comparsion-op simple-exp</code>组成（用于和前面必有的simple-exp构成一个比较表达式）。同样用if表示可选，当存在比较时就可以先预测这个节点会是一个表达式类型的节点，且表达式类型是有运算符（<code>OpK</code>），同样，是调用<code>util.c</code>中的<code>newExpNode</code>函数进行初始化。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Function newExpNode creates a new expression </span></span><br><span class="line"><span class="comment"> * node for syntax tree construction</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//和newStmtNode相似，不解释了</span></span><br><span class="line">TreeNode * <span class="title function_">newExpNode</span><span class="params">(ExpKind kind)</span></span><br><span class="line">&#123; TreeNode * t = (TreeNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">if</span> (t==<span class="literal">NULL</span>)</span><br><span class="line">    <span class="built_in">fprintf</span>(listing,<span class="string">&quot;Out of memory error at line %d\n&quot;</span>,lineno);</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;MAXCHILDREN;i++) t-&gt;child[i] = <span class="literal">NULL</span>;</span><br><span class="line">    t-&gt;sibling = <span class="literal">NULL</span>;</span><br><span class="line">    t-&gt;nodekind = ExpK;</span><br><span class="line">    t-&gt;kind.<span class="built_in">exp</span> = kind;</span><br><span class="line">    t-&gt;lineno = lineno;</span><br><span class="line">    t-&gt;type = Void;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面看<code>simple_exp()</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TreeNode * <span class="title function_">simple_exp</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; TreeNode * t = term();<span class="comment">//先匹配一次term</span></span><br><span class="line">  <span class="keyword">while</span> ((token==PLUS)||(token==MINUS))</span><br><span class="line">  &#123; TreeNode * p = newExpNode(OpK);<span class="comment">//调用工具函数初始化</span></span><br><span class="line">    <span class="keyword">if</span> (p!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">      p-&gt;child[<span class="number">0</span>] = t;<span class="comment">//有运算符的话之前匹配的term就要当成子节点</span></span><br><span class="line">      p-&gt;attr.op = token;<span class="comment">//给节点完善操作符属性</span></span><br><span class="line">      t = p;<span class="comment">//更改返回值</span></span><br><span class="line">      match(token);<span class="comment">//获取下一个token</span></span><br><span class="line">      t-&gt;child[<span class="number">1</span>] = term();<span class="comment">//获取后一个term</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据文法<code>simple-exp → term &#123;addop term&#125;</code>，这是由一个term和重复的addop term组成的，同样由while循环实现重复。</p>
<p>下面看<code>term()</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TreeNode * <span class="title function_">term</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; TreeNode * t = factor();</span><br><span class="line">  <span class="keyword">while</span> ((token==TIMES)||(token==OVER))</span><br><span class="line">  &#123; TreeNode * p = newExpNode(OpK);</span><br><span class="line">    <span class="keyword">if</span> (p!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">      p-&gt;child[<span class="number">0</span>] = t;</span><br><span class="line">      p-&gt;attr.op = token;</span><br><span class="line">      t = p;</span><br><span class="line">      match(token);</span><br><span class="line">      p-&gt;child[<span class="number">1</span>] = factor();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文法为<code>term → factor&#123;mulop factor&#125;</code>，这个文法和上面的<code>simple-exp</code>很像，而且代码内容格式也是一致的，不过多分析</p>
<p>下面看<code>factor()</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TreeNode * <span class="title function_">factor</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; TreeNode * t = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">switch</span> (token) &#123;</span><br><span class="line">    <span class="keyword">case</span> NUM :<span class="comment">//匹配数字</span></span><br><span class="line">      t = newExpNode(ConstK);<span class="comment">//调用工具函数初始化节点数据</span></span><br><span class="line">      <span class="keyword">if</span> ((t!=<span class="literal">NULL</span>) &amp;&amp; (token==NUM))</span><br><span class="line">        t-&gt;attr.val = atoi(tokenString);<span class="comment">//将串值转化为整数赋值给节点的属性值</span></span><br><span class="line">      match(NUM);<span class="comment">//必然成功，读取下一个token</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ID :</span><br><span class="line">      t = newExpNode(IdK);</span><br><span class="line">      <span class="keyword">if</span> ((t!=<span class="literal">NULL</span>) &amp;&amp; (token==ID))</span><br><span class="line">        t-&gt;attr.name = copyString(tokenString);</span><br><span class="line">      match(ID);<span class="comment">////必然成功，读取下一个token</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LPAREN :</span><br><span class="line">      match(LPAREN);<span class="comment">//左括号</span></span><br><span class="line">      t = <span class="built_in">exp</span>();<span class="comment">//匹配exp</span></span><br><span class="line">      match(RPAREN);<span class="comment">//右括号</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      syntaxError(<span class="string">&quot;unexpected token -&gt; &quot;</span>);<span class="comment">//其他的都是错误的token</span></span><br><span class="line">      printToken(token,tokenString);</span><br><span class="line">      token = getToken();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文法为<code>factor → (exp) | number | identifier</code>，这是一个选择，用<code>switch...case...实现</code></p>
<p>下面看其他语句</p>
<p>repeat语句</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TreeNode * <span class="title function_">repeat_stmt</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; TreeNode * t = newStmtNode(RepeatK);<span class="comment">//工具函数调用初始化节点数据</span></span><br><span class="line">  match(REPEAT);<span class="comment">//必然成功，读取下一个token</span></span><br><span class="line">  <span class="keyword">if</span> (t!=<span class="literal">NULL</span>) t-&gt;child[<span class="number">0</span>] = stmt_sequence();<span class="comment">//循环体里的语句序列（作为孩子）</span></span><br><span class="line">  match(UNTIL);<span class="comment">//匹配until</span></span><br><span class="line">  <span class="keyword">if</span> (t!=<span class="literal">NULL</span>) t-&gt;child[<span class="number">1</span>] = <span class="built_in">exp</span>();<span class="comment">//匹配until内的条件表达式</span></span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文法为<code>repeat-stmt → repeat stmt-sequence until exp</code>，很简单，顺序匹配即可。另外声明作为子节点可以让内容处于语法树的下端</p>
<p>赋值语句</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TreeNode * <span class="title function_">assign_stmt</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; TreeNode * t = newStmtNode(AssignK);<span class="comment">//初始化</span></span><br><span class="line">  <span class="keyword">if</span> ((t!=<span class="literal">NULL</span>) &amp;&amp; (token==ID))</span><br><span class="line">    t-&gt;attr.name = copyString(tokenString);</span><br><span class="line">  match(ID);<span class="comment">//匹配标识符</span></span><br><span class="line">  match(ASSIGN);<span class="comment">//匹配赋值操作符</span></span><br><span class="line">  <span class="keyword">if</span> (t!=<span class="literal">NULL</span>) t-&gt;child[<span class="number">0</span>] = <span class="built_in">exp</span>();<span class="comment">//匹配exp</span></span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文法为<code>assign-stmt → identifier := exp</code>，也是很直接的依次匹配</p>
<p>下面看输入和输出语句</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TreeNode * <span class="title function_">read_stmt</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; TreeNode * t = newStmtNode(ReadK);</span><br><span class="line">  match(READ);</span><br><span class="line">  <span class="keyword">if</span> ((t!=<span class="literal">NULL</span>) &amp;&amp; (token==ID))</span><br><span class="line">    t-&gt;attr.name = copyString(tokenString);</span><br><span class="line">  match(ID);</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode * <span class="title function_">write_stmt</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; TreeNode * t = newStmtNode(WriteK);</span><br><span class="line">  match(WRITE);</span><br><span class="line">  <span class="keyword">if</span> (t!=<span class="literal">NULL</span>) t-&gt;child[<span class="number">0</span>] = <span class="built_in">exp</span>();</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个语句的文法也很简单<code>read-stmt → read identifier write-stmt → write exp</code>，直接匹配即可</p>
<p>​                                                                                                                                                                                                                                          </p>
<p>​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                </p>
<p>​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ​                 </p>
<h6 id=""><a href="#" class="headerlink" title=""></a></h6><p>​    </p>
<p>​    </p>
<p>​    </p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
        <tag>编译前端</tag>
        <tag>词法分析</tag>
        <tag>语法分析</tag>
      </tags>
  </entry>
  <entry>
    <title>js数据结构：队列</title>
    <url>/2022/10/12/%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列是一种先进先出的数据结构</p>
<p>用JavaScript实现队列的下列功能：</p>
<p><code>enqueue</code>:入队</p>
<p><code>dequeue</code>:出队</p>
<p><code>peek</code>:返回队首元素</p>
<p><code>isEmpty</code>:判断队列是否为空</p>
<p><code>size</code>:返回队列长度</p>
<p><code>toString</code>:队列字符串化</p>
<p><code>clear</code>:清空队列</p>
<p>代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span>=<span class="number">0</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">lowestCount</span>=<span class="number">0</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span>=&#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">enqueue</span>(<span class="params">element</span>) &#123;<span class="comment">//入队</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">count</span>]=element;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span>++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">dequeue</span>(<span class="params"></span>) &#123;<span class="comment">//出队</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> result=<span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">lowestCount</span>];</span><br><span class="line">    <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">lowestCount</span>];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">lowestCount</span>++;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;<span class="comment">//是否为空</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">count</span>===<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">peek</span>(<span class="params"></span>) &#123;<span class="comment">//返回队首元素</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">lowestCount</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">size</span>(<span class="params"></span>) &#123;<span class="comment">//返回队列长度</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">count</span>-<span class="variable language_">this</span>.<span class="property">lowestCount</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">clear</span>(<span class="params"></span>) &#123;<span class="comment">//清空队列</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span>=&#123;&#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span>=<span class="number">0</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">lowestCount</span>=<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;<span class="comment">//转换成字符串</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> objString=<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.items[<span class="variable language_">this</span>.lowestCount]&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="variable language_">this</span>.<span class="property">lowestCount</span>+<span class="number">1</span>;i &lt; <span class="variable language_">this</span>.<span class="property">count</span>;i++) &#123;</span><br><span class="line">      objString=<span class="string">`<span class="subst">$&#123;objString&#125;</span>,<span class="subst">$&#123;<span class="variable language_">this</span>.items[i]&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> objString;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用队列的例子：击鼓传花</p>
<p>传入一个成员数组，和一个数字，在传到指定数字时淘汰对应的成员</p>
<p>思路：创建一个队列，每传一次就将队首元素出队并从队尾入队，这样使得拿着花圈的成员永远对应队首元素。到达指定次数之后，将队首元素出队，不再添加至队尾，添加至淘汰者名单中。当队列中只有一个元素时，结束循环，得到胜者</p>
<p>代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hotPotato</span>(<span class="params">elementsList,num</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> queue=<span class="keyword">new</span> <span class="title class_">Queue</span>();</span><br><span class="line">  <span class="keyword">let</span> out=[];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> elementsList) &#123;</span><br><span class="line">    queue.<span class="title function_">enqueue</span>(elementsList[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(queue.<span class="title function_">size</span>()&gt;<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;num;i++) &#123;</span><br><span class="line">      queue.<span class="title function_">enqueue</span>(queue.<span class="title function_">dequeue</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;queue.peek()&#125;</span>被淘汰了！`</span>)</span><br><span class="line">    out.<span class="title function_">push</span>(queue.<span class="title function_">dequeue</span>())</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">winner</span>: queue.<span class="title function_">dequeue</span>(),</span><br><span class="line">    <span class="attr">outList</span>: out</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h3><p>双端队列与队列的区别是双端队列可以任意在队首或队尾增加，删除元素</p>
<p>用JavaScript实现队列的下列功能：</p>
<p><code>addFront</code>:从队首添加元素</p>
<p><code>addBack</code>:从队尾添加元素（与队列中的enqueue类似）</p>
<p><code>removeFront</code>:从队首删除元素（与队列中dequeue类似）</p>
<p><code>removeBack</code>:从队尾删除元素（与栈中pop类似）</p>
<p><code>peekFront</code>:返回队首元素</p>
<p><code>peekBack</code>:返回队尾元素</p>
<p><code>isEmpty</code>:判断队列是否为空</p>
<p><code>size</code>:返回队列长度</p>
<p><code>clear</code>:清空队列</p>
<p><code>toString</code>:队列字符串化</p>
<p>代码实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Deque</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span>=<span class="number">0</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">lowestCount</span>=<span class="number">0</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span>=&#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">addBack</span>(<span class="params">element</span>) &#123;<span class="comment">//后端入队</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">count</span>]=element;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span>++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">addFront</span>(<span class="params">element</span>) &#123;<span class="comment">//前端入队</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">addBack</span>(element);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">lowestCount</span>&gt;<span class="number">0</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">lowestCount</span>--;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">lowestCount</span>]=element;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="variable language_">this</span>.<span class="property">count</span>;i&gt;<span class="number">0</span>;i--) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">items</span>[i]=<span class="variable language_">this</span>.<span class="property">items</span>[i-<span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">count</span>++;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">lowestCount</span>=<span class="number">0</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">items</span>[<span class="number">0</span>]=element;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">removeFront</span>(<span class="params"></span>) &#123;<span class="comment">//前端出队</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> result=<span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">lowestCount</span>];</span><br><span class="line">    <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">lowestCount</span>];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">lowestCount</span>++;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">removeBack</span>(<span class="params"></span>) &#123;<span class="comment">//后端出队</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> result=<span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">count</span>-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">count</span>-<span class="number">1</span>];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span>--;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;<span class="comment">//是否为空</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">count</span>===<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">peekFront</span>(<span class="params"></span>) &#123;<span class="comment">//返回队首元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">lowestCount</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">peekBack</span>(<span class="params"></span>) &#123;<span class="comment">//返回队尾元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">count</span>-<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">count</span>-<span class="variable language_">this</span>.<span class="property">lowestCount</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">clear</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span>=&#123;&#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span>=<span class="number">0</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">lowestCount</span>=<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> objString=<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.items[<span class="variable language_">this</span>.lowestCount]&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="variable language_">this</span>.<span class="property">lowestCount</span>+<span class="number">1</span>;i &lt; <span class="variable language_">this</span>.<span class="property">count</span>;i++) &#123;</span><br><span class="line">      objString=<span class="string">`<span class="subst">$&#123;objString&#125;</span>,<span class="subst">$&#123;<span class="variable language_">this</span>.items[i]&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> objString;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用双端队列的例子：检测回文串</p>
<p>回文串就是从前向后和从后向前读起来一样的字符串</p>
<p>思路：首先检测是否传入以及将字符串字母大写转为小写，然后创建双端队列，不断将队首队尾元素出队比较直至双端队列长度小于等于1即可</p>
<p>代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">palindromeChecker</span>(<span class="params">aString</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (aString === <span class="literal">undefined</span> || aString === <span class="literal">null</span> ||</span><br><span class="line">      (aString !== <span class="literal">null</span> &amp;&amp; aString.<span class="property">length</span> === <span class="number">0</span>)) &#123; <span class="comment">// 先判断是否传入字符串</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> deque = <span class="keyword">new</span> <span class="title class_">Deque</span>(); <span class="comment">// 创建一个双端对列</span></span><br><span class="line">  <span class="keyword">const</span> lowerString = aString.<span class="title function_">toLocaleLowerCase</span>().<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>).<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>); <span class="comment">// 将大写全部转换成小写</span></span><br><span class="line">  <span class="keyword">let</span> isEqual = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">let</span> firstChar, lastChar;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; lowerString.<span class="property">length</span>; i++) &#123; <span class="comment">// 向队列中添加字母</span></span><br><span class="line">    deque.<span class="title function_">addBack</span>(lowerString.<span class="title function_">charAt</span>(i));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (deque.<span class="title function_">size</span>() &gt; <span class="number">1</span> &amp;&amp; isEqual) &#123; <span class="comment">// 随时跳出</span></span><br><span class="line">    firstChar = deque.<span class="title function_">removeFront</span>(); <span class="comment">// 首字母</span></span><br><span class="line">    lastChar = deque.<span class="title function_">removeBack</span>(); <span class="comment">// 末尾字母</span></span><br><span class="line">    <span class="keyword">if</span> (firstChar !== lastChar) &#123;</span><br><span class="line">      isEqual = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> isEqual;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>数据结构</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>js数据结构：集合</title>
    <url>/2022/10/12/%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>集合是由一组无序且唯一（即不能重复）的项组成的。</p>
<p>我们先创建一个集合类</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">items</span>=&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用对象形式存储，且键值保持相同便于查找</p>
<ul>
<li><p>判断集合中是否拥有某元素</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">has</span>(<span class="params">element</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">hasOwnProperty</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>.<span class="property">items</span>,element);<span class="comment">//判断element是否在items中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Object</code>的原型中有一个<code>hasOwnProperty</code>方法用于判断传入的值是否在this中，使用call改变this指向到<code>this.items</code>中，直接使用<code>this.items.prototype.hasOwnProperty(element)</code>可能存在问题，因为<code>this.items</code>的原型可能已经改写<code>hasOwnProperty</code>，使用<code>Object</code>最为保险</p>
</li>
<li><p>向集合中添加元素</p>
<p>先判断是否重复再添加</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">add</span>(<span class="params">element</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(!<span class="variable language_">this</span>.<span class="title function_">has</span>(element)) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span>[element]=element;<span class="comment">//添加一个 element 的时候，把它同时作为键和值保存，因为这样有利于查找该元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除某元素</p>
<p>先判断是否存在再删除</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">delete</span>(<span class="params">element</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">has</span>(element)) &#123;</span><br><span class="line">    <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">items</span>[element];<span class="comment">//键值名相同，可以直接删除</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>清空集合</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">clear</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">items</span>=&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取集合大小</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="variable language_">this</span>.<span class="property">items</span>).<span class="property">length</span>;<span class="comment">//Object 类有一个 keys 方法，它返回一个包含给定对象所有属性的数组。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取集合的所有值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">values</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">values</span>(<span class="variable language_">this</span>.<span class="property">items</span>);<span class="comment">//Object.values()方法返回了一个包含给定对象所有属性值的数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>以上就是集合类的基本方法了，但我们还需要定义一些用于集合运算的方法</p>
<ul>
<li><p>并集</p>
<p>因为集合的add方法会判断是否重复，所以直接将两个集合的值全部添加到新集合即可</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">union</span>(<span class="params">otherSet</span>)&#123;<span class="comment">//集合的并运算</span></span><br><span class="line">  <span class="keyword">const</span> unionSet=<span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">values</span>().<span class="title function_">forEach</span>(<span class="function"><span class="params">value</span>=&gt;</span>unionSet.<span class="title function_">add</span>(value));</span><br><span class="line">  otherSet.<span class="title function_">values</span>().<span class="title function_">forEach</span>(<span class="function"><span class="params">value</span>=&gt;</span>unionSet.<span class="title function_">add</span>(value));<span class="comment">//因为add方法会检查是否重复，直接全部添加即可</span></span><br><span class="line">  <span class="keyword">return</span> unionSet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>交集</p>
<p>对两个集合中较小的那个集合进行遍历，判断再另一个集合中是否存在遍历到的值，存在就添加</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">intersection</span>(<span class="params">otherSet</span>) &#123;<span class="comment">//集合的交运算</span></span><br><span class="line">  <span class="keyword">const</span> intersectionSet=<span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">  <span class="keyword">const</span> values=<span class="variable language_">this</span>.<span class="title function_">values</span>();</span><br><span class="line">  <span class="keyword">const</span> otherValues=otherSet.<span class="title function_">values</span>();</span><br><span class="line">  <span class="keyword">let</span> bigValues=values;</span><br><span class="line">  <span class="keyword">let</span> smallValues=otherValues;</span><br><span class="line">  <span class="keyword">if</span>(otherValues.<span class="property">length</span>&gt;values.<span class="property">length</span>) &#123;</span><br><span class="line">    bigValues=otherValues;</span><br><span class="line">    smallValues=values;</span><br><span class="line">  &#125;<span class="comment">//确定数组长度关系，减少迭代次数</span></span><br><span class="line">  smallValues.<span class="title function_">forEach</span>(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(bigValues.<span class="title function_">includes</span>(value)) &#123;</span><br><span class="line">      intersectionSet.<span class="title function_">add</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> intersectionSet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>差集</p>
<p>与交集类似，但是遍历到的元素若在另一个集合中不存在则添加</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">difference</span>(<span class="params">otherSet</span>) &#123;<span class="comment">//集合的差集运算</span></span><br><span class="line">  <span class="keyword">const</span> differenceSet=<span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">values</span>().<span class="title function_">forEach</span>(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!otherSet.<span class="title function_">has</span>(value)) &#123;</span><br><span class="line">      differenceSet.<span class="title function_">add</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> differenceSet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>子集</p>
<p>首先比较大小，大的不可能是小的的子集</p>
<p>然后遍历，若发现某个值不存在于大集合中则跳出，全部存在则返回true</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">isSubsetOf</span>(<span class="params">otherSet</span>) &#123;<span class="comment">//判断是否是otherSet的子集</span></span><br><span class="line">  <span class="keyword">if</span>(otherSet.<span class="title function_">size</span>()&lt;<span class="variable language_">this</span>.<span class="title function_">size</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> isSubset=<span class="literal">true</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">values</span>().<span class="title function_">every</span>(<span class="function"><span class="params">value</span>=&gt;</span>&#123;<span class="comment">//every:直到返回false退出</span></span><br><span class="line">    <span class="keyword">if</span>(!otherSet.<span class="title function_">has</span>(value)) &#123;</span><br><span class="line">      isSubset=<span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> isSubset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>这样我们创建的集合类就包含了基本的集合操作方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Set</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span>=&#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">has</span>(<span class="params">element</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">hasOwnProperty</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>.<span class="property">items</span>,element);<span class="comment">//判断element是否在items中</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">add</span>(<span class="params">element</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="variable language_">this</span>.<span class="title function_">has</span>(element)) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">items</span>[element]=element;<span class="comment">//添加一个 element 的时候，把它同时作为键和值保存，因为这样有利于查找该元素</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">delete</span>(<span class="params">element</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">has</span>(element)) &#123;</span><br><span class="line">      <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">items</span>[element];<span class="comment">//键值名相同，可以直接删除</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">clear</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span>=&#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="variable language_">this</span>.<span class="property">items</span>).<span class="property">length</span>;<span class="comment">//Object 类有一个 keys 方法，它返回一个包含给定对象所有属性的数组。</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">values</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">values</span>(<span class="variable language_">this</span>.<span class="property">items</span>);<span class="comment">//Object.values()方法返回了一个包含给定对象所有属性值的数组</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">union</span>(<span class="params">otherSet</span>)&#123;<span class="comment">//集合的并运算</span></span><br><span class="line">    <span class="keyword">const</span> unionSet=<span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">values</span>().<span class="title function_">forEach</span>(<span class="function"><span class="params">value</span>=&gt;</span>unionSet.<span class="title function_">add</span>(value));</span><br><span class="line">    otherSet.<span class="title function_">values</span>().<span class="title function_">forEach</span>(<span class="function"><span class="params">value</span>=&gt;</span>unionSet.<span class="title function_">add</span>(value));<span class="comment">//因为add方法会检查是否重复，直接全部添加即可</span></span><br><span class="line">    <span class="keyword">return</span> unionSet;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">intersection</span>(<span class="params">otherSet</span>) &#123;<span class="comment">//集合的交运算</span></span><br><span class="line">    <span class="keyword">const</span> intersectionSet=<span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">    <span class="keyword">const</span> values=<span class="variable language_">this</span>.<span class="title function_">values</span>();</span><br><span class="line">    <span class="keyword">const</span> otherValues=otherSet.<span class="title function_">values</span>();</span><br><span class="line">    <span class="keyword">let</span> bigValues=values;</span><br><span class="line">    <span class="keyword">let</span> smallValues=otherValues;</span><br><span class="line">    <span class="keyword">if</span>(otherValues.<span class="property">length</span>&gt;values.<span class="property">length</span>) &#123;</span><br><span class="line">      bigValues=otherValues;</span><br><span class="line">      smallValues=values;</span><br><span class="line">    &#125;<span class="comment">//确定数组长度关系，减少迭代次数</span></span><br><span class="line">    smallValues.<span class="title function_">forEach</span>(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(bigValues.<span class="title function_">includes</span>(value)) &#123;</span><br><span class="line">        intersectionSet.<span class="title function_">add</span>(value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> intersectionSet;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">difference</span>(<span class="params">otherSet</span>) &#123;<span class="comment">//集合的差集运算</span></span><br><span class="line">    <span class="keyword">const</span> differenceSet=<span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">values</span>().<span class="title function_">forEach</span>(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(!otherSet.<span class="title function_">has</span>(value)) &#123;</span><br><span class="line">        differenceSet.<span class="title function_">add</span>(value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> differenceSet;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">isSubsetOf</span>(<span class="params">otherSet</span>) &#123;<span class="comment">//判断是否是otherSet的子集</span></span><br><span class="line">    <span class="keyword">if</span>(otherSet.<span class="title function_">size</span>()&lt;<span class="variable language_">this</span>.<span class="title function_">size</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> isSubset=<span class="literal">true</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">values</span>().<span class="title function_">every</span>(<span class="function"><span class="params">value</span>=&gt;</span>&#123;<span class="comment">//every:直到返回false退出</span></span><br><span class="line">      <span class="keyword">if</span>(!otherSet.<span class="title function_">has</span>(value)) &#123;</span><br><span class="line">        isSubset=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> isSubset;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ES2015提供的集合类"><a href="#ES2015提供的集合类" class="headerlink" title="ES2015提供的集合类"></a>ES2015提供的集合类</h4><p>ES6也为我们提供了一个set类</p>
<p>与我们编写的set类不同的是，ES6提供的set类中的没有集合运算的相关方法，<code>size</code>是作为Set的一个属性。</p>
<p>我们可以为Set类编写相关集合运算的函数，下面的代码展示了并集函数的模拟</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">union</span>=(<span class="params">setA,setB</span>)=&gt;&#123;<span class="comment">//模拟并集函数</span></span><br><span class="line">  <span class="keyword">const</span> unionAB=<span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">  setA.<span class="title function_">forEach</span>(<span class="function"><span class="params">value</span>=&gt;</span>unionAB.<span class="title function_">add</span>(value));</span><br><span class="line">  setB.<span class="title function_">forEach</span>(<span class="function"><span class="params">value</span>=&gt;</span>unionAB.<span class="title function_">add</span>(value));</span><br><span class="line">  <span class="keyword">return</span> unionAB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用拓展运算符<code>...</code>会让编写变得更简洁</p>
<p><code>...</code>作用是将值展开为一个数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> unionAB=<span class="keyword">new</span> <span class="title class_">Set</span>([...setA,...setB])<span class="comment">//并集</span></span><br><span class="line"><span class="keyword">const</span> intersectionAB=<span class="keyword">new</span> <span class="title class_">Set</span>([...setA].<span class="title function_">filter</span>(<span class="function"><span class="params">value</span>=&gt;</span>setB.<span class="title function_">has</span>(value)));<span class="comment">//交集</span></span><br><span class="line"><span class="keyword">const</span> differenceAB=<span class="keyword">new</span> <span class="title class_">Set</span>([...setA].<span class="title function_">filter</span>(<span class="function"><span class="params">value</span>=&gt;</span>!setB.<span class="title function_">has</span>(value)));<span class="comment">//差集</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>数据结构</tag>
        <tag>集合</tag>
      </tags>
  </entry>
</search>
